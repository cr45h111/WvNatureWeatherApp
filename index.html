<!DOCTYPE html>
<html lang="en">
<head>
<meta name="description" content="Immersive West Virginia nature simulation with real-time weather, astronomy, and interactive ecosystem">
<meta name="keywords" content="nature simulation, West Virginia, weather, astronomy, relaxation">
<meta name="author" content="Chris Fisher">
<meta property="og:title" content="West Virginia Nature Simulation">
<meta property="og:description" content="Experience the beauty of West Virginia nature">
<meta property="og:type" content="website">
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸŒ²</text></svg>">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no,viewport-fit=cover">
<meta name="theme-color" content="#0a1628">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="WV Nature & Weather">
<meta name="application-name" content="WV Nature & Weather">
<meta name="mobile-web-app-capable" content="yes">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon-192.png">
<title>West Virginia Nature Simulation</title>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8931239245129969"
     crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
body{overflow:hidden;background:#000;font-family:'Courier New',monospace;}
canvas{display:block;width:100vw;height:100vh;cursor:crosshair;}
.btn{position:absolute;background:rgba(0,255,255,0.2);border:2px solid #0ff;color:#0ff;padding:8px 16px;border-radius:8px;cursor:pointer;font-family:'Courier New',monospace;font-size:11px;text-shadow:0 0 10px rgba(0,255,255,0.8);transition:all 0.3s;z-index:100;}
.btn:hover{background:rgba(0,255,255,0.4);box-shadow:0 0 20px rgba(0,255,255,0.6);}
.btn.active{background:rgba(0,255,255,0.4);}
.btn.hidden{opacity:0;pointer-events:none;}
#quickActionsBtn{top:20px;right:470px;}
#fullscreenBtn{top:20px;right:320px;}
#settingsBtn{top:20px;right:170px;}
#hideBtn{top:20px;right:20px;}
#soundBtn{top:70px;right:470px;}
#storeBtn{top:70px;right:320px;}
#infoPanelBtn{top:70px;right:170px;}
#clockBtn{top:70px;right:20px;}
#plantHealthBtn{top:120px;right:320px;}
#birdGuideBtn{top:120px;right:170px;}
#supportBtn{top:120px;right:20px;}
#alarmBtn{display:none;}
#locationBtn{display:none;}
#forecastBtn{display:none;}
#moonBtn{display:none;}

#ui{position:absolute;bottom:20px;right:20px;color:#0ff;font-size:11px;background:rgba(0,0,0,0.88);padding:14px 18px;border-radius:10px;line-height:2;text-shadow:0 0 12px rgba(0,255,255,0.7);text-align:right;border:1px solid rgba(0,255,255,0.3);max-width:280px;transition:opacity 0.3s;z-index:100;}
#ui.hidden{opacity:0;pointer-events:none;}
#adBanner{position:fixed;left:12px;bottom:12px;z-index:120;width:min(340px,90vw);min-height:50px;background:rgba(0,0,0,0.65);border:1px solid rgba(0,255,255,0.2);border-radius:8px;padding:6px 8px;display:flex;align-items:center;justify-content:center;box-shadow:0 0 12px rgba(0,255,255,0.25);}
#adBanner.ad-hidden{display:none;}
#fpsCounter{position:absolute;top:10px;left:10px;color:#0ff;font-size:12px;background:rgba(0,0,0,0.7);padding:6px 10px;border-radius:5px;border:1px solid rgba(0,255,255,0.3);display:none;z-index:100;text-shadow:0 0 8px rgba(0,255,255,0.6);}
#fpsCounter.visible{display:block;}
#tutorialOverlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.75);display:none;z-index:300;align-items:center;justify-content:center;}
#tutorialOverlay.visible{display:flex;}
#tutorialContent{background:rgba(0,30,40,0.98);border:3px solid #0ff;border-radius:15px;padding:20px;max-width:450px;max-height:60vh;overflow-y:auto;box-shadow:0 0 50px rgba(0,255,255,0.8);color:#0ff;font-family:'Courier New',monospace;}
#tutorialContent h2{font-size:20px;margin:0 0 15px 0;text-shadow:0 0 20px rgba(0,255,255,0.6);}
#tutorialContent p{margin:8px 0;font-size:12px;line-height:1.5;color:#0cf;}
.tutorial-section{margin:12px 0;padding:10px;background:rgba(0,100,120,0.3);border-left:4px solid #0aa;border-radius:5px;}
.tutorial-buttons{display:flex;gap:8px;margin-top:15px;justify-content:center;flex-wrap:wrap;}
.tutorial-btn{background:rgba(0,255,255,0.2);border:2px solid #0ff;color:#0ff;padding:8px 16px;border-radius:6px;cursor:pointer;font-family:'Courier New',monospace;font-size:11px;transition:all 0.3s;}
.tutorial-btn:hover{background:rgba(0,255,255,0.4);box-shadow:0 0 15px rgba(0,255,255,0.5);}
#sceneNotification{position:fixed;top:100px;left:50%;transform:translateX(-50%);background:rgba(0,150,180,0.95);border:2px solid #0ff;border-radius:8px;padding:12px 20px;color:#0ff;font-family:'Courier New',monospace;font-size:12px;display:none;z-index:250;animation:slideDown 0.4s ease-out;}
#sceneNotification.visible{display:block;}
@keyframes slideDown{from{transform:translateX(-50%) translateY(-30px);opacity:0}to{transform:translateX(-50%) translateY(0);opacity:1}}
#plantTooltip{position:absolute;background:rgba(0,30,40,0.95);border:2px solid #0ff;border-radius:8px;padding:10px 12px;color:#0ff;font-family:'Courier New',monospace;font-size:11px;display:none;z-index:150;pointer-events:none;max-width:150px;text-align:center;line-height:1.4;box-shadow:0 0 15px rgba(0,255,255,0.4);}
#seasonalAlert{position:fixed;top:100px;right:20px;background:rgba(100,150,50,0.95);border:2px solid #88ff00;border-radius:10px;padding:15px 20px;color:#00ff00;font-family:'Courier New',monospace;font-size:12px;display:none;z-index:250;max-width:280px;box-shadow:0 0 20px rgba(100,200,0,0.6);animation:slideIn 0.4s ease-out;}
#seasonalAlert.visible{display:block;}
@keyframes slideIn{from{transform:translateX(400px);opacity:0}to{transform:translateX(0);opacity:1}}
.label{color:#0cf;opacity:0.8;}
.modal{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,30,40,0.98);border:3px solid #0ff;border-radius:12px;box-shadow:0 0 50px rgba(0,255,255,0.8);display:none;z-index:200;}
.modal.visible{display:block;}
.modal-header{background:rgba(0,100,120,0.5);padding:12px 20px;border-bottom:2px solid #0ff;display:flex;justify-content:space-between;align-items:center;border-radius:8px 8px 0 0;}
.modal-header h2{color:#0ff;font-size:18px;margin:0;}
.modal-controls{display:flex;gap:8px;}
.modal-controls button{background:rgba(0,255,255,0.3);border:1px solid #0ff;color:#0ff;width:24px;height:24px;border-radius:4px;cursor:pointer;font-size:14px;line-height:1;}
.modal-controls button:hover{background:rgba(0,255,255,0.5);}
.modal-body{padding:20px;max-width:90vw;max-height:70vh;overflow-y:auto;color:#0ff;}
#store .modal-body{max-width:800px;}
.store-category{margin-bottom:25px;}
.store-category h3{color:#0cf;margin-bottom:12px;font-size:16px;border-bottom:2px solid #0cf;padding-bottom:5px;}
.item-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:12px;}
.item{background:rgba(0,50,70,0.6);border:2px solid #0aa;padding:10px;border-radius:8px;cursor:pointer;transition:all 0.3s;text-align:center;}
.item:hover{background:rgba(0,80,100,0.8);border-color:#0ff;transform:scale(1.05);box-shadow:0 0 20px rgba(0,255,255,0.4);}
.item.selected{background:rgba(0,100,120,0.9);border-color:#0ff;box-shadow:0 0 25px rgba(0,255,255,0.6);}
.item.remove-mode{background:rgba(100,20,20,0.6);border-color:#f00;}
.item-name{color:#0ff;font-size:11px;font-weight:bold;margin-top:5px;}
.item-icon{font-size:28px;}
#removeModeBtn{background:rgba(255,100,0,0.3);border-color:#ff6600;color:#ff6600;width:100%;padding:10px;margin-bottom:15px;border-radius:6px;cursor:pointer;border:2px solid #ff6600;}
#removeModeBtn.active{background:rgba(255,50,0,0.5);}
#clock{position:absolute;bottom:2%;left:50%;transform:translateX(-50%);font-size:80px;color:rgba(0,255,255,0.9);text-shadow:0 0 30px rgba(0,100,150,0.8);font-weight:bold;pointer-events:none;display:none;font-family:'Courier New',monospace;z-index:50;text-align:center;background:rgba(0,50,80,0.85);padding:20px 40px;border-radius:15px;border:2px solid rgba(0,255,255,0.4);}
#clock.visible{display:block;}
#clockTemp{font-size:32px;margin-top:10px;}
#weatherAlert{position:absolute;top:20px;left:50%;transform:translateX(-50%);background:rgba(255,100,0,0.95);border:3px solid #ff6600;border-radius:10px;padding:15px 20px;display:none;box-shadow:0 0 40px rgba(255,100,0,0.6);z-index:250;color:#fff;max-width:400px;}
#weatherAlert.visible{display:block;}
#closeAlert{float:right;background:transparent;border:none;color:#fff;font-size:18px;cursor:pointer;margin:-5px -5px 0 10px;}
input,select{background:rgba(0,50,70,0.8);border:2px solid #0aa;color:#0ff;padding:8px;margin:8px 0;border-radius:5px;font-size:14px;width:100%;}
.form-group{margin:15px 0;}
.form-group label{display:block;margin-bottom:5px;color:#0cf;}
.modal-btn-wrapper{display:flex;flex-direction:column;gap:10px;margin-top:20px;}
.modal-btn{background:rgba(0,255,255,0.2);border:2px solid #0ff;color:#0ff;padding:10px 16px;border-radius:6px;cursor:pointer;font-family:'Courier New',monospace;font-size:12px;width:100%;transition:all 0.3s;}
.modal-btn:hover{background:rgba(0,255,255,0.4);box-shadow:0 0 15px rgba(0,255,255,0.5);}
.modal-btn.danger{background:rgba(255,0,0,0.2);border-color:#f00;color:#f00;}
.modal-btn.danger:hover{background:rgba(255,0,0,0.4);}
canvas:-webkit-full-screen{background:#000;}
canvas:-moz-full-screen{background:#000;}
canvas:fullscreen{background:#000;}
#loader{position:fixed;top:0;left:0;width:100vw;height:100vh;background:linear-gradient(135deg,#0a1628 0%,#1a2a45 100%);display:flex;align-items:center;justify-content:center;z-index:9999;transition:opacity 0.5s,visibility 0.5s;}
#loader.hidden{opacity:0;visibility:hidden;}
.loader-content{text-align:center;max-width:700px;padding-top:60px;padding-bottom:60px;}
.spinner{width:80px;height:80px;border:6px solid rgba(0,255,255,0.1);border-top-color:#0ff;border-radius:50%;margin:0 auto 30px;animation:spin 1s linear infinite;}
@keyframes spin{to{transform:rotate(360deg);}}
#loader h1{color:#0ff;font-size:28px;margin:20px 0;text-shadow:0 0 20px rgba(0,255,255,0.6);font-family:'Courier New',monospace;}
.loading-text{color:#0cf;font-size:16px;margin:15px 0;font-family:'Courier New',monospace;}
.loader-logo{width:140px;max-width:55vw;height:auto;margin:14px auto 0;opacity:0.85;filter:drop-shadow(0 0 10px rgba(0,255,255,0.35));}
.progress-bar{width:100%;height:8px;background:rgba(0,255,255,0.1);border-radius:4px;overflow:hidden;margin-top:20px;}
.progress-fill{height:100%;background:linear-gradient(90deg,#0ff 0%,#0cf 100%);width:0%;transition:width 0.3s;box-shadow:0 0 10px rgba(0,255,255,0.5);}
#plantHealthPanel{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,30,40,0.98);border:3px solid #0ff;border-radius:12px;padding:20px;max-width:500px;max-height:70vh;overflow-y:auto;display:none;z-index:200;color:#0ff;font-family:'Courier New',monospace;box-shadow:0 0 50px rgba(0,255,255,0.8);}
#plantHealthPanel.visible{display:block;}
.plant-health-item{margin-bottom:16px;padding:12px;background:rgba(0,100,120,0.3);border-radius:8px;border-left:4px solid #0ff;}
.plant-health-header{display:flex;align-items:center;gap:8px;margin-bottom:8px;font-weight:bold;color:#0cf;}
.plant-health-icon{font-size:20px;}
.plant-health-name{flex:1;}
.plant-health-status{font-size:11px;color:#aaa;margin-top:4px;}
.health-bar{width:100%;height:12px;background:rgba(0,50,70,0.6);border:1px solid #0aa;border-radius:4px;margin:6px 0;overflow:hidden;}
.health-fill{height:100%;transition:width 0.3s;display:flex;align-items:center;justify-content:center;font-size:9px;color:#000;font-weight:bold;}
.health-excellent{background:linear-gradient(90deg,#00ff00,#00dd00);width:100%;}
.health-good{background:linear-gradient(90deg,#88ff00,#66dd00);}
.health-fair{background:linear-gradient(90deg,#ffff00,#dddd00);}
.health-poor{background:linear-gradient(90deg,#ff8800,#dd6600);}
.health-critical{background:linear-gradient(90deg,#ff0000,#dd0000);}
.seasonal-badge{display:inline-block;padding:2px 6px;background:rgba(0,255,255,0.2);border:1px solid #0aa;border-radius:3px;font-size:10px;margin-top:4px;color:#0cf;}
#plantHealthBtn{display:none;}
#plantHealthPanel h2{margin-top:0;color:#0cf;border-bottom:2px solid #0ff;padding-bottom:12px;}
</style>
</head>
<body>
<canvas id="canvas" style="position:absolute;top:0;left:0;z-index:1;"></canvas>
<canvas id="canvasLayer1" style="position:absolute;top:0;left:0;z-index:3;pointer-events:none;"></canvas>
<canvas id="canvasLayer2" style="position:absolute;top:0;left:0;z-index:5;pointer-events:none;"></canvas>
<canvas id="canvasLayer3" style="position:absolute;top:0;left:0;z-index:12;pointer-events:none;"></canvas>
<canvas id="canvasLayer4" style="position:absolute;top:0;left:0;z-index:14;pointer-events:none;"></canvas>
<button id="hideBtn" class="btn">ğŸ‘ï¸ Hide UI</button>
<button id="soundBtn" class="btn">ï¿½ OFF</button>
<button id="fullscreenBtn" class="btn">â›¶ Fullscreen</button>
<button id="infoPanelBtn" class="btn active">ğŸ“Š Info</button>
<button id="quickActionsBtn" class="btn">âš¡ Quick Actions</button>
<button id="storeBtn" class="btn">ğŸª Store</button>
<button id="clockBtn" class="btn">ğŸ• Clock</button>
<button id="alarmBtn" class="btn">â° Alarm</button>
<button id="locationBtn" class="btn">ğŸ“ Location</button>

<button id="plantHealthBtn" class="btn">ğŸŒ¿ Health</button>
<button id="settingsBtn" class="btn">âš™ï¸ Settings</button>
<button id="supportBtn" class="btn" onclick="openSupportLink()">â˜• Support</button>

<div id="fpsCounter">FPS: 0</div>

<div id="tutorialOverlay">
  <div id="tutorialContent">
    <h2>ğŸŒ² Welcome to WV Nature & Weather</h2>
    
    <div class="tutorial-section">
      <p><strong>ğŸ® Getting Started:</strong> Drag your mouse (or finger on mobile) to look around. The world updates in real-time with actual weather and accurate astronomy!</p>
    </div>

    <div class="tutorial-section">
      <p><strong>ğŸ“ Set Your Location (IMPORTANT!):</strong> This is the first thing you should do! Click the "âš™ï¸ Settings" button to configure your location. You can:</p>
      <p style="font-size:11px;margin:4px 0;">â€¢ Enter your city name and coordinates manually (Latitude/Longitude)</p>
      <p style="font-size:11px;margin:4px 0;">â€¢ Search by ZIP code for automatic location detection</p>
      <p style="font-size:11px;">By setting your location, you unlock:</p>
      <p style="font-size:11px;margin:4px 0;">ğŸŒ¡ï¸ Real-time weather data for your exact area â€¢ ğŸŒ™ Accurate moon phases & rise/set times â€¢ â­ Correct star positions & constellations â€¢ ğŸŒ Precise sunrise/sunset times â€¢ ğŸ¦… Relevant bird species for your region</p>
      <p style="font-size:11px;color:#ff9900;"><strong>ğŸ’¡ Note: Default location is Hacker Valley, WV. Change it for your area!</strong></p>
    </div>

    <div class="tutorial-section">
      <p><strong>ğŸª Building Your Scene:</strong> Click the "ğŸª Store" button to browse and place items. Select something, then click on the canvas to add it to your scene. Remove items with the "Remove Mode" toggle.</p>
    </div>

    <div class="tutorial-section">
      <p><strong>ğŸŒ¿ Plant Types Available:</strong></p>
      <p style="font-size:11px;margin:4px 0;">ğŸŒ² Trees (Oak, Maple, Pine) â€¢ ğŸŒ¸ Flowers (Wildflowers, Daisies) â€¢ ğŸŒ¿ Shrubs & Bushes â€¢ ğŸ Fruit Trees</p>
      <p style="font-size:11px;">ğŸ’¡ Tip: Plants need sunlight during the day and water. Check plant health regularly!</p>
    </div>

    <div class="tutorial-section">
      <p><strong>ğŸ¦Œ Wildlife & Creatures:</strong> Animals appear naturally based on time of day and season. You'll see:</p>
      <p style="font-size:11px;margin:4px 0;">ğŸ¦Œ Deer (grazing during day) â€¢ ğŸ° Bunnies (active dawn/dusk) â€¢ ğŸ¦‰ Owls (hooting at night) â€¢ ğŸ¦‡ Bats (at dusk) â€¢ ğŸŸ Fish (jumping in water)</p>
    </div>

    <div class="tutorial-section">
      <p><strong>â° Time & Weather:</strong> Check the info panel (bottom right) to see:</p>
      <p style="font-size:11px;margin:4px 0;">ğŸ“ Your location â€¢ ğŸ• Local time â€¢ ğŸŒ Sunrise/Sunset â€¢ ğŸŒ™ Moon phase â€¢ ğŸŒ¡ï¸ Temperature & Weather</p>
      <p style="font-size:11px;">ğŸ’¡ Weather changes every day! Storm, snow, clear skies, etc.</p>
    </div>

      <div class="tutorial-section">
        <p><strong>ğŸ“š Community History (New!):</strong> Every 30 minutes, you may see a gentle â€œDid You Know?â€ popup about your townâ€”founding details, key moments, and nearby historic sites.</p>
        <p style="font-size:11px;margin:4px 0;">ğŸŒŸ Each popup includes an astronomy connection, linking historical dates to the night sky you see today.</p>
        <p style="font-size:11px;">If no data is available for your location, nothing is shown.</p>
      </div>

    <div class="tutorial-section">
      <p><strong>ğŸŒŸ Stars & Constellations:</strong> On clear nights, hover over stars to learn about them and their constellations. Astronomy is accurate for West Virginia!</p>
    </div>

    <div class="tutorial-section">
      <p><strong>ğŸŒ± Plant Health Monitor:</strong> Click "ğŸŒ¿ Health" to see all your plants. You can track:</p>
      <p style="font-size:11px;margin:4px 0;">ğŸ“Š Health status â€¢ ğŸŒ¡ï¸ Age & maturity â€¢ ğŸ“ˆ Growth progress â€¢ ğŸŒ¿ Seasonal changes</p>
    </div>

    <div class="tutorial-section">
      <p><strong>ğŸµ Sound & Music:</strong> Enable sounds in settings to hear:</p>
      <p style="font-size:11px;margin:4px 0;">ğŸ¦‰ Owl hoots â€¢ ğŸ¦‡ Bat squeaks â€¢ ğŸŸ Fish jumping â€¢ ğŸ’§ Water & rain â€¢ ğŸ¼ Ambient music & wind</p>
      <p style="font-size:11px;">Control volumes individually in Settings!</p>
    </div>

    <div class="tutorial-section">
      <p><strong>ğŸ’¾ Save & Load Scenes:</strong> Use "âš¡ Quick Actions" to save your favorite layouts. Give them names and reload them anytime!</p>
    </div>

    <div class="tutorial-section">
      <p><strong>ğŸ“¸ Share Your Creations:</strong> Use the screenshot button (in Quick Actions) to capture your scenes and share on social media!</p>
    </div>

    <div class="tutorial-section">
      <p><strong>âš™ï¸ Customize Everything:</strong> Settings let you adjust:</p>
      <p style="font-size:11px;margin:4px 0;">ğŸŒ«ï¸ Cloud appearance â€¢ ğŸ”Š Sound volumes â€¢ ğŸ“ Location â€¢ ğŸŒ Zoom level</p>
    </div>

    <div class="tutorial-section">
      <p><strong>ğŸ“± Mobile Tips:</strong> Touch the screen and drag to move around. Tap a star or plant to see info (instead of hovering). Button layouts are optimized for portrait and landscape!</p>
    </div>

    <div class="tutorial-buttons">
      <button class="tutorial-btn" onclick="skipTutorial()">Skip</button>
      <button class="tutorial-btn" onclick="closeTutorial()">Got It!</button>
    </div>
  </div>
</div>

<div id="sceneNotification"></div>
<div id="plantTooltip"></div>
<div id="seasonalAlert"></div>

<div id="adBanner" class="ad-hidden" aria-label="Advertisement"></div>

<div id="ui">
  <strong id="locationName">HACKER VALLEY, WV</strong><br>
  <span class="label">Time:</span> <span id="localtime">--:--</span><br>
  <span class="label">Sun:</span> <span id="suninfo">--</span> <span id="sunriseset" style="font-size:9px;">--</span><br>
  <span class="label">Moon:</span> <span id="mooninfo" style="font-size:10px;line-height:1.4;">--</span> <span id="moonriseset" style="font-size:9px;">--</span><br>
  <span class="label">Weather:</span> <span id="weather">--</span> <span id="weatherIcon"></span><br>
  <span class="label">Temp:</span> <span id="temp">--Â°F</span> | <span class="label">Wind:</span> <span id="wind">--mph</span><br>
  <span class="label">Humidity:</span> <span id="humidity">--%</span><br>
  <span class="label">Items:</span> <span id="itemCount">0</span><br>
  <span class="label">Birds:</span> <span id="birds">0</span><br>
  <span class="label">Mode:</span> <span id="selected">None</span>
</div>

<div id="clock"><div id="clockTime"></div><div id="clockTemp"></div></div>

<div id="weatherAlert">
  <button id="closeAlert">âœ•</button>
  <strong id="alertTitle"></strong>
  <p id="alertMessage" style="margin:5px 0 0 0;"></p>
</div>

<div id="weatherBeacon" style="position:absolute;bottom:30%;right:10%;width:60px;height:120px;cursor:pointer;display:none;z-index:150;">
  <svg width="60" height="120" viewBox="0 0 60 120">
    <defs>
      <radialGradient id="beaconGlow">
        <stop offset="0%" style="stop-color:#ff0000;stop-opacity:1" />
        <stop offset="100%" style="stop-color:#ff0000;stop-opacity:0" />
      </radialGradient>
    </defs>
    <rect x="25" y="80" width="10" height="40" fill="#666"/>
    <polygon points="20,80 40,80 35,40 25,40" fill="#888"/>
    <polygon points="25,40 35,40 32,20 28,20" fill="#aaa"/>
    <circle id="beaconLight" cx="30" cy="15" r="8" fill="#ff0000">
      <animate attributeName="opacity" values="1;0.3;1" dur="1s" repeatCount="indefinite"/>
    </circle>
    <circle cx="30" cy="15" r="15" fill="url(#beaconGlow)" opacity="0.6">
  </div>
      <animate attributeName="r" values="15;25;15" dur="1s" repeatCount="indefinite"/>
      <animate attributeName="opacity" values="0.6;0.2;0.6" dur="1s" repeatCount="indefinite"/>
    </circle>
  </svg>
</div>
<div id="beaconAlert" class="modal">
  <div class="modal-header">
    <h2>âš ï¸ Weather Warning</h2>
    <div class="modal-controls">
      <button onclick="closeBeaconAlert()">âœ•</button>
    </div>
  </div>
  <div class="modal-body">
    <p id="beaconAlertMessage" style="font-size:14px;line-height:1.6;"></p>
  </div>
</div>

<div id="saveSceneModal" class="modal">
  <div class="modal-header">
    <h2>ğŸ’¾ Save Scene</h2>
    <div class="modal-controls">
      <button onclick="document.getElementById('saveSceneModal').classList.remove('visible')">âœ•</button>
    </div>
  </div>
  <div class="modal-body">
    <div class="form-group">
      <label for="sceneName">Scene Name:</label>
      <input id="sceneName" type="text" placeholder="My Garden Scene">
    </div>
    <div class="modal-btn-wrapper">
      <button class="modal-btn" onclick="saveSceneFromModal()">ğŸ’¾ Save</button>
      <button class="modal-btn" onclick="document.getElementById('saveSceneModal').classList.remove('visible')">Cancel</button>
    </div>
  </div>
</div>

<div id="loadSceneModal" class="modal">
  <div class="modal-header">
    <h2>ğŸ“‚ Load Scene</h2>
    <div class="modal-controls">
      <button onclick="document.getElementById('loadSceneModal').classList.remove('visible')">âœ•</button>
    </div>
  </div>
  <div class="modal-body">
    <div id="sceneList" style="max-height:400px;overflow-y:auto;"></div>
  </div>
</div>

<div id="alarmModal" class="modal">
  <div class="modal-header">
    <h2>â° Set Alarm</h2>
    <div class="modal-controls">
      <button onclick="closeAlarmModal()">âœ•</button>
    </div>
  </div>
  <div class="modal-body">
    <div class="form-group">
      <label for="alarmTime">Alarm Time:</label>
      <input id="alarmTime" type="time">
    </div>
    <div class="form-group">
      <label for="alarmSound">Sound:</label>
      <select id="alarmSound">
        <option value="birds">Birds</option>
        <option value="beep">Beep</option>
        <option value="chime">Chime</option>
        <option value="siren">Siren</option>
      </select>
    </div>
    <div class="modal-btn-wrapper">
      <button class="modal-btn" onclick="setAlarm()">Save</button>
      <button class="modal-btn danger" onclick="clearAlarm()">Clear</button>
    </div>
  </div>
</div>
<div id="settingsModal" class="modal">
  <div class="modal-header">
    <h2>âš™ï¸ Settings</h2>
    <div class="modal-controls">
      <button onclick="document.getElementById('settingsModal').classList.remove('visible')">âœ•</button>
    </div>
  </div>
  <div class="modal-body">
    <h3>Test Triggers</h3>
    <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:12px">
      <button class="modal-btn" onclick="testSpawnBunny()">ğŸ° Spawn Bunny</button>
      <button class="modal-btn" onclick="testCatfishFeeding()">ğŸŸ Test Catfish Feeding (9PM)</button>
      <button class="modal-btn" onclick="showFishDebug()">ğŸ‘ï¸ Show Fish Debug Info</button>
    </div>
    <h3>Sound Controls</h3>
    <div style="display:flex;flex-direction:column;gap:12px;margin-bottom:12px">
      <div>
        <button class="modal-btn" id="toggleOwlBtn" onclick="toggleOwlSound()">ğŸ¦‰ Owl: ON</button>
        <div style="margin-top:4px;display:flex;align-items:center;gap:8px"><label style="font-size:11px;min-width:60px">Volume:</label><input type="range" id="owlVolume" min="0" max="100" value="40" style="flex:1" oninput="updateOwlVolume(this.value)"><span id="owlVolVal" style="font-size:11px;min-width:35px">40%</span></div>
      </div>
      <div>
        <button class="modal-btn" id="toggleFishSplashBtn" onclick="toggleFishSplashSound()">ğŸ’¦ Fish Splash: ON</button>
        <div style="margin-top:4px;display:flex;align-items:center;gap:8px"><label style="font-size:11px;min-width:60px">Volume:</label><input type="range" id="fishSplashVolume" min="0" max="100" value="60" style="flex:1" oninput="updateFishSplashVolume(this.value)"><span id="fishSplashVolVal" style="font-size:11px;min-width:35px">60%</span></div>
      </div>
      <div>
        <button class="modal-btn" id="toggleFishEatingBtn" onclick="toggleFishEatingSound()">ğŸŸ Fish Eating: ON</button>
        <div style="margin-top:4px;display:flex;align-items:center;gap:8px"><label style="font-size:11px;min-width:60px">Volume:</label><input type="range" id="fishEatingVolume" min="0" max="100" value="40" style="flex:1" oninput="updateFishEatingVolume(this.value)"><span id="fishEatingVolVal" style="font-size:11px;min-width:35px">40%</span></div>
      </div>
      <div>
        <button class="modal-btn" id="toggleFishJumpingBtn" onclick="toggleFishJumpingSound()">ğŸ£ Fish Jumping: ON</button>
        <div style="margin-top:4px;display:flex;align-items:center;gap:8px"><label style="font-size:11px;min-width:60px">Volume:</label><input type="range" id="fishJumpingVolume" min="0" max="100" value="40" style="flex:1" oninput="updateFishJumpingVolume(this.value)"><span id="fishJumpingVolVal" style="font-size:11px;min-width:35px">40%</span></div>
      </div>
      <div>
        <button class="modal-btn" id="toggleBatsBtn" onclick="toggleBatSound()">ğŸ¦‡ Bats: ON</button>
        <div style="margin-top:4px;display:flex;align-items:center;gap:8px"><label style="font-size:11px;min-width:60px">Volume:</label><input type="range" id="batsVolume" min="0" max="100" value="30" style="flex:1" oninput="updateBatsVolume(this.value)"><span id="batsVolVal" style="font-size:11px;min-width:35px">30%</span></div>
      </div>
      <div>
        <button class="modal-btn" id="toggleAmbienceBtn" onclick="toggleAmbienceSound()">ğŸµ Ambience: ON</button>
        <div style="margin-top:4px;display:flex;align-items:center;gap:8px"><label style="font-size:11px;min-width:60px">Volume:</label><input type="range" id="ambienceVolume" min="0" max="100" value="20" style="flex:1" oninput="updateAmbienceVolume(this.value)"><span id="ambienceVolVal" style="font-size:11px;min-width:35px">20%</span></div>
      </div>
      <div>
        <button class="modal-btn" id="toggleCrowsBtn" onclick="toggleCrowSound()">ğŸ¦ Crows: ON</button>
        <div style="margin-top:4px;display:flex;align-items:center;gap:8px"><label style="font-size:11px;min-width:60px">Volume:</label><input type="range" id="crowsVolume" min="0" max="100" value="50" style="flex:1" oninput="updateCrowsVolume(this.value)"><span id="crowsVolVal" style="font-size:11px;min-width:35px">50%</span></div>
      </div>
    </div>
    <h3>Accessibility</h3>
    <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:12px">
      <label><input type="checkbox" id="reduceMotionCheckbox"> Reduce Motion</label>
      <label><input type="checkbox" id="highContrastCheckbox"> High Contrast</label>
      <label><input type="checkbox" id="largeTextCheckbox"> Larger UI Text</label>
    </div>
    <h3>Share</h3>
    <div style="display:flex;gap:8px;flex-wrap:wrap">
      <button class="modal-btn" onclick="shareScene()">Share</button>
      <button class="modal-btn" onclick="copyShareLink()">Copy Link</button>
    </div>
    <h3>Photo Credits</h3>
    <div style="font-size:12px;color:#dfe8ff;line-height:1.5;margin-top:6px">
      <ul style="margin:6px 0 0 16px;padding:0">
        <li>Loading Background â€” Photo by <a href="https://unsplash.com/@tuannguyen728" target="_blank" rel="noopener">Tuan Nguyen</a> on <a href="https://unsplash.com/photos/a-river-running-through-a-lush-green-forest-ElJDeklYUas" target="_blank" rel="noopener">Unsplash</a></li>
        <li>Cardinal â€” Photo by <a href="https://unsplash.com/@jcotten" target="_blank" rel="noopener">Joshua J. Cotten</a> on <a href="https://unsplash.com/photos/oKTGgL5qRwA" target="_blank" rel="noopener">Unsplash</a></li>
        <li>Catfish â€” Photo by <a href="https://unsplash.com/@lauraespana" target="_blank" rel="noopener">Laura EspaÃ±a</a> on <a href="https://unsplash.com/photos/aOQ4hX4KCyk" target="_blank" rel="noopener">Unsplash</a></li>
        <li>Crow â€” Photo by <a href="https://unsplash.com/@dshap" target="_blank" rel="noopener">Daniel Shapiro</a> on <a href="https://unsplash.com/photos/d-vBDK5rqR0" target="_blank" rel="noopener">Unsplash</a></li>
        <li>Robin â€” Photo by <a href="https://unsplash.com/@famouswebsites" target="_blank" rel="noopener">A Perry</a> on <a href="https://unsplash.com/photos/OjhSUsHUIYM" target="_blank" rel="noopener">Unsplash</a></li>
        <li>Sparrow â€” Photo by <a href="https://unsplash.com/@andyjh07" target="_blank" rel="noopener">Andy Holmes</a> on <a href="https://unsplash.com/photos/i-7HDFvmI6E" target="_blank" rel="noopener">Unsplash</a></li>
        <li>Trout â€” Photo by <a href="https://unsplash.com/@stereophototyp" target="_blank" rel="noopener">Sara KurfeÃŸ</a> on <a href="https://unsplash.com/photos/E8AabnQlTlQ" target="_blank" rel="noopener">Unsplash</a></li>
        <li>Willow â€” Photo by <a href="https://unsplash.com/@julianmokzth" target="_blank" rel="noopener">Tianhao Zhang</a> on <a href="https://unsplash.com/photos/TaIsz3PkTsI" target="_blank" rel="noopener">Unsplash</a></li>
        <li>Sycamore â€” Photo by <a href="https://unsplash.com/@artbyhybrid" target="_blank" rel="noopener">Madison Oren</a> on <a href="https://unsplash.com/photos/AuRp3sz6U2c" target="_blank" rel="noopener">Unsplash</a></li>
        <li>Walnut â€” Photo by <a href="https://unsplash.com/@phil_lev" target="_blank" rel="noopener">Phil Lev</a> on <a href="https://unsplash.com/photos/4S7i1VBw4nE" target="_blank" rel="noopener">Unsplash</a></li>
        <li>Poplar â€” Photo by <a href="https://unsplash.com/@daniceg" target="_blank" rel="noopener">Danice G</a> on <a href="https://unsplash.com/photos/uDMKgdRj12E" target="_blank" rel="noopener">Unsplash</a></li>
        <li>Pine â€” Photo by <a href="https://unsplash.com/@scottosbornphoto" target="_blank" rel="noopener">Scott Osborn</a> on <a href="https://unsplash.com/photos/tiU5gPlxMSw" target="_blank" rel="noopener">Unsplash</a></li>
        <li>Oak â€” Photo by <a href="https://unsplash.com/@lierra" target="_blank" rel="noopener">Valerie</a> on <a href="https://unsplash.com/photos/RWGh2UY4F3Q" target="_blank" rel="noopener">Unsplash</a></li>
        <li>Chestnut â€” Photo by <a href="https://unsplash.com/@sqraz" target="_blank" rel="noopener">Slawek</a> on <a href="https://unsplash.com/photos/9xJXsT70u4w" target="_blank" rel="noopener">Unsplash</a></li>
        <li>Hickory â€” Photo by <a href="https://unsplash.com/@scarlettweiss" target="_blank" rel="noopener">Josie Weiss</a> on <a href="https://unsplash.com/photos/uts_bN4MKGk" target="_blank" rel="noopener">Unsplash</a></li>
        <li>Maple â€” Photo by <a href="https://unsplash.com/@alvannee" target="_blank" rel="noopener">Alvan Nee</a> on <a href="https://unsplash.com/photos/99n-8J62UbQ" target="_blank" rel="noopener">Unsplash</a></li>
        <li>Birch â€” Photo by <a href="https://unsplash.com/@markuswinkler" target="_blank" rel="noopener">Markus Winkler</a> on <a href="https://unsplash.com/photos/bHkkPAWZx38" target="_blank" rel="noopener">Unsplash</a></li>
        <li>Beech â€” Photo by <a href="https://unsplash.com/@misky" target="_blank" rel="noopener">Misky</a> on <a href="https://unsplash.com/photos/NcNeb0tQd_0" target="_blank" rel="noopener">Unsplash</a></li>
        <li>Basswood â€” Photo by <a href="https://unsplash.com/@thewritingsample" target="_blank" rel="noopener">Andrew Eroh</a> on <a href="https://unsplash.com/photos/yiHZElVRFoQ" target="_blank" rel="noopener">Unsplash</a></li>
        <li>Laurel â€” Photo by <a href="https://unsplash.com/@pistos" target="_blank" rel="noopener">Jeffrey Hamilton</a> on <a href="https://unsplash.com/photos/X1jizxzHBI8" target="_blank" rel="noopener">Unsplash</a></li>
      </ul>
    </div>
    <h3>About</h3>
    <div style="font-size:13px;color:#dfe8ff;line-height:1.4;margin-top:8px">
      <strong>Wv Nature & Weather</strong><br>
      By Chris Fisher<br>
      Version: 2026.01.23<br>
      Displays an animated nature scene driven by local astronomy and weather data. Audio and visuals can be toggled in Settings. No personal data is collected; location stays on-device.
    </div>
  </div>
</div>
<div id="quickActionsModal" class="modal">
  <div class="modal-header">
    <h2>âš¡ Quick Actions</h2>
    <button onclick="document.getElementById('quickActionsModal').classList.remove('visible')" class="modal-close">âœ•</button>
  </div>
  <div class="modal-body">
    <h3>Actions</h3>
    <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:12px">
      <button class="modal-btn" onclick="document.getElementById('forecastPanel').style.display='block';document.getElementById('quickActionsModal').classList.remove('visible')">Open Forecast</button>
      <button class="modal-btn" onclick="document.getElementById('moonCalendar').style.display='block';document.getElementById('quickActionsModal').classList.remove('visible')">Open Moon Calendar</button>
      <button class="modal-btn" onclick="document.getElementById('locationModal').classList.add('visible');document.getElementById('quickActionsModal').classList.remove('visible')">Location</button>
      <button class="modal-btn" onclick="document.getElementById('alarmModal').classList.add('visible');document.getElementById('quickActionsModal').classList.remove('visible')">Alarm</button>
      <button id="openBirdGuideBtn" class="modal-btn">Open Bird Guide</button>
      <button id="openFishGuideBtn" class="modal-btn">Open Fish Guide</button>
      <button id="openTreeGuideBtn" class="modal-btn">Open Tree Guide</button>
      <button class="modal-btn" onclick="captureScreenshot()">ğŸ“¸ Screenshot</button>
      <button class="modal-btn" onclick="showSaveSceneModal()">ğŸ’¾ Save Scene</button>
      <button class="modal-btn" onclick="showLoadSceneModal()">ğŸ“‚ Load Scene</button>
      <button class="modal-btn" onclick="showTutorial()">ğŸ“š Tutorial</button>
    </div>
  </div>
</div>
<div id="store" class="modal">
  <div class="modal-header">
    <h2>ğŸª Store</h2>
    <div class="modal-controls">
      <button onclick="minimizeStore()">âˆ’</button>
      <button onclick="closeStore()">âœ•</button>
    </div>
  </div>
  <div class="modal-body">
    <button id="removeModeBtn">ğŸ—‘ï¸ Remove Tool</button>
    
    <div class="store-category">
      <h3>ğŸŒ³ Trees</h3>
      <div class="item-grid">
        <div class="item" data-type="plant" data-subtype="oak"><div class="item-icon">ğŸŒ³</div><div class="item-name">Oak</div></div>
        <div class="item" data-type="plant" data-subtype="pine"><div class="item-icon">ğŸŒ²</div><div class="item-name">Pine</div></div>
        <div class="item" data-type="plant" data-subtype="willow"><div class="item-icon">ğŸŒ³</div><div class="item-name">Willow</div></div>
        <div class="item" data-type="plant" data-subtype="maple"><div class="item-icon">ğŸ</div><div class="item-name">Maple</div></div>
        <div class="item" data-type="plant" data-subtype="birch"><div class="item-icon">ğŸŒ³</div><div class="item-name">Birch</div></div>
        <div class="item" data-type="plant" data-subtype="beech"><div class="item-icon">ğŸŒ³</div><div class="item-name">Beech</div></div>
        <div class="item" data-type="plant" data-subtype="basswood"><div class="item-icon">ğŸŒ³</div><div class="item-name">Basswood</div></div>
        <div class="item" data-type="plant" data-subtype="laurel"><div class="item-icon">ğŸŒ¿</div><div class="item-name">Laurel</div></div>
        <div class="item" data-type="plant" data-subtype="walnut"><div class="item-icon">ğŸŒ³</div><div class="item-name">Walnut</div></div>
        <div class="item" data-type="plant" data-subtype="hickory"><div class="item-icon">ğŸŒ³</div><div class="item-name">Hickory</div></div>
        <div class="item" data-type="plant" data-subtype="chestnut"><div class="item-icon">ğŸŒ³</div><div class="item-name">Chestnut</div></div>
        <div class="item" data-type="plant" data-subtype="poplar"><div class="item-icon">ğŸŒ³</div><div class="item-name">Poplar</div></div>
        <div class="item" data-type="plant" data-subtype="sycamore"><div class="item-icon">ğŸŒ³</div><div class="item-name">Sycamore</div></div>
      </div>
    </div>
    
    <div class="store-category">
      <h3>ğŸŒ¿ Bushes</h3>
      <div class="item-grid">
        <div class="item" data-type="plant" data-subtype="rosebush"><div class="item-icon">ğŸŒ¹</div><div class="item-name">Rose</div></div>
        <div class="item" data-type="plant" data-subtype="blueberry"><div class="item-icon">ğŸ«</div><div class="item-name">Blueberry</div></div>
        <div class="item" data-type="plant" data-subtype="lavender"><div class="item-icon">ğŸ’œ</div><div class="item-name">Lavender</div></div>
      </div>
    </div>
    
    <div class="store-category">
      <h3>ğŸª¨ Accessories</h3>
      <div class="item-grid">
        <div class="item" data-type="accessory" data-subtype="rock"><div class="item-icon">ğŸª¨</div><div class="item-name">Rock</div></div>
        <div class="item" data-type="accessory" data-subtype="boulder"><div class="item-icon">ğŸ—¿</div><div class="item-name">Boulder</div></div>
        <div class="item" data-type="accessory" data-subtype="welcome"><div class="item-icon">ğŸª§</div><div class="item-name">Welcome</div></div>
        <div class="item" data-type="accessory" data-subtype="keepout"><div class="item-icon">â›”</div><div class="item-name">Keep Out</div></div>
        <div class="item" data-type="accessory" data-subtype="custom"><div class="item-icon">âœï¸</div><div class="item-name">Custom Sign</div></div>
        <div id="customSignsList" style="display:contents;"></div>
      </div>
    </div>
    
    <div class="store-category">
      <h3>ï¿½ Seasonal Vegetables</h3>
      <div style="font-size:11px;color:#aaa;margin-bottom:6px">Based on Farmer's Almanac</div>
      <div id="seasonalVegetables" class="item-grid"></div>
    </div>
    
    <div class="store-category">
      <h3>ï¿½ğŸ”ï¸ Terrain Shapes</h3>
      <div class="item-grid">
        <div class="item" data-type="terrain" data-subtype="hills"><div class="item-icon">ğŸ”ï¸</div><div class="item-name">Rolling Hills</div></div>
        <div class="item" data-type="terrain" data-subtype="flat"><div class="item-icon">ğŸï¸</div><div class="item-name">Flat Plains</div></div>
        <div class="item" data-type="terrain" data-subtype="valley"><div class="item-icon">â›°ï¸</div><div class="item-name">Valley</div></div>
        <div class="item" data-type="terrain" data-subtype="mountain"><div class="item-icon">ğŸ—»</div><div class="item-name">Mountain</div></div>
        <div class="item" data-type="terrain" data-subtype="peaks"><div class="item-icon">â›°ï¸</div><div class="item-name">Sharp Peaks</div></div>
        <div class="item" data-type="terrain" data-subtype="alpine"><div class="item-icon">â„ï¸</div><div class="item-name">Alpine Ridge</div></div>
        <div class="item" data-type="terrain" data-subtype="plateau"><div class="item-icon">ğŸ“¦</div><div class="item-name">High Plateau</div></div>
        <div class="item" data-type="terrain" data-subtype="gorge"><div class="item-icon">ğŸª¨</div><div class="item-name">Rocky Gorge</div></div>
      </div>
    </div>
  </div>
</div>

<div id="locationModal" class="modal">
  <div class="modal-header">
    <h2>ğŸ“ Set Location</h2>
    <div class="modal-controls">
      <button onclick="closeLocationModal()">âœ•</button>
    </div>
  </div>
  <div class="modal-body">
    <div class="form-group">
      <label for="locName">Location Name:</label>
      <input id="locName" type="text" placeholder="Town, State">
    </div>
    <div class="form-group">
      <label for="locLat">Latitude:</label>
      <input id="locLat" type="number" step="0.0001" placeholder="38.4147">
    </div>
    <div class="form-group">
      <label for="locLon">Longitude:</label>
      <input id="locLon" type="number" step="0.0001" placeholder="-80.2435">
    </div>
    <div class="modal-btn-wrapper">
      <button class="modal-btn" onclick="setLocation()">Save</button>
      <button class="modal-btn danger" onclick="closeLocationModal()">Cancel</button>
    </div>
  </div>
</div>

<div id="cloudModal" class="modal">
  <div class="modal-header">
    <h2>â˜ï¸ Cloud Settings</h2>
    <div class="modal-controls">
      <button onclick="closeCloudModal()">âœ•</button>
    </div>
  </div>
  <div class="modal-body">
    <div class="store-category">
      <h3>Start Color (Cloud Center)</h3>
      <div class="form-group">
        <label>Red (0-255):</label>
        <input type="range" id="startR" min="0" max="255" value="255">
        <span id="startRVal">255</span>
      </div>
      <div class="form-group">
        <label>Green (0-255):</label>
        <input type="range" id="startG" min="0" max="255" value="255">
        <span id="startGVal">255</span>
      </div>
      <div class="form-group">
        <label>Blue (0-255):</label>
        <input type="range" id="startB" min="0" max="255" value="255">
        <span id="startBVal">255</span>
      </div>
      <div class="form-group">
        <label>Opacity (0-1):</label>
        <input type="range" id="startA" min="0" max="100" value="90">
        <span id="startAVal">0.9</span>
      </div>
    </div>
    
    <div class="store-category">
      <h3>End Color (Cloud Edge)</h3>
      <div class="form-group">
        <label>Red (0-255):</label>
        <input type="range" id="endR" min="0" max="255" value="20">
        <span id="endRVal">20</span>
      </div>
      <div class="form-group">
        <label>Green (0-255):</label>
        <input type="range" id="endG" min="0" max="255" value="30">
        <span id="endGVal">30</span>
      </div>
      <div class="form-group">
        <label>Blue (0-255):</label>
        <input type="range" id="endB" min="0" max="255" value="80">
        <span id="endBVal">80</span>
      </div>
      <div class="form-group">
        <label>Opacity (0-1):</label>
        <input type="range" id="endA" min="0" max="100" value="30">
        <span id="endAVal">0.3</span>
      </div>
    </div>
    
    <div class="modal-btn-wrapper">
      <button class="modal-btn" onclick="applyCloudSettings()">Apply Preview</button>
      <button class="modal-btn" onclick="acceptCloudSettings()">Accept & Save</button>
      <button class="modal-btn danger" onclick="resetCloudSettings()">Reset to Default</button>
    </div>
  </div>
</div>

<div id="loader">
  <div class="loader-content">
    <img src="WestVirginia game data/WV.jpg?v=2" alt="West Virginia landscape" style="width:100%;max-width:600px;height:auto;max-height:360px;border-radius:10px;margin-bottom:20px;opacity:0.8;">
    <div class="spinner"></div>
    <h1>West Virginia Nature Simulation</h1>
      <h2 class="loading-subtitle" style="color:#aaf;font-size:14px;margin-top:6px;">Where Nature Meets Data</h2>
    <p class="loading-text">Loading environment...</p>
    <img class="loader-logo" src="cr45h-apps-logo.svg" alt="Cr45h Apps logo">
    <div class="progress-bar">
      <div class="progress-fill" id="progressFill"></div>
    </div>
  </div>
</div>
<script>
const canvas = document.getElementById('canvas');
let ctx = canvas.getContext('2d'); // Changed to let so we can reassign for layered drawing

// Create layered canvases for depth sorting
const canvasLayer1 = document.getElementById('canvasLayer1');
const ctxLayer1 = canvasLayer1.getContext('2d');
const canvasLayer2 = document.getElementById('canvasLayer2');
const ctxLayer2 = canvasLayer2.getContext('2d');
const canvasLayer3 = document.getElementById('canvasLayer3');
const ctxLayer3 = canvasLayer3.getContext('2d');
const canvasLayer4 = document.getElementById('canvasLayer4');
const ctxLayer4 = canvasLayer4.getContext('2d');

// Create GIF images as positioned HTML elements that can animate
function createAnimatedGIF(src, name){
  const img = document.createElement('img');
  img.src = src;
  img.style.position = 'fixed';
  img.style.display = 'none'; // Hidden until needed
  img.style.pointerEvents = 'none';
  img.style.zIndex = '50'; // Above canvas
  img.className = 'animated-sprite';
  img.onload = () => {
    console.log(name + ' GIF loaded successfully');
    document.body.appendChild(img);
  };
  img.onerror = () => console.error('Failed to load ' + name + ' image');
  return img;
}

// Load animated GIFs for creatures
const owlImg = createAnimatedGIF('./WestVirginia game data/owlHoot.gif', 'Owl');
const batImg = createAnimatedGIF('./WestVirginia game data/batFlying.gif', 'Bat');
const deerWalkImg = createAnimatedGIF('./WestVirginia game data/deer_walk.gif', 'Deer walk');
const deerIdleImg = createAnimatedGIF('./WestVirginia game data/deer_idle.gif', 'Deer idle');
const bunnyHopImg = createAnimatedGIF('./WestVirginia game data/bunny-hop.gif', 'Bunny hop');
const bunnyScratchImg = createAnimatedGIF('./WestVirginia game data/bunny-scratch.gif', 'Bunny scratch');
const babyBunnyHopImg1 = createAnimatedGIF('./WestVirginia game data/bunny-hop.gif', 'Baby bunny 1 hop');
const babyBunnyScratchImg1 = createAnimatedGIF('./WestVirginia game data/bunny-scratch.gif', 'Baby bunny 1 scratch');
const babyBunnyHopImg2 = createAnimatedGIF('./WestVirginia game data/bunny-hop.gif', 'Baby bunny 2 hop');
const babyBunnyScratchImg2 = createAnimatedGIF('./WestVirginia game data/bunny-scratch.gif', 'Baby bunny 2 scratch');

// Terrain boundary markers for layering
let firstPlantY = null;  // Bottom boundary (items in front of animals)
let secondPlantY = null; // Top boundary (items behind animals)

// ============================================
// MODULE: CONFIGURATION
// ============================================
const CONFIG = {
  TERRAIN: {
    BASE_Y: 0.65,
    MOUNTAIN_TOP_Y: 0.35,
    WATER_Y: 0.78
  },
  WEATHER: {
    UPDATE_INTERVAL: 120000,
    RAIN_SPAWN_CHANCE: 0.2,
    SNOW_SPAWN_CHANCE: 0.3
  },
  AUDIO: {
    WATER_VOLUME: 0.06,
    RAIN_VOLUME: 0.08,
    WIND_MAX_VOLUME: 0.15,
    BIRD_VOLUME: 0.025
  },
  SPAWN_RATES: {
    BIRD_INTERVAL: 8000,
    FIREFLY_CHANCE: 0.4,
    OWL_HOURS: [2, 7]
  }
};

let W, H, ready = false, animTime = 0;
let lightSourceX, lightSourceY, lightSourceAlt = 45;
let LAT = 38.4147, LON = -80.2435, LOCATION_NAME = 'HACKER VALLEY, WV';
let selectedType = null, selectedSubtype = null, removeMode = false, showClock = false;
let alarmTime = null, alarmTriggered = false;
let controlsHidden = false;
let customSignText = 'CUSTOM';
let infoPanelVisible = true;

let cloudSettings = {
  startColor: {r:255, g:255, b:255, a:0.9},
  endColor: {r:20, g:30, b:80, a:0.3}
};

let items = [], birds = [], clouds = [], stars = [], raindrops = [], snowflakes = [];
let grassPatches = [], terrain = [], bgTerrain = [[], [], []], bgDetails = [[],[],[]], river = [];
let creatures = [], splashes = [], cloudShadows = [];
let weatherData = {temp:70, condition:'Clear', windSpeed:5, precipitation:0, humidity:50, cloudCover:20};
let sunAlt = 45, sunAz = 180, moonAlt = -20, moonAz = 0, moonPhase = 0.5;
let snowCover = 0, terrainType = 'hills';
let lightning = {active:false, intensity:0, countdown:0, x:0};
let season = 'spring';
let moonCraters = [];
let owl = null; let owlSchedule = null; let owlHootsDone = 0;
let fish = [];
let alarmSoundType = 'birds';
let audioCtx = null, soundEnabled = false, waterSound = null, rainSound = null, windSound = null;
let muteCrows = false;
let muteFishSplashes = false;
let muteOwl = false;
let muteBats = false;
let muteFishEating = false;
let muteFishJumping = false;
let muteAmbience = false;
// Sound volume levels (0-1)
let owlVolume = 0.4;
let fishSplashVolume = 0.6;
let fishEatingVolume = 0.4;
let fishJumpingVolume = 0.4;
let batsVolume = 0.3;
let ambienceVolume = 0.2;
let crowsVolume = 0.5;
let owlHootAudio = null;
let fishEatingAudio = null;
let fishJumping1Audio = null;
let fishJumping2Audio = null;
let ambienceAudio = null;
let crowCawAudio = null;
let crowMurderAudio = null;
let deer = null;
let deerEvents = [];
let deerEventsToday = 0;
let bunny = null;
let bunnyEvents = [];
let bunnyEventsToday = 0;
let babyBunny1 = null;
let babyBunny2 = null;

// environmental particle arrays
let mistParticles = [];
let bats = [];
let fallingLeaves = [];
let fallenLeafAccum = [];
let dragonflies = [];
let fireflies = [];


// Bright star catalog (top ~20 by visual magnitude) with RA (hours) / Dec (deg)
const brightStars = [
  {name:'Sirius',        ra:6.752,  dec:-16.716, mag:-1.46, con:'Canis Major'},
  {name:'Canopus',       ra:6.399,  dec:-52.695, mag:-0.74, con:'Carina'},
  {name:'Alpha Centauri',ra:14.660, dec:-60.835, mag:-0.27, con:'Centaurus'},
  {name:'Arcturus',      ra:14.261, dec:19.183,  mag:-0.05, con:'BoÃ¶tes'},
  {name:'Vega',          ra:18.615, dec:38.783,  mag:0.03,  con:'Lyra'},
  {name:'Capella',       ra:5.279,  dec:45.999,  mag:0.08,  con:'Auriga'},
  {name:'Rigel',         ra:5.243,  dec:-8.202,  mag:0.13,  con:'Orion'},
  {name:'Procyon',       ra:7.655,  dec:5.225,   mag:0.38,  con:'Canis Minor'},
  {name:'Achernar',      ra:1.628,  dec:-57.236, mag:0.46,  con:'Eridanus'},
  {name:'Betelgeuse',    ra:5.919,  dec:7.407,   mag:0.50,  con:'Orion'},
  {name:'Hadar',         ra:14.063, dec:-60.373, mag:0.61,  con:'Centaurus'},
  {name:'Altair',        ra:19.846, dec:8.868,   mag:0.76,  con:'Aquila'},
  {name:'Acrux',         ra:12.443, dec:-63.099, mag:0.77,  con:'Crux'},
  {name:'Aldebaran',     ra:4.598,  dec:16.509,  mag:0.85,  con:'Taurus'},
  {name:'Antares',       ra:16.490, dec:-26.431, mag:0.96,  con:'Scorpius'},
  {name:'Spica',         ra:13.419, dec:-11.161, mag:0.98,  con:'Virgo'},
  {name:'Pollux',        ra:7.755,  dec:28.026,  mag:1.14,  con:'Gemini'},
  {name:'Fomalhaut',     ra:22.961, dec:-29.622, mag:1.16,  con:'Piscis Austrinus'},
  {name:'Deneb',         ra:20.691, dec:45.280,  mag:1.25,  con:'Cygnus'},
  {name:'Regulus',       ra:10.139, dec:11.967,  mag:1.35,  con:'Leo'},
  {name:'Polaris',       ra:2.530,  dec:89.260,  mag:1.97,  con:'Ursa Minor'}
];
// Load saved settings
function loadSettings(){
  try{
    const saved = localStorage.getItem('wvNatureSettings');
    if(saved){
      const settings = JSON.parse(saved);
      LAT = settings.lat || LAT;
      LON = settings.lon || LON;
      LOCATION_NAME = settings.locName || LOCATION_NAME;
      showClock = settings.showClock || false;
      // Don't auto-enable sound - browser requires user gesture
      // soundEnabled = settings.soundEnabled || false;
      infoPanelVisible = settings.infoPanelVisible !== undefined ? settings.infoPanelVisible : true;
      terrainType = settings.terrainType || 'hills';
      alarmSoundType = settings.alarmSoundType || 'birds';
      
      // Restore terrain conditions
      snowCover = settings.snowCover !== undefined ? settings.snowCover : 0;

      // Restore owl schedule state
      owlSchedule = settings.owlSchedule || null;
      owlHootsDone = settings.owlHootsDone || 0;
      
      if(settings.alarmSoundType){
        document.getElementById('alarmSound').value = settings.alarmSoundType;
      }
      
      if(settings.cloudSettings){
        cloudSettings = settings.cloudSettings;
      }
      
      // Load sound mute settings
      muteCrows = settings.muteCrows !== undefined ? settings.muteCrows : false;
      muteFishSplashes = settings.muteFishSplashes !== undefined ? settings.muteFishSplashes : false;
      muteOwl = settings.muteOwl !== undefined ? settings.muteOwl : false;
      muteBats = settings.muteBats !== undefined ? settings.muteBats : false;
      muteFishEating = settings.muteFishEating !== undefined ? settings.muteFishEating : false;
      muteFishJumping = settings.muteFishJumping !== undefined ? settings.muteFishJumping : false;
      muteAmbience = settings.muteAmbience !== undefined ? settings.muteAmbience : false;
      
      // Load volume settings
      if(settings.owlVolume !== undefined){
        owlVolume = settings.owlVolume;
        document.getElementById('owlVolume').value = Math.round(owlVolume * 100);
        document.getElementById('owlVolVal').textContent = Math.round(owlVolume * 100) + '%';
      }
      if(settings.fishSplashVolume !== undefined){
        fishSplashVolume = settings.fishSplashVolume;
        document.getElementById('fishSplashVolume').value = Math.round(fishSplashVolume * 100);
        document.getElementById('fishSplashVolVal').textContent = Math.round(fishSplashVolume * 100) + '%';
      }
      if(settings.fishEatingVolume !== undefined){
        fishEatingVolume = settings.fishEatingVolume;
        document.getElementById('fishEatingVolume').value = Math.round(fishEatingVolume * 100);
        document.getElementById('fishEatingVolVal').textContent = Math.round(fishEatingVolume * 100) + '%';
      }
      if(settings.fishJumpingVolume !== undefined){
        fishJumpingVolume = settings.fishJumpingVolume;
        document.getElementById('fishJumpingVolume').value = Math.round(fishJumpingVolume * 100);
        document.getElementById('fishJumpingVolVal').textContent = Math.round(fishJumpingVolume * 100) + '%';
      }
      if(settings.batsVolume !== undefined){
        batsVolume = settings.batsVolume;
        document.getElementById('batsVolume').value = Math.round(batsVolume * 100);
        document.getElementById('batsVolVal').textContent = Math.round(batsVolume * 100) + '%';
      }
      if(settings.ambienceVolume !== undefined){
        ambienceVolume = settings.ambienceVolume;
        document.getElementById('ambienceVolume').value = Math.round(ambienceVolume * 100);
        document.getElementById('ambienceVolVal').textContent = Math.round(ambienceVolume * 100) + '%';
      }
      if(settings.crowsVolume !== undefined){
        crowsVolume = settings.crowsVolume;
        document.getElementById('crowsVolume').value = Math.round(crowsVolume * 100);
        document.getElementById('crowsVolVal').textContent = Math.round(crowsVolume * 100) + '%';
      }
      
      if(settings.items){
        items = settings.items.map(data => Object.assign(new Item(data.baseX, data.baseY, data.type, data.subtype), data));
        console.log(`ğŸ“¦ Loaded ${items.length} items from localStorage`);
      }
      
      document.getElementById('locationName').textContent = LOCATION_NAME;
      if(showClock) document.getElementById('clock').classList.add('visible');
      if(!infoPanelVisible) document.getElementById('ui').classList.add('hidden');
      if(!infoPanelVisible) document.getElementById('infoPanelBtn').classList.remove('active');
    }
  }catch(e){
    console.log('Settings load error:', e);
  }
}



function saveSettings(){
  try{
    const settings = {
      lat: LAT,
      lon: LON,
      locName: LOCATION_NAME,
      showClock: showClock,
      soundEnabled: soundEnabled,
      infoPanelVisible: infoPanelVisible,
      terrainType: terrainType,
      cloudSettings: cloudSettings,
      alarmSoundType: alarmSoundType,
      muteCrows: muteCrows,
      muteFishSplashes: muteFishSplashes,
      muteOwl: muteOwl,
      muteBats: muteBats,
      muteFishEating: muteFishEating,
      muteFishJumping: muteFishJumping,
      muteAmbience: muteAmbience,
      owlVolume: owlVolume,
      fishSplashVolume: fishSplashVolume,
      fishEatingVolume: fishEatingVolume,
      fishJumpingVolume: fishJumpingVolume,
      batsVolume: batsVolume,
      ambienceVolume: ambienceVolume,
      crowsVolume: crowsVolume,
      // Persist owl schedule
      owlSchedule: owlSchedule,
      owlHootsDone: owlHootsDone,
      snowCover: snowCover,
      items: items.map(item => ({
        baseX: item.baseX,
        baseY: item.baseY,
        type: item.type,
        subtype: item.subtype,
        age: item.age,
        customText: item.customText
      }))
    };
    console.log(`ğŸ’¾ Saving ${settings.items.length} items to localStorage`);
    localStorage.setItem('wvNatureSettings', JSON.stringify(settings));
    console.log('âœ… Settings saved successfully');
  }catch(e){
    console.log('Settings save error:', e);
  }
}

function closeStore(){ document.getElementById('store').classList.remove('visible'); }
function minimizeStore(){ document.getElementById('store').classList.remove('visible'); }
function closeAlarmModal(){ document.getElementById('alarmModal').classList.remove('visible'); }
function closeLocationModal(){ document.getElementById('locationModal').classList.remove('visible'); }
function closeSignModal(){ document.getElementById('signModal').classList.remove('visible'); }
function openCloudModal(){
  document.getElementById('cloudModal').classList.add('visible');
  // Populate current values
  document.getElementById('startR').value = cloudSettings.startColor.r;
  document.getElementById('startG').value = cloudSettings.startColor.g;
  document.getElementById('startB').value = cloudSettings.startColor.b;
  document.getElementById('startA').value = Math.round(cloudSettings.startColor.a * 100);
  document.getElementById('endR').value = cloudSettings.endColor.r;
  document.getElementById('endG').value = cloudSettings.endColor.g;
  document.getElementById('endB').value = cloudSettings.endColor.b;
  document.getElementById('endA').value = Math.round(cloudSettings.endColor.a * 100);
  // Update display values
  document.getElementById('startRVal').textContent = cloudSettings.startColor.r;
  document.getElementById('startGVal').textContent = cloudSettings.startColor.g;
  document.getElementById('startBVal').textContent = cloudSettings.startColor.b;
  document.getElementById('startAVal').textContent = cloudSettings.startColor.a.toFixed(1);
  document.getElementById('endRVal').textContent = cloudSettings.endColor.r;
  document.getElementById('endGVal').textContent = cloudSettings.endColor.g;
  document.getElementById('endBVal').textContent = cloudSettings.endColor.b;
  document.getElementById('endAVal').textContent = cloudSettings.endColor.a.toFixed(1);
}
function closeCloudModal(){ document.getElementById('cloudModal').classList.remove('visible'); }
function closeBeaconAlert(){ document.getElementById('beaconAlert').classList.remove('visible'); }

// Return interpolated terrain Y for a given X; fallback to mid-ground height
function getTerrainY(x){
  for(let i = 0; i < terrain.length - 1; i++){
    if(terrain[i].x <= x && terrain[i+1].x >= x){
      const t = (x - terrain[i].x) / (terrain[i+1].x - terrain[i].x);
      return terrain[i].y + (terrain[i+1].y - terrain[i].y) * t;
    }
  }
  return H * 0.65;
}

function createCrowCaw(mode = 'single'){
  if(muteCrows) return;
  if(!soundEnabled) return;
  if(typeof sunAlt !== 'undefined' && sunAlt < -6) return; // no crow sounds after dusk
  if(mode === 'murder'){
    if(!crowMurderAudio){
      crowMurderAudio = new Audio('./WestVirginia game data/crow-murder-caw.wav');
      crowMurderAudio.volume = crowsVolume;
    }
    crowMurderAudio.currentTime = 0;
    crowMurderAudio.play().catch(() => {});
  }else{
    if(!crowCawAudio){
      crowCawAudio = new Audio('./WestVirginia game data/crow-caw.mp3');
      crowCawAudio.volume = crowsVolume;
    }
    crowCawAudio.currentTime = 0;
    crowCawAudio.play().catch(() => {});
  }
}
function updateCloudPreview(){
  document.getElementById('startRVal').textContent = document.getElementById('startR').value;
  document.getElementById('startGVal').textContent = document.getElementById('startG').value;
  document.getElementById('startBVal').textContent = document.getElementById('startB').value;
  document.getElementById('startAVal').textContent = (document.getElementById('startA').value / 100).toFixed(2);
  
  document.getElementById('endRVal').textContent = document.getElementById('endR').value;
  document.getElementById('endGVal').textContent = document.getElementById('endG').value;
  document.getElementById('endBVal').textContent = document.getElementById('endB').value;
  document.getElementById('endAVal').textContent = (document.getElementById('endA').value / 100).toFixed(2);
}

function applyCloudSettings(){
  cloudSettings.startColor.r = parseInt(document.getElementById('startR').value);
  cloudSettings.startColor.g = parseInt(document.getElementById('startG').value);
  cloudSettings.startColor.b = parseInt(document.getElementById('startB').value);
  cloudSettings.startColor.a = parseFloat(document.getElementById('startA').value) / 100;
  
  cloudSettings.endColor.r = parseInt(document.getElementById('endR').value);
  cloudSettings.endColor.g = parseInt(document.getElementById('endG').value);
  cloudSettings.endColor.b = parseInt(document.getElementById('endB').value);
  cloudSettings.endColor.a = parseFloat(document.getElementById('endA').value) / 100;
}

function acceptCloudSettings(){
  applyCloudSettings();
  saveSettings();
  closeCloudModal();
  alert('âœ… Cloud settings saved!');
}

function resetCloudSettings(){
  cloudSettings = {
    startColor: {r:255, g:255, b:255, a:0.9},
    endColor: {r:20, g:30, b:80, a:0.3}
  };
  openCloudModal();
}

function applySignText(){
  const text = document.getElementById('signText').value.toUpperCase() || 'CUSTOM';
  customSignText = text.substring(0, 12);
  
  const customSignsList = document.getElementById('customSignsList');
  const newSignDiv = document.createElement('div');
  newSignDiv.className = 'item';
  newSignDiv.dataset.type = 'accessory';
  newSignDiv.dataset.subtype = 'customsaved';
  newSignDiv.dataset.signtext = customSignText;
  newSignDiv.innerHTML = `<div class="item-icon">ğŸª§</div><div class="item-name">${customSignText}</div>`;
  
  newSignDiv.addEventListener('click', function(){
    if(removeMode) return;
    document.querySelectorAll('.item').forEach(i => i.classList.remove('selected'));
    this.classList.add('selected');
    selectedType = 'accessory';
    selectedSubtype = 'customsaved';
    customSignText = this.dataset.signtext;
    document.getElementById('selected').textContent = customSignText;
  });
  
  customSignsList.appendChild(newSignDiv);
  closeSignModal();
  
  selectedType = 'accessory';
  selectedSubtype = 'customsaved';
  document.getElementById('selected').textContent = customSignText;
}

function setAlarm(){
  alarmTime = document.getElementById('alarmTime').value;
  alarmSoundType = document.getElementById('alarmSound').value;
  if(alarmTime){
    alarmTriggered = false;
    showNotification('âœ… Alarm set for ' + alarmTime + ' with ' + alarmSoundType + ' sound');
    closeAlarmModal();
    saveSettings();
  }
}

function clearAlarm(){
  alarmTime = null;
  alarmTriggered = false;
  document.getElementById('alarmTime').value = '';
  showNotification('âŒ Alarm cleared');
  saveSettings();
}

function updateOwlVolume(val){
  owlVolume = val / 100;
  document.getElementById('owlVolVal').textContent = val + '%';
  saveSettings();
}

function updateFishSplashVolume(val){
  fishSplashVolume = val / 100;
  document.getElementById('fishSplashVolVal').textContent = val + '%';
  saveSettings();
}

function updateFishEatingVolume(val){
  fishEatingVolume = val / 100;
  document.getElementById('fishEatingVolVal').textContent = val + '%';
  if(fishEatingAudio) fishEatingAudio.volume = fishEatingVolume;
  saveSettings();
}

function updateFishJumpingVolume(val){
  fishJumpingVolume = val / 100;
  document.getElementById('fishJumpingVolVal').textContent = val + '%';
  if(fishJumping1Audio) fishJumping1Audio.volume = fishJumpingVolume;
  if(fishJumping2Audio) fishJumping2Audio.volume = fishJumpingVolume;
  saveSettings();
}

function updateBatsVolume(val){
  batsVolume = val / 100;
  document.getElementById('batsVolVal').textContent = val + '%';
  saveSettings();
}

function updateAmbienceVolume(val){
  ambienceVolume = val / 100;
  document.getElementById('ambienceVolVal').textContent = val + '%';
  if(ambienceAudio) ambienceAudio.volume = ambienceVolume;
  saveSettings();
}

function updateCrowsVolume(val){
  crowsVolume = val / 100;
  document.getElementById('crowsVolVal').textContent = val + '%';
  // Update existing audio instances
  if(crowMurderAudio) crowMurderAudio.volume = crowsVolume;
  if(crowCawAudio) crowCawAudio.volume = crowsVolume;
  saveSettings();
}

function toggleOwlSound(){
  muteOwl = !muteOwl;
  const btn = document.getElementById('toggleOwlBtn');
  btn.textContent = muteOwl ? 'ğŸ¦‰ Owl: OFF' : 'ğŸ¦‰ Owl: ON';
  btn.classList.toggle('active', !muteOwl);
  saveSettings();
}

function toggleFishSplashSound(){
  muteFishSplashes = !muteFishSplashes;
  const btn = document.getElementById('toggleFishSplashBtn');
  btn.textContent = muteFishSplashes ? 'ğŸ’¦ Fish Splash: OFF' : 'ğŸ’¦ Fish Splash: ON';
  btn.classList.toggle('active', !muteFishSplashes);
  saveSettings();
}

function toggleFishEatingSound(){
  muteFishEating = !muteFishEating;
  const btn = document.getElementById('toggleFishEatingBtn');
  btn.textContent = muteFishEating ? 'ğŸŸ Fish Eating: OFF' : 'ğŸŸ Fish Eating: ON';
  btn.classList.toggle('active', !muteFishEating);
  saveSettings();
}

function toggleFishJumpingSound(){
  muteFishJumping = !muteFishJumping;
  const btn = document.getElementById('toggleFishJumpingBtn');
  btn.textContent = muteFishJumping ? 'ğŸ£ Fish Jumping: OFF' : 'ğŸ£ Fish Jumping: ON';
  btn.classList.toggle('active', !muteFishJumping);
  saveSettings();
}

function toggleBatSound(){
  muteBats = !muteBats;
  const btn = document.getElementById('toggleBatsBtn');
  btn.textContent = muteBats ? 'ğŸ¦‡ Bats: OFF' : 'ğŸ¦‡ Bats: ON';
  btn.classList.toggle('active', !muteBats);
  saveSettings();
}

function toggleAmbienceSound(){
  muteAmbience = !muteAmbience;
  const btn = document.getElementById('toggleAmbienceBtn');
  btn.textContent = muteAmbience ? 'ğŸµ Ambience: OFF' : 'ğŸµ Ambience: ON';
  btn.classList.toggle('active', !muteAmbience);
  
  if(ambienceAudio){
    if(muteAmbience){
      ambienceAudio.pause();
    }else if(soundEnabled){
      audioCtx.resume().then(() => ambienceAudio.play().catch(() => {}));
    }
  }
  saveSettings();
}

function toggleCrowSound(){
  muteCrows = !muteCrows;
  const btn = document.getElementById('toggleCrowsBtn');
  btn.textContent = muteCrows ? 'ğŸ¦ Crows: OFF' : 'ğŸ¦ Crows: ON';
  btn.classList.toggle('active', !muteCrows);
  saveSettings();
}

function testSpawnCrow(){
  if(typeof spawnCrow === 'function') spawnCrow();
}

function testSpawnDeer(){
  if(window._spawnDeer) {
    window._spawnDeer();
    console.log('Test deer spawned');
  } else {
    console.error('Deer spawn function not available');
  }
}

function testSpawnBunny(){
  if(window._spawnBunny) {
    window._spawnBunny();
    console.log('Test bunny spawned');
  } else {
    console.error('Bunny spawn function not available');
  }
}

function testCatfishFeeding(){
  // Temporarily override the hour to 9pm (21:00) for testing
  const originalGetHours = Date.prototype.getHours;
  Date.prototype.getHours = function() { return 21; };
  
  console.log('ğŸŸ CATFISH FEEDING TEST: Time set to 9PM for 30 seconds');
  console.log('Watch the bottom of the water - catfish should rise to surface');
  
  // Log current catfish positions
  const catfishList = fish.filter(f => f.type === 'catfish');
  console.log(`Found ${catfishList.length} catfish`);
  catfishList.forEach((f, i) => {
    console.log(`Catfish ${i+1}: depth=${f.depth.toFixed(2)} (0=surface, 1=bottom)`);
  });
  
  alert('â° Time set to 9PM!\nCatfish should rise to surface.\nCheck console for details.\nTime will reset in 30 seconds.');
  
  // Restore normal time after 30 seconds
  setTimeout(() => {
    Date.prototype.getHours = originalGetHours;
    console.log('Time restored to normal');
    alert('âœ… Test complete - time restored to normal');
  }, 30000);
}

function showFishDebug(){
  console.log('=== FISH DEBUG INFO ===');
  const currentHour = new Date().getHours();
  console.log(`Current time: ${currentHour}:00 (${currentHour >= 21 && currentHour < 23 ? 'CATFISH FEEDING TIME' : 'normal'})`);
  console.log(`Total fish: ${fish.length}`);
  
  const byType = {};
  fish.forEach(f => {
    if(!byType[f.type]) byType[f.type] = [];
    byType[f.type].push(f);
  });
  
  Object.keys(byType).forEach(type => {
    console.log(`\n${type.toUpperCase()} (${byType[type].length}):`);
    byType[type].forEach((f, i) => {
      console.log(`  #${i+1}: depth=${f.depth.toFixed(2)}, y=${f.y.toFixed(0)}, size=${f.size.toFixed(1)}, jumpState=${f.jumpState}`);
    });
  });
  
  alert('Fish debug info logged to console (F12)');
}

function testSpawnOwl(){
  if(!owl){
    const treesWithOwl = items.filter(item => item.type === 'plant' && !item.isBush && item.maxH > 80);
    if(treesWithOwl.length > 0){
      const tree = treesWithOwl[Math.floor(Math.random() * treesWithOwl.length)];
      owl = {
        tree: tree,
        x: tree.screenX,
        y: tree.screenY - tree.maxH * 0.7,
        blink: Math.random() * Math.PI * 2,
        blinkRate: 0.005,
        hootTimer: Math.random() * 200,
        nextHoot: 300 + Math.random() * 600
      };
      // Play hoot immediately on appearance for testing
      createOwlHoot();
    }
  }
}

function testSpawnBats(){
  if(window._spawnBat){
    for(let i = 0; i < 5; i++){
      setTimeout(() => window._spawnBat(), i * 200);
    }
  }
}

function testTriggerFishJump(){
  if(fish && fish.length > 0){
    const f = fish[Math.floor(Math.random() * fish.length)];
    if(f.jumpState === 'idle'){
      if(f.isSmall){
        f.jumpState = 'surface';
        f.jumpTimer = 0;
        f.jumpDuration = 20 + Math.floor(Math.random() * 20);
      }else{
        f.jumpState = 'arch';
        f.jumpTimer = 0;
        f.jumpDuration = 60 + Math.floor(Math.random() * 60);
        f.jumpStartX = f.x;
        f.jumpStartY = f.y;
        f.jumpPeakX = f.x + f.direction * (80 + Math.random() * 140);
        const waterY = H * 0.78;
        f.jumpPeakY = waterY - (30 + Math.random() * 40);
        createFishJumpExitSound();
      }
    }
  }
}

function testAlarmSound(){
  const soundType = document.getElementById('alarmSound').value;
  playAlarmSound(soundType);
}

function playAlarmSound(type){
  if(!soundEnabled && !audioCtx){
    initAudio();
  }
  
  if(type === 'birds'){
    for(let i = 0; i < 3; i++){
      setTimeout(() => createBirdChirp('cardinal'), i * 500);
    }
  }else if(type === 'beep'){
    createAlarmBeep();
  }else if(type === 'chime'){
    createAlarmChime();
  }else if(type === 'siren'){
    createAlarmSiren();
  }
}

async function setLocation(){
  const nameInput = document.getElementById('locName').value.trim();
  const lat = parseFloat(document.getElementById('locLat').value);
  const lon = parseFloat(document.getElementById('locLon').value);
  
  // West Virginia bounds: roughly Lat 37.2 to 40.6, Lon -82.6 to -77.7
  const wvLatMin = 37.2, wvLatMax = 40.6, wvLonMin = -82.6, wvLonMax = -77.7;
  
  if(isNaN(lat) || isNaN(lon)){
    alert('Please enter valid latitude and longitude values.');
    return;
  }
  if(lat < wvLatMin || lat > wvLatMax || lon < wvLonMin || lon > wvLonMax){
    alert('Please enter a West Virginia location (Lat: 37.2-40.6, Lon: -82.6 to -77.7).');
    return;
  }

  let name = nameInput;
  if(!name){
    const geoData = await reverseGeocode(lat, lon);
    if(geoData && geoData.town){
      name = `${geoData.town}, ${geoData.state || 'WV'}`;
    }
  }
  if(!name) name = 'West Virginia';

  LOCATION_NAME = name;
  LAT = lat;
  LON = lon;
  document.getElementById('locationName').textContent = name;
  
  buildTerrain();
  generateGrassPatches();
  generateStars();
  generateClouds();
  fetchWeather();
  updateAstronomy();
  saveSettings();
  closeLocationModal();
}

async function setByZip(){
  const zip = document.getElementById('zipCode').value.trim();
  if(!zip || zip.length !== 5){
    alert('Please enter a valid 5-digit ZIP code');
    return;
  }
  
  try{
    const r = await fetch(`https://api.zippopotam.us/us/${zip}`);
    if(!r.ok) throw new Error('ZIP not found');
    const d = await r.json();
    
    const lat = parseFloat(d.places[0].latitude);
    const lon = parseFloat(d.places[0].longitude);
    const name = `${d.places[0]['place name']}, ${d.places[0]['state abbreviation']}`;
    
    document.getElementById('locName').value = name;
    document.getElementById('locLat').value = lat;
    document.getElementById('locLon').value = lon;
    
    alert(`âœ… Found: ${name}`);
  }catch(e){
    alert('âŒ Could not find ZIP code. Please enter location manually.');
  }
}
function initAudio(){
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  soundEnabled = true;
  startSounds();
  
  // Initialize ambient music
  if(!ambienceAudio){
    ambienceAudio = new Audio('./WestVirginia game data/ambience.mp3');
    ambienceAudio.loop = true;
    ambienceAudio.volume = ambienceVolume;
  }
  if(!muteAmbience){
    // Play only after context is resumed (user gesture)
    audioCtx.resume().then(() => {
      ambienceAudio.play().catch(() => {});
    });
  }
  
  saveSettings();
}

function createAlarmBeep(){
  if(!audioCtx) return;
  for(let i = 0; i < 5; i++){
    setTimeout(() => {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'square';
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      osc.frequency.setValueAtTime(800, now);
      gain.gain.setValueAtTime(0.2, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
      osc.start(now);
      osc.stop(now + 0.3);
    }, i * 400);
  }
}

function createAlarmChime(){
  if(!audioCtx) return;
  const notes = [523.25, 659.25, 783.99, 1046.50];
  for(let i = 0; i < notes.length; i++){
    setTimeout(() => {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      osc.frequency.setValueAtTime(notes[i], now);
      gain.gain.setValueAtTime(0.15, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
      osc.start(now);
      osc.stop(now + 0.8);
    }, i * 300);
  }
}

function createAlarmSiren(){
  if(!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const lfo = audioCtx.createOscillator();
  const lfoGain = audioCtx.createGain();
  
  osc.type = 'sawtooth';
  lfo.type = 'triangle';
  lfo.frequency.value = 2;
  lfoGain.gain.value = 400;
  
  lfo.connect(lfoGain);
  lfoGain.connect(osc.frequency);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  
  const now = audioCtx.currentTime;
  osc.frequency.setValueAtTime(600, now);
  gain.gain.setValueAtTime(0.15, now);
  gain.gain.setValueAtTime(0.15, now + 3);
  gain.gain.exponentialRampToValueAtTime(0.01, now + 3.5);
  
  lfo.start(now);
  osc.start(now);
  lfo.stop(now + 3.5);
  osc.stop(now + 3.5);
}

function createWaterFlow(){
  if(!audioCtx) return null;
  const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for(let i = 0; i < buffer.length; i++) data[i] = Math.random() * 2 - 1;
  const source = audioCtx.createBufferSource();
  source.buffer = buffer;
  source.loop = true;
  const filter = audioCtx.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.value = 600;
  const gain = audioCtx.createGain();
  gain.gain.value = 0.06;
  source.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);
  source.start();
  return {source, gain};
}

function createRainSound(intensity = 1){
  if(!audioCtx) return null;
  const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 1.5, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for(let i = 0; i < buffer.length; i++) data[i] = Math.random() * 2 - 1;
  const source = audioCtx.createBufferSource();
  source.buffer = buffer;
  source.loop = true;
  const filter = audioCtx.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.value = 1200;
  const gain = audioCtx.createGain();
  gain.gain.value = 0.08 * intensity;
  source.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);
  source.start();
  return {source, gain};
}

function createSplashSound(){
  if(!soundEnabled || muteFishSplashes) return;
  if(!audioCtx) return;
  // stronger, fuller splash so it's audible at normal volumes
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();
  osc.type = 'triangle';
  filter.type = 'lowpass';
  filter.frequency.value = 1200;
  filter.Q.value = 0.7;
  osc.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);
  const now = audioCtx.currentTime;
  osc.frequency.setValueAtTime(900 + Math.random()*200, now);
  osc.frequency.exponentialRampToValueAtTime(250 + Math.random()*100, now + 0.25);
  // Use volume variable
  gain.gain.setValueAtTime(0.06 * fishSplashVolume, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.45);
  osc.start(now);
  osc.stop(now + 0.45);
}

function createFishEatingSound(){
  if(!soundEnabled || muteFishEating) return;
  if(!fishEatingAudio){
    fishEatingAudio = new Audio('./WestVirginia game data/fish_eating.mp3');
    fishEatingAudio.volume = fishEatingVolume;
  }
  fishEatingAudio.currentTime = 0;
  fishEatingAudio.play().catch(e => console.log('Fish eating audio error:', e));
}

function createFishJumpExitSound(){
  if(!soundEnabled || muteFishJumping) return;
  if(!fishJumping1Audio){
    fishJumping1Audio = new Audio('./WestVirginia game data/fish-jumping1.wav');
    fishJumping1Audio.volume = fishJumpingVolume;
    fishJumping1Audio.onerror = () => console.error('Failed to load fish-jumping1.wav');
  }
  fishJumping1Audio.currentTime = 0;
  fishJumping1Audio.play().catch(e => console.error('Fish jump EXIT sound error:', e.message));
}

function createFishJumpEntrySound(){
  if(!soundEnabled || muteFishJumping) return;
  if(!fishJumping2Audio){
    fishJumping2Audio = new Audio('./WestVirginia game data/fish-jumping2.wav');
    fishJumping2Audio.volume = fishJumpingVolume;
    fishJumping2Audio.onerror = () => console.error('Failed to load fish-jumping2.wav');
  }
  fishJumping2Audio.currentTime = 0;
  fishJumping2Audio.play().catch(e => console.error('Fish jump ENTRY sound error (fish-jumping2.wav):', e.message));
}

function createWindSound(){
  if(!audioCtx) return null;
  const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 3, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for(let i = 0; i < buffer.length; i++) data[i] = (Math.random() * 2 - 1) * 0.5;
  const source = audioCtx.createBufferSource();
  source.buffer = buffer;
  source.loop = true;
  const filter = audioCtx.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.value = 400;
  const gain = audioCtx.createGain();
  gain.gain.value = Math.min(0.15, weatherData.windSpeed / 100);
  source.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);
  source.start();
  return {source, gain};
}
function createBirdChirp(type = 'chirp'){
  if(!audioCtx || sunAlt < 0) return;
  
  if(type === 'cardinal'){
    for(let note = 0; note < 3; note++){
      setTimeout(() => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine';
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        
        const startF = 3500 - (note * 200);
        osc.frequency.setValueAtTime(startF, now);
        osc.frequency.exponentialRampToValueAtTime(startF * 0.85, now + 0.08);
        
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.025, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        osc.start(now);
        osc.stop(now + 0.15);
      }, note * 120);
    }
  }else if(type === 'robin'){
    const pattern = [2000, 2400, 1900, 2300, 2100];
    for(let i = 0; i < pattern.length; i++){
      setTimeout(() => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        
        osc.type = 'sine';
        filter.type = 'bandpass';
        filter.frequency.value = pattern[i];
        filter.Q.value = 3;
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        
        osc.frequency.setValueAtTime(pattern[i], now);
        osc.frequency.linearRampToValueAtTime(pattern[i] * 1.15, now + 0.05);
        osc.frequency.linearRampToValueAtTime(pattern[i] * 0.95, now + 0.1);
        
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.02, now + 0.01);
        gain.gain.linearRampToValueAtTime(0.015, now + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
        osc.start(now);
        osc.stop(now + 0.12);
      }, i * 100);
    }
  }else{
    const osc1 = audioCtx.createOscillator();
    const osc2 = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const lfo = audioCtx.createOscillator();
    const lfoGain = audioCtx.createGain();
    
    osc1.type = 'sine';
    osc2.type = 'sine';
    lfo.type = 'sine';
    lfo.frequency.value = 12;
    lfoGain.gain.value = 40;
    
    lfo.connect(lfoGain);
    lfoGain.connect(osc1.frequency);
    
    osc1.connect(gain);
    osc2.connect(gain);
    gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    
    const baseF = 1500 + Math.random() * 800;
    osc1.frequency.setValueAtTime(baseF, now);
    osc1.frequency.exponentialRampToValueAtTime(baseF * 1.4, now + 0.06);
    osc1.frequency.exponentialRampToValueAtTime(baseF * 1.2, now + 0.12);
    
    osc2.frequency.setValueAtTime(baseF * 2, now);
    osc2.frequency.exponentialRampToValueAtTime(baseF * 2.8, now + 0.06);
    osc2.frequency.exponentialRampToValueAtTime(baseF * 2.4, now + 0.12);
    
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(0.018, now + 0.01);
    gain.gain.linearRampToValueAtTime(0.012, now + 0.06);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.13);
    
    lfo.start(now);
    osc1.start(now);
    osc2.start(now);
    lfo.stop(now + 0.13);
    osc1.stop(now + 0.13);
    osc2.stop(now + 0.13);
  }
}

function createOwlHoot(){
  if(!soundEnabled || muteOwl) return;
  if(!owlHootAudio){
    owlHootAudio = new Audio('./WestVirginia game data/owl-hooting.mp3');
    owlHootAudio.volume = owlVolume;
  }
  owlHootAudio.currentTime = 0;
  owlHootAudio.play().catch(e => console.log('Owl audio error:', e));
  
  // Set owl to become invisible 5 seconds after sound ends
  if(owl){
    owl.visible = true;
    owlHootAudio.onended = () => {
      if(owl){
        setTimeout(() => {
          if(owl) owl.visible = false;
        }, 5000); // 5 seconds after hoot ends
      }
    };
  }
}

function createThunder(intensity = 0.5){
  if(!audioCtx) return;
  const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 2.5, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for(let i = 0; i < buffer.length; i++){
    const t = i / buffer.length;
    const env = Math.exp(-t * 3) * Math.sin(t * Math.PI);
    data[i] = (Math.random() * 2 - 1) * env * intensity;
  }
  const source = audioCtx.createBufferSource();
  source.buffer = buffer;
  const filter = audioCtx.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.value = 200 + Math.random() * 300;
  const gain = audioCtx.createGain();
  gain.gain.value = 0.25 * intensity;
  source.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);
  source.start();
}

function createTornadoSiren(){
  if(!audioCtx) return;
  
  const duration = 8;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const lfo = audioCtx.createOscillator();
  const lfoGain = audioCtx.createGain();
  
  osc.type = 'sawtooth';
  lfo.type = 'triangle';
  lfo.frequency.value = 0.5;
  lfoGain.gain.value = 300;
  
  lfo.connect(lfoGain);
  lfoGain.connect(osc.frequency);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  
  const now = audioCtx.currentTime;
  osc.frequency.setValueAtTime(600, now);
  gain.gain.setValueAtTime(0, now);
  gain.gain.linearRampToValueAtTime(0.12, now + 0.5);
  gain.gain.setValueAtTime(0.12, now + duration - 1);
  gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
  
  lfo.start(now);
  osc.start(now);
  lfo.stop(now + duration);
  osc.stop(now + duration);
}

function startSounds(){
  if(!soundEnabled || !audioCtx) return;
  if(!waterSound) waterSound = createWaterFlow();
  updateWeatherSounds();
  scheduleSounds();
}

function updateWeatherSounds(){
  if(!soundEnabled) return;
  
  if((weatherData.condition === 'Rain' || weatherData.condition === 'Storm') && !rainSound){
    const intensity = weatherData.precipitation > 0.1 ? 2.5 : 1;
    rainSound = createRainSound(intensity);
  }else if(rainSound && weatherData.condition !== 'Rain' && weatherData.condition !== 'Storm'){
    if(rainSound.source) rainSound.source.stop();
    rainSound = null;
  }else if(rainSound && rainSound.gain){
    const intensity = weatherData.precipitation > 0.1 ? 2.5 : 1;
    rainSound.gain.gain.value = 0.08 * intensity;
  }
  
  if(weatherData.windSpeed > 15 && !windSound){
    windSound = createWindSound();
  }else if(windSound && weatherData.windSpeed <= 15){
    if(windSound.source) windSound.source.stop();
    windSound = null;
  }else if(windSound && windSound.gain){
    windSound.gain.gain.value = Math.min(0.15, weatherData.windSpeed / 100);
  }
}

function scheduleSounds(){
  if(!soundEnabled) return;
  if(sunAlt > 0 && Math.random() < 0.08){
    const types = ['chirp', 'cardinal', 'robin'];
    setTimeout(() => {
      if(soundEnabled) createBirdChirp(types[Math.floor(Math.random() * types.length)]);
    }, Math.random() * 8000);
  }
  
  if(sunAlt > -10 && Math.random() < 0.03){
    setTimeout(() => {
      if(soundEnabled) createCrowCaw();
    }, Math.random() * 5000);
  }
  
  setTimeout(scheduleSounds, 3000);
}

function stopSounds(){
  if(waterSound && waterSound.source) try{ waterSound.source.stop(); }catch(e){}
  if(rainSound && rainSound.source) try{ rainSound.source.stop(); }catch(e){}
  if(windSound && windSound.source) try{ windSound.source.stop(); }catch(e){}
  waterSound = null;
  rainSound = null;
  windSound = null;
}
function generateMoonCraters(){
  moonCraters = [];
  // Based on real lunar features visible from Earth
  const craterData = [
    // Tycho - prominent crater in southern region
    {x:3, y:24, r:6, depth:0.8},
    // Copernicus - bright ray crater in center
    {x:-5, y:5, r:5, depth:0.7},
    // Kepler - northwestern region
    {x:-18, y:-8, r:4, depth:0.6},
    // Aristarchus - one of brightest spots
    {x:-20, y:-12, r:5, depth:0.75},
    // Plato - dark floored crater in north
    {x:-8, y:-18, r:6, depth:0.5},
    // Archimedes - Mare Imbrium region
    {x:-10, y:-10, r:4, depth:0.5},
    // Theophilus - eastern edge
    {x:18, y:8, r:5, depth:0.65},
    // Ptolemaeus - central
    {x:2, y:12, r:5, depth:0.4},
    // Mare Crisium - dark sea on eastern edge
    {x:25, y:-5, r:8, depth:0.3, mare:true},
    // Mare Serenitatis - Sea of Serenity
    {x:8, y:-12, r:9, depth:0.3, mare:true},
    // Mare Tranquillitatis - Apollo 11 landing
    {x:12, y:2, r:7, depth:0.3, mare:true},
    // Smaller craters for detail
    {x:-15, y:18, r:3, depth:0.5},
    {x:15, y:-18, r:3, depth:0.5},
    {x:-25, y:2, r:3, depth:0.6},
    {x:22, y:15, r:3, depth:0.55}
  ];
  moonCraters = craterData;
}

function updateAstronomy(){
  const now = new Date();
  const year = now.getUTCFullYear();
  const month = now.getUTCMonth() + 1;
  const day = now.getUTCDate();
  const hours = now.getUTCHours() + now.getUTCMinutes() / 60 + now.getUTCSeconds() / 3600;
  
  const a = Math.floor((14 - month) / 12);
  const y = year + 4800 - a;
  const m = month + 12 * a - 3;
  const JDN = day + Math.floor((153 * m + 2) / 5) + 365 * y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) - 32045;
  const JD = JDN + (hours - 12) / 24;
  
  const n = JD - 2451545.0;
  
  const L = (280.460 + 0.9856474 * n) % 360;
  const g = (357.528 + 0.9856003 * n) % 360;
  const gRad = g * Math.PI / 180;
  const lambda = (L + 1.915 * Math.sin(gRad) + 0.020 * Math.sin(2 * gRad)) % 360;
  const epsilon = 23.439 - 0.0000004 * n;

  const lambdaRad = lambda * Math.PI / 180;
  const epsilonRad = epsilon * Math.PI / 180;
  const sunDec = Math.asin(Math.sin(epsilonRad) * Math.sin(lambdaRad)) * 180 / Math.PI;

  const GMST = (280.46061837 + 360.98564736629 * n) % 360;
  const sunRA = (Math.atan2(Math.cos(epsilonRad) * Math.sin(lambdaRad), Math.cos(lambdaRad)) * 180 / Math.PI + 360) % 360;
  // Hour angle in degrees: HA = LST - RA, where LST = GMST + LON
  const sunHA = (GMST + LON - sunRA + 360) % 360;
  // Normalize to -180 to 180 for proper calculation
  const normalizedHA = sunHA > 180 ? sunHA - 360 : sunHA;

  const latRad = LAT * Math.PI / 180;
  const decRad = sunDec * Math.PI / 180;
  const haRad = normalizedHA * Math.PI / 180;

  sunAlt = Math.asin(Math.sin(latRad) * Math.sin(decRad) + Math.cos(latRad) * Math.cos(decRad) * Math.cos(haRad)) * 180 / Math.PI;

  const azRad = Math.atan2(Math.sin(haRad), Math.cos(haRad) * Math.sin(latRad) - Math.tan(decRad) * Math.cos(latRad));
  sunAz = (azRad * 180 / Math.PI + 180) % 360;

  const localHours = now.getHours() + now.getMinutes() / 60 + now.getSeconds() / 3600;
  console.log('=== Astronomy Debug ===');
  console.log('UTC Hour:', hours.toFixed(2), 'Local Hour:', localHours.toFixed(2), 'LAT:', LAT, 'LON:', LON);
  console.log('Sun Alt:', sunAlt.toFixed(2), 'Sun Az:', sunAz.toFixed(2), 'HA:', normalizedHA.toFixed(2));
  console.log('GMST:', GMST.toFixed(2), 'RA:', sunRA.toFixed(2), 'Dec:', sunDec.toFixed(2));
  
  const daysSinceNew = (now - new Date(2000, 0, 6, 18, 14)) / (1000 * 60 * 60 * 24);
  moonPhase = (daysSinceNew % 29.530588) / 29.530588;
  
  const moonL = (218.316 + 13.176396 * n) % 360;
  const moonM = (134.963 + 13.064993 * n) % 360;
  const moonF = (93.272 + 13.229350 * n) % 360;
  
  const moonLambda = (moonL + 6.289 * Math.sin(moonM * Math.PI / 180)) % 360;
  const moonBeta = 5.128 * Math.sin(moonF * Math.PI / 180);
  
  const moonDec = Math.asin(Math.sin(epsilon * Math.PI / 180) * Math.sin(moonLambda * Math.PI / 180) * Math.cos(moonBeta * Math.PI / 180) +
    Math.cos(epsilon * Math.PI / 180) * Math.sin(moonBeta * Math.PI / 180)) * 180 / Math.PI;
  
  const moonRA = Math.atan2(
    Math.sin(moonLambda * Math.PI / 180) * Math.cos(epsilon * Math.PI / 180) - Math.tan(moonBeta * Math.PI / 180) * Math.sin(epsilon * Math.PI / 180),
    Math.cos(moonLambda * Math.PI / 180)
  ) * 180 / Math.PI;
  
  const moonHA = (GMST - moonRA + 360) % 360;
  const moonDecRad = moonDec * Math.PI / 180;
  const moonHaRad = moonHA * Math.PI / 180;
  
  moonAlt = Math.asin(Math.sin(latRad) * Math.sin(moonDecRad) + Math.cos(latRad) * Math.cos(moonDecRad) * Math.cos(moonHaRad)) * 180 / Math.PI;
  
  const moonAzRad = Math.atan2(Math.sin(moonHaRad), Math.cos(moonHaRad) * Math.sin(latRad) - Math.tan(moonDecRad) * Math.cos(latRad));
  moonAz = (moonAzRad * 180 / Math.PI + 180) % 360;
  
  const sunPos = altAzToScreen(sunAlt, sunAz);
  const moonPos = altAzToScreen(moonAlt, moonAz);
  // Prefer the sun as the primary light source when it's above the horizon,
  // even if its projected screen position falls slightly off-screen (so light
  // comes from overhead/downward). Otherwise fall back to the moon or a
  // low behind-mountain light.
  if(sunAlt > -6){
    lightSourceAlt = sunAlt;
    lightSourceX = sunPos.x;
    lightSourceY = sunPos.y;
  }else if(moonPos.visible){
    lightSourceAlt = moonAlt;
    lightSourceX = moonPos.x;
    lightSourceY = moonPos.y;
  }else{
    // when neither sun nor moon are usefully above/beside horizon, keep
    // a soft low light coming from behind the mountains
    lightSourceAlt = -20;
    lightSourceX = W * 0.5;
    lightSourceY = H * 1.2;
  }
  
  // Calculate rise/set times
  calculateRiseSetTimes(now);
  updateTimeDisplay(now);
}

// Owl scheduler: exactly three hoots between 2:00â€“7:00 local time
function getDateKey(d){
  const y = d.getFullYear();
  const m = (d.getMonth()+1).toString().padStart(2,'0');
  const day = d.getDate().toString().padStart(2,'0');
  return `${y}-${m}-${day}`;
}

function ensureOwlSchedule(now){
  // Determine the window this schedule belongs to (the day of the 2 AM window start)
  const windowStart = new Date(now);
  // If currently before 2:00, today's window is today 2:00; else schedule for next day
  if(now.getHours() >= 2){
    windowStart.setHours(2,0,0,0);
  }else{
    windowStart.setDate(windowStart.getDate());
    windowStart.setHours(2,0,0,0);
  }
  const dateKey = getDateKey(windowStart);

  // If missing or for different day or invalid, regenerate
  if(!owlSchedule || owlSchedule.dateKey !== dateKey || !Array.isArray(owlSchedule.times) || owlSchedule.times.length !== 3){
    const start = new Date(windowStart);
    const end = new Date(windowStart);
    end.setHours(7,0,0,0);
    // Generate three random timestamps in [start,end)
    const spanMs = end.getTime() - start.getTime();
    const picks = [];
    for(let i=0;i<3;i++){
      const t = start.getTime() + Math.random() * spanMs;
      picks.push(Math.floor(t));
    }
    picks.sort((a,b)=>a-b);
    owlSchedule = {dateKey, times:picks, consumed:[false,false,false]};
    owlHootsDone = 0;
    saveSettings();
  }
}

function checkOwlSchedule(now){
  try{
    ensureOwlSchedule(now);
    if(!owlSchedule) return;
    const hour = now.getHours();
    // Only trigger in 2â€“7 window
    if(hour < 2 || hour >= 7) return;

    for(let i=0;i<owlSchedule.times.length;i++){
      if(owlSchedule.consumed[i]) continue;
      const t = owlSchedule.times[i];
      if(now.getTime() >= t){
        // Trigger hoot event
        triggerOwlHootEvent();
        owlSchedule.consumed[i] = true;
        owlHootsDone = (owlHootsDone||0) + 1;
        saveSettings();
        break;
      }
    }
  }catch(e){
    console.log('Owl schedule error:', e);
  }
}

function triggerOwlHootEvent(){
  try{
    // Choose a tree to perch; if none, skip spawn but still attempt sound
    let tree = null;
    const candidates = items.filter(item => item.type==='plant' && !item.isBush && item.maxH>80 && (item.subtype==='oak' || item.subtype==='maple'));
    if(candidates.length){
      tree = candidates[Math.floor(Math.random()*candidates.length)];
    }
    // Spawn or update owl entity
    if(!owl){
      owl = {tree: tree||null, x: 0, y: 0, visible: true, blink: Math.random()*Math.PI*2, blinkRate:0.005, hootTimer:0, nextHoot:0};
    }else{
      owl.visible = true;
      owl.tree = tree||null;
    }
    if(owl.tree){
      owl.x = owl.tree.screenX;
      owl.y = owl.tree.screenY - owl.tree.maxH * 0.7;
    }else{
      // Fallback position near center top
      owl.x = W*0.5;
      owl.y = H*0.3;
    }
    // Play hoot and schedule auto-hide
    createOwlHoot();
    // If audio cannot play due to user gesture policy, still hide after +5s
    if(owlHootAudio){
      owlHootAudio.onended = () => {
        if(owl){ setTimeout(()=>{ if(owl) { owl.visible=false; owl=null; saveSettings(); } }, 5000); }
      };
    }else{
      setTimeout(()=>{ if(owl) { owl.visible=false; owl=null; saveSettings(); } }, 5000);
    }
  }catch(e){
    console.log('Owl trigger error:', e);
  }
}

function calculateRiseSetTimes(now){
  // Calculate sunrise/sunset times by finding when sun altitude crosses 0Â°
  // We do a binary search over the day to find these times
  
  // Helper to get sun altitude at a specific time
  function getSunAltAtTime(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth() + 1;
    const day = date.getUTCDate();
    const hours = date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;
    
    const a = Math.floor((14 - month) / 12);
    const y = year + 4800 - a;
    const m = month + 12 * a - 3;
    const JDN = day + Math.floor((153 * m + 2) / 5) + 365 * y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) - 32045;
    const JD = JDN + (hours - 12) / 24;
    const n = JD - 2451545.0;
    
    const L = (280.460 + 0.9856474 * n) % 360;
    const g = (357.528 + 0.9856003 * n) % 360;
    const gRad = g * Math.PI / 180;
    const lambda = (L + 1.915 * Math.sin(gRad) + 0.020 * Math.sin(2 * gRad)) % 360;
    const epsilon = 23.439 - 0.0000004 * n;
    
    const lambdaRad = lambda * Math.PI / 180;
    const epsilonRad = epsilon * Math.PI / 180;
    const sunDec = Math.asin(Math.sin(epsilonRad) * Math.sin(lambdaRad)) * 180 / Math.PI;
    
    const GMST = (280.46061837 + 360.98564736629 * n) % 360;
    const sunRA = (Math.atan2(Math.cos(epsilonRad) * Math.sin(lambdaRad), Math.cos(lambdaRad)) * 180 / Math.PI + 360) % 360;
    const sunHA = (GMST + LON - sunRA + 360) % 360;
    const normalizedHA = sunHA > 180 ? sunHA - 360 : sunHA;
    
    const latRad = LAT * Math.PI / 180;
    const decRad = sunDec * Math.PI / 180;
    const haRad = normalizedHA * Math.PI / 180;
    
    return Math.asin(Math.sin(latRad) * Math.sin(decRad) + Math.cos(latRad) * Math.cos(decRad) * Math.cos(haRad)) * 180 / Math.PI;
  }
  
  // Binary search for sunrise (sun crosses 0Â° going up)
  let sunrise = null;
  const startOfDay = new Date(now);
  startOfDay.setUTCHours(0, 0, 0, 0);
  
  for(let h = 0; h < 24; h++) {
    const t1 = new Date(startOfDay);
    t1.setUTCHours(h);
    const alt1 = getSunAltAtTime(t1);
    
    const t2 = new Date(startOfDay);
    t2.setUTCHours(h + 1);
    const alt2 = getSunAltAtTime(t2);
    
    // Sunrise: altitude goes from negative to positive
    if(alt1 < 0 && alt2 > 0) {
      let low = t1.getTime(), high = t2.getTime();
      for(let i = 0; i < 15; i++) {
        const mid = (low + high) / 2;
        const midDate = new Date(mid);
        if(getSunAltAtTime(midDate) < 0) low = mid;
        else high = mid;
      }
      sunrise = new Date((low + high) / 2);
      break;
    }
  }
  
  // Binary search for sunset (sun crosses 0Â° going down)
  let sunset = null;
  for(let h = 23; h >= 0; h--) {
    const t1 = new Date(startOfDay);
    t1.setUTCHours(h);
    const alt1 = getSunAltAtTime(t1);
    
    const t2 = new Date(startOfDay);
    t2.setUTCHours(h + 1);
    const alt2 = getSunAltAtTime(t2);
    
    // Sunset: altitude goes from positive to negative
    if(alt1 > 0 && alt2 < 0) {
      let low = t1.getTime(), high = t2.getTime();
      for(let i = 0; i < 15; i++) {
        const mid = (low + high) / 2;
        const midDate = new Date(mid);
        if(getSunAltAtTime(midDate) > 0) high = mid;
        else low = mid;
      }
      sunset = new Date((low + high) / 2);
      break;
    }
  }
  
  // Calculate moonrise/moonset similarly
  function getMoonAltAtTime(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth() + 1;
    const day = date.getUTCDate();
    const hours = date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;
    
    const a = Math.floor((14 - month) / 12);
    const y = year + 4800 - a;
    const m = month + 12 * a - 3;
    const JDN = day + Math.floor((153 * m + 2) / 5) + 365 * y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) - 32045;
    const JD = JDN + (hours - 12) / 24;
    const n = JD - 2451545.0;
    
    const epsilon = 23.439 - 0.0000004 * n;
    const moonL = (218.316 + 13.176396 * n) % 360;
    const moonM = (134.963 + 13.064993 * n) % 360;
    const moonF = (93.272 + 13.229350 * n) % 360;
    
    const moonLambda = (moonL + 6.289 * Math.sin(moonM * Math.PI / 180)) % 360;
    const moonBeta = 5.128 * Math.sin(moonF * Math.PI / 180);
    
    const moonDec = Math.asin(Math.sin(epsilon * Math.PI / 180) * Math.sin(moonLambda * Math.PI / 180) * Math.cos(moonBeta * Math.PI / 180) +
      Math.cos(epsilon * Math.PI / 180) * Math.sin(moonBeta * Math.PI / 180)) * 180 / Math.PI;
    
    const GMST = (280.46061837 + 360.98564736629 * n) % 360;
    const moonRA = Math.atan2(
      Math.cos(epsilon * Math.PI / 180) * Math.sin(moonLambda * Math.PI / 180) - Math.tan(moonBeta * Math.PI / 180) * Math.sin(epsilon * Math.PI / 180),
      Math.cos(moonLambda * Math.PI / 180)
    ) * 180 / Math.PI;
    
    const moonHA = (GMST + LON - moonRA + 360) % 360;
    const normalizedMoonHA = moonHA > 180 ? moonHA - 360 : moonHA;
    
    const latRad = LAT * Math.PI / 180;
    const decRad = moonDec * Math.PI / 180;
    const haRad = normalizedMoonHA * Math.PI / 180;
    
    return Math.asin(Math.sin(latRad) * Math.sin(decRad) + Math.cos(latRad) * Math.cos(decRad) * Math.cos(haRad)) * 180 / Math.PI;
  }
  
  let moonrise = null;
  for(let h = 0; h < 24; h++) {
    const t1 = new Date(startOfDay);
    t1.setUTCHours(h);
    const alt1 = getMoonAltAtTime(t1);
    
    const t2 = new Date(startOfDay);
    t2.setUTCHours(h + 1);
    const alt2 = getMoonAltAtTime(t2);
    
    if(alt1 < 0 && alt2 > 0) {
      let low = t1.getTime(), high = t2.getTime();
      for(let i = 0; i < 15; i++) {
        const mid = (low + high) / 2;
        const midDate = new Date(mid);
        if(getMoonAltAtTime(midDate) < 0) low = mid;
        else high = mid;
      }
      moonrise = new Date((low + high) / 2);
      break;
    }
  }
  
  let moonset = null;
  for(let h = 23; h >= 0; h--) {
    const t1 = new Date(startOfDay);
    t1.setUTCHours(h);
    const alt1 = getMoonAltAtTime(t1);
    
    const t2 = new Date(startOfDay);
    t2.setUTCHours(h + 1);
    const alt2 = getMoonAltAtTime(t2);
    
    if(alt1 > 0 && alt2 < 0) {
      let low = t1.getTime(), high = t2.getTime();
      for(let i = 0; i < 15; i++) {
        const mid = (low + high) / 2;
        const midDate = new Date(mid);
        if(getMoonAltAtTime(midDate) > 0) high = mid;
        else low = mid;
      }
      moonset = new Date((low + high) / 2);
      break;
    }
  }
  
  // Store for display
  window.sunriseTime = sunrise;
  window.sunsetTime = sunset;
  window.moonriseTime = moonrise;
  window.moonsetTime = moonset;
}

function updateTimeDisplay(now){
  const h = now.getHours(), m = now.getMinutes(), ampm = h >= 12 ? 'PM' : 'AM', dh = h % 12 || 12;
  document.getElementById('localtime').textContent = `${dh}:${m.toString().padStart(2, '0')} ${ampm}`;
  // Check owl schedule every second with the local clock
  checkOwlSchedule(now);
  
  let sunDisplay = 'Up â˜€';
  if(sunAlt <= 0 && sunAlt > -18) sunDisplay = 'Twilight ğŸŒ†';
  else if(sunAlt <= -18) sunDisplay = 'Down';
  
  // Format rise/set times
  let sunrisesetText = '';
  if(window.sunriseTime || window.sunsetTime) {
    const times = [];
    if(window.sunriseTime) {
      const sr = window.sunriseTime;
      const srh = sr.getHours(), srm = sr.getMinutes();
      const srampm = srh >= 12 ? 'PM' : 'AM', srdh = srh % 12 || 12;
      times.push(`â†‘${srdh}:${srm.toString().padStart(2, '0')}${srampm.charAt(0)}`);
    }
    if(window.sunsetTime) {
      const ss = window.sunsetTime;
      const ssh = ss.getHours(), ssm = ss.getMinutes();
      const ssampm = ssh >= 12 ? 'PM' : 'AM', ssdh = ssh % 12 || 12;
      times.push(`â†“${ssdh}:${ssm.toString().padStart(2, '0')}${ssampm.charAt(0)}`);
    }
    sunrisesetText = times.join(' ');
  }
  document.getElementById('suninfo').textContent = sunDisplay;
  document.getElementById('sunriseset').textContent = sunrisesetText;
  
  if(moonAlt > 0){
    const phases = [
      {name:'New', icon:'ğŸŒ‘', range:[0, 0.03]},
      {name:'Waxing Crescent', icon:'ğŸŒ’', range:[0.03, 0.22]},
      {name:'First Quarter', icon:'ğŸŒ“', range:[0.22, 0.28]},
      {name:'Waxing Gibbous', icon:'ğŸŒ”', range:[0.28, 0.47]},
      {name:'Full', icon:'ğŸŒ•', range:[0.47, 0.53]},
      {name:'Waning Gibbous', icon:'ğŸŒ–', range:[0.53, 0.72]},
      {name:'Last Quarter', icon:'ğŸŒ—', range:[0.72, 0.78]},
      {name:'Waning Crescent', icon:'ğŸŒ˜', range:[0.78, 0.97]},
      {name:'New', icon:'ğŸŒ‘', range:[0.97, 1]}
    ];
    
    let currentPhase = phases[0];
    for(let phase of phases){
      if(moonPhase >= phase.range[0] && moonPhase <= phase.range[1]){
        currentPhase = phase;
        break;
      }
    }
    
    const illumination = Math.round(Math.abs(Math.cos((moonPhase - 0.5) * Math.PI * 2)) * 100);
    document.getElementById('mooninfo').textContent = `${currentPhase.name} ${currentPhase.icon} (${illumination}%)`;
  }else{
    document.getElementById('mooninfo').textContent = 'Down';
  }
  
  // Format moonrise/moonset times
  let moonrisesetText = '';
  if(window.moonriseTime || window.moonsetTime) {
    const times = [];
    if(window.moonriseTime) {
      const mr = window.moonriseTime;
      const mrh = mr.getHours(), mrm = mr.getMinutes();
      const mrampm = mrh >= 12 ? 'PM' : 'AM', mrdh = mrh % 12 || 12;
      times.push(`â†‘${mrdh}:${mrm.toString().padStart(2, '0')}${mrampm.charAt(0)}`);
    }
    if(window.moonsetTime) {
      const ms = window.moonsetTime;
      const msh = ms.getHours(), msm = ms.getMinutes();
      const msampm = msh >= 12 ? 'PM' : 'AM', msdh = msh % 12 || 12;
      times.push(`â†“${msdh}:${msm.toString().padStart(2, '0')}${msampm.charAt(0)}`);
    }
    moonrisesetText = times.join(' ');
  }
  document.getElementById('moonriseset').textContent = moonrisesetText;
}

function updateClock(){
  const now = new Date();
  const h = now.getHours(), m = now.getMinutes(), s = now.getSeconds();
  const ampm = h >= 12 ? 'PM' : 'AM', dh = h % 12 || 12;
  const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  const dayName = days[now.getDay()];
  const month = now.getMonth() + 1;
  const date = now.getDate();
  const year = now.getFullYear();
  
  if(showClock){
    document.getElementById('clockTime').textContent = `${dh}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')} ${ampm}`;
    document.getElementById('clockTemp').innerHTML = `<div>${dayName}, ${month}/${date}/${year}</div><div style="font-size:28px;margin-top:6px">${weatherData.temp}Â°F</div>`;
  }
}

function checkAlarm(){
  if(!alarmTime || alarmTriggered) return;
  const now = new Date();
  const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
  if(currentTime === alarmTime){
    playAlarmSound(alarmSoundType);
    showNotification('â° ALARM! Time: ' + alarmTime);
    alarmTriggered = true;
  }
}

function altAzToScreen(alt, az){
  let y;
  if(alt < -30){
    y = H + 200 + (Math.abs(alt) - 30) * 10;
  }else if(alt < 0){
    const progress = (alt + 30) / 30;
    y = H * 1.2 - (progress * H * 0.7);
  }else{
    const progress = alt / 90;
    y = H * 0.5 - (progress * H * 0.6);
  }
  
  // Enhanced azimuth mapping with seasonal variation
  // The sun's azimuth range varies by season - wider arc in summer, narrower in winter
  const azNorm = (az - 180) / 180;
  const x = W * 0.5 + (azNorm * W * 0.7); // Increased from 0.6 to 0.7 for more left-right movement
  
  return {x, y, visible: alt > -6 && x > -100 && x < W + 100 && y > -100 && y < H + 100};
}
document.getElementById('hideBtn').addEventListener('click', () => {
  controlsHidden = !controlsHidden;
  const btns = document.querySelectorAll('.btn:not(#hideBtn)');
  btns.forEach(btn => btn.classList.toggle('hidden'));
  document.getElementById('hideBtn').textContent = controlsHidden ? 'ğŸ‘ï¸ Show UI' : 'ğŸ‘ï¸ Hide UI';
});

document.getElementById('soundBtn').addEventListener('click', () => {
  if(!soundEnabled){
    initAudio();
    document.getElementById('soundBtn').textContent = 'ğŸ”Š ON';
    document.getElementById('soundBtn').classList.add('active');
  }else{
    stopSounds();
    soundEnabled = false;
    // Stop ambient audio
    if(ambienceAudio) ambienceAudio.pause();
    document.getElementById('soundBtn').textContent = 'ğŸ”‡ OFF';
    document.getElementById('soundBtn').classList.remove('active');
  }
});

document.getElementById('fullscreenBtn').addEventListener('click', () => {
  if(!document.fullscreenElement) document.documentElement.requestFullscreen();
  else document.exitFullscreen();
});

document.getElementById('infoPanelBtn').addEventListener('click', () => {
  infoPanelVisible = !infoPanelVisible;
  document.getElementById('ui').classList.toggle('hidden');
  document.getElementById('infoPanelBtn').classList.toggle('active');
  saveSettings();
});

document.getElementById('storeBtn').addEventListener('click', () => {
  document.getElementById('store').classList.toggle('visible');
});

document.getElementById('clockBtn').addEventListener('click', () => {
  showClock = !showClock;
  document.getElementById('clock').classList.toggle('visible');
  document.getElementById('clockBtn').classList.toggle('active');
  saveSettings();
});

document.getElementById('alarmBtn').addEventListener('click', () => {
  document.getElementById('alarmModal').classList.add('visible');
});

document.getElementById('locationBtn').addEventListener('click', () => {
  document.getElementById('locName').value = LOCATION_NAME;
  document.getElementById('locLat').value = LAT;
  document.getElementById('locLon').value = LON;
  document.getElementById('locationModal').classList.add('visible');
});

document.getElementById('removeModeBtn').addEventListener('click', () => {
  removeMode = !removeMode;
  document.getElementById('removeModeBtn').classList.toggle('active');
  document.querySelectorAll('.item').forEach(i => i.classList.toggle('remove-mode'));
  document.getElementById('selected').textContent = removeMode ? 'Remove' : 'None';
  if(!removeMode){ selectedType = null; selectedSubtype = null; }
});

document.getElementById('closeAlert').addEventListener('click', () => {
  document.getElementById('weatherAlert').classList.remove('visible');
});

document.getElementById('weatherBeacon').addEventListener('click', () => {
  let msg = '';
  if(weatherData.condition === 'Storm'){
    msg = 'â›ˆï¸ <strong>Severe Thunderstorm Warning</strong><br><br>Severe thunderstorm conditions detected in your area. Seek shelter immediately. Lightning and heavy rain present.';
  }
  if(weatherData.windSpeed > 25){
    msg += (msg ? '<br><br>' : '') + 'ğŸ’¨ <strong>High Wind Warning</strong><br><br>Sustained winds of ' + weatherData.windSpeed + ' mph detected. Secure loose objects and avoid outdoor activities.';
  }
  document.getElementById('beaconAlertMessage').innerHTML = msg;
  document.getElementById('beaconAlert').classList.add('visible');
});

document.querySelectorAll('.item').forEach(item => {
  item.addEventListener('click', () => {
    if(removeMode) return;
    
    const type = item.dataset.type;
    const subtype = item.dataset.subtype;
    
    if(type === 'terrain'){
      terrainType = subtype;
      buildTerrain();
      generateGrassPatches();
      saveSettings();
      return;
    }
    
    if(type === 'accessory' && subtype === 'custom'){
      document.getElementById('signModal').classList.add('visible');
      return;
    }
    
    document.querySelectorAll('.item').forEach(i => i.classList.remove('selected'));
    item.classList.add('selected');
    selectedType = type;
    selectedSubtype = subtype;
    document.getElementById('selected').textContent = item.querySelector('.item-name').textContent;
  });
});

document.addEventListener('keydown', (e) => {
  if(e.key === 'Escape'){
    document.getElementById('store').classList.remove('visible');
    document.getElementById('alarmModal').classList.remove('visible');
    document.getElementById('locationModal').classList.remove('visible');
    document.getElementById('cloudModal').classList.remove('visible');
    const birdGuide = document.getElementById('birdGuideModal');
    const fishGuide = document.getElementById('fishGuideModal');
    const treeGuide = document.getElementById('treeGuideModal');
    if(birdGuide) birdGuide.style.display='none';
    if(fishGuide) fishGuide.style.display='none';
    if(treeGuide) treeGuide.style.display='none';
  }
  if(e.key === 's' && e.ctrlKey){
    e.preventDefault();
    document.getElementById('store').classList.toggle('visible');
  }
  if(e.key === 'i' && e.ctrlKey){
    e.preventDefault();
    infoPanelVisible = !infoPanelVisible;
    document.getElementById('ui').classList.toggle('hidden');
  }
  if(e.key === 'h'){
    controlsHidden = !controlsHidden;
    const btns = document.querySelectorAll('.btn:not(#hideBtn)');
    btns.forEach(btn => btn.classList.toggle('hidden'));
  }
});

let touchStartX = 0;
let touchStartY = 0;

canvas.addEventListener('touchstart', (e) => {
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
}, {passive: true});

canvas.addEventListener('touchend', (e) => {
  const touchEndX = e.changedTouches[0].clientX;
  const touchEndY = e.changedTouches[0].clientY;
  
  const deltaX = Math.abs(touchEndX - touchStartX);
  const deltaY = Math.abs(touchEndY - touchStartY);
  
  if(deltaX < 10 && deltaY < 10){
    const rect = canvas.getBoundingClientRect();
    const x = (touchEndX - rect.left) * (W / rect.width);
    const y = (touchEndY - rect.top) * (H / rect.height);
    
    if(removeMode){
      for(let i = items.length - 1; i >= 0; i--){
        if(Math.abs(items[i].screenX - x) < 40 && Math.abs(items[i].screenY - y) < 60){
          items.splice(i, 1);
          saveSettings();
          if(navigator.vibrate) navigator.vibrate(50);
          break;
        }
      }
    }else if(selectedType){
      // Allow placement anywhere on canvas for background terrains
      const animalWalkY = H * 0.65;
      const itemY = y; // Use clicked Y position directly
      
      // Allow placement in background areas (anywhere Y < animalWalkY + 60)
      if(itemY < animalWalkY + 60){
        items.push(new Item(x, itemY, selectedType, selectedSubtype));
        saveSettings();
      } else {
        console.warn('âŒ Item blocked - only background placement allowed (place higher up)');
      }
      
      // Track first two plants for terrain boundaries
      if(selectedType === 'plant' && firstPlantY === null){
        firstPlantY = itemY;
        console.log(`ğŸŒ± FIRST PLANT (BOTTOM BOUNDARY): Y=${Math.round(firstPlantY)} - Items here will appear IN FRONT of animations`);
      } else if(selectedType === 'plant' && secondPlantY === null && firstPlantY !== null){
        secondPlantY = itemY;
        console.log(`ğŸŒ² SECOND PLANT (TOP BOUNDARY): Y=${Math.round(secondPlantY)} - Items here will appear BEHIND animations`);
        console.log(`ğŸ“ Boundary range: ${Math.round(Math.min(firstPlantY, secondPlantY))} to ${Math.round(Math.max(firstPlantY, secondPlantY))}`);
      }
    }
  }
});



// Rake feature removed

canvas.addEventListener('click', e => {
  if(!ready) return;
  const r = canvas.getBoundingClientRect();
  const x = (e.clientX - r.left) * (W / r.width);
  const y = (e.clientY - r.top) * (H / r.height);
  if(removeMode){
    for(let i = items.length - 1; i >= 0; i--){
      if(Math.abs(items[i].screenX - x) < 30 && Math.abs(items[i].screenY - y) < 50){
        items.splice(i, 1);
        saveSettings();
        break;
      }
    }
  }else if(selectedType){
    // Allow placement anywhere on canvas for background terrains
    const animalWalkY = H * 0.65;
    const itemY = y; // Use clicked Y position directly
    
    console.log(`Click: selectedType=${selectedType}, y=${Math.round(y)}, itemY=${Math.round(itemY)}, animalWalkY=${Math.round(animalWalkY)}, threshold=${Math.round(animalWalkY + 60)}, pass=${itemY < animalWalkY + 60}`);
    
    // Allow placement in background areas (anywhere Y < animalWalkY + 60)
    if(itemY < animalWalkY + 60){
      items.push(new Item(x, itemY, selectedType, selectedSubtype));
      console.log(`âœ… Item placed!`);
      saveSettings();
    } else {
      console.warn('âŒ Item blocked - only background placement allowed (place higher up)');
    }
    
    // Track first two plants for terrain boundaries
    if(selectedType === 'plant' && firstPlantY === null){
      firstPlantY = itemY;
      console.log(`ğŸŒ± FIRST PLANT (BOTTOM BOUNDARY): Y=${Math.round(firstPlantY)} - Items here will appear IN FRONT of animations`);
    } else if(selectedType === 'plant' && secondPlantY === null && firstPlantY !== null){
      secondPlantY = itemY;
      console.log(`ğŸŒ² SECOND PLANT (TOP BOUNDARY): Y=${Math.round(secondPlantY)} - Items here will appear BEHIND animations`);
      console.log(`ğŸ“ Boundary range: ${Math.round(Math.min(firstPlantY, secondPlantY))} to ${Math.round(Math.max(firstPlantY, secondPlantY))}`);
    }
    
    saveSettings();
  }
});

window.addEventListener('resize', () => {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  canvasLayer1.width = W; canvasLayer1.height = H;
  canvasLayer2.width = W; canvasLayer2.height = H;
  canvasLayer3.width = W; canvasLayer3.height = H;
  canvasLayer4.width = W; canvasLayer4.height = H;
  lightSourceX = W * 0.5;
  lightSourceY = H * 0.3;
  buildTerrain();
  generateStars();
  generateClouds();
  generateGrassPatches();
});
function determineSeason(){
  const month = new Date().getMonth();
  if(month >= 2 && month <= 4) season = 'spring';
  else if(month >= 5 && month <= 7) season = 'summer';
  else if(month >= 8 && month <= 10) season = 'fall';
  else season = 'winter';
}

function buildTerrain(){
  terrain = [];
  bgTerrain = [[], [], []];
  river = [];
  const baseY = H * 0.65;
  
  for(let x = 0; x <= W; x += 4){
    // Foreground terrain is FLAT for consistent creature animation
    // All visual terrain variation is in the background layers
    const y = baseY;
    terrain.push({x, y});
  }

  const mountainTopY = H * 0.35;

  bgDetails = [[],[],[]];
  for(let layer = 0; layer < 3; layer++){
    const peakOffsets = [0, W * 0.5, W];
    const xOffset = peakOffsets[layer];
    
    for(let x = -W * 0.3; x <= W * 1.3; x += 4){
      let noise = 0;
      const scale = 0.002 + layer * 0.0003;
      const layerAmplitude = 120 - layer * 15;
      
      if(terrainType === 'hills'){
        const wave = Math.sin((x + xOffset) * scale);
        noise = Math.pow(Math.abs(wave), 0.5) * Math.sign(wave) * layerAmplitude * 1.2;
      }else if(terrainType === 'flat'){
        const wave = Math.sin((x + xOffset) * scale * 0.5);
        noise = Math.pow(Math.abs(wave), 0.5) * Math.sign(wave) * layerAmplitude * 0.4;
      }else if(terrainType === 'valley'){
        const wave = -Math.abs(Math.sin((x + xOffset) / W * Math.PI));
        noise = Math.pow(Math.abs(wave), 0.6) * Math.sign(wave) * layerAmplitude * 1.8;
      }else if(terrainType === 'mountain'){
        const wave = Math.sin((x + xOffset) * scale);
        noise = Math.pow(Math.abs(wave), 0.4) * Math.sign(wave) * layerAmplitude * 1.6;
      }else if(terrainType === 'peaks'){
        const wave = Math.sin((x + xOffset) * scale * 1.5) + Math.sin((x + xOffset) * scale * 0.5);
        noise = Math.pow(Math.abs(wave), 0.35) * Math.sign(wave) * layerAmplitude * 1.8;
      }else if(terrainType === 'alpine'){
        const wave = Math.sin((x + xOffset) * scale * 0.7);
        noise = Math.pow(Math.abs(wave), 0.3) * Math.sign(wave) * layerAmplitude * 1.9;
      }else if(terrainType === 'plateau'){
        const plateauCount = 3;
        const plateauSection = Math.floor(((x + xOffset) / W) * plateauCount);
        const sectionProgress = (((x + xOffset) / W) * plateauCount) % 1;
        const baseHeight = plateauSection * 60 - 80;
        noise = baseHeight + (sectionProgress < 0.2 || sectionProgress > 0.8 ? Math.sin(sectionProgress * Math.PI * 5) * 40 : 0);
      }else if(terrainType === 'gorge'){
        const mainGorge = -Math.abs(Math.sin(((x + xOffset) / W) * Math.PI)) * 180 + 40;
        const smallValleys = Math.sin((x + xOffset) * 0.015) * 30;
        noise = mainGorge + smallValleys;
      }
      
      const y = mountainTopY + noise + layer * 15;
      bgTerrain[layer].push({x: x, y: y});
    }
    // populate persistent background details for this layer so shapes don't jitter each frame
    const detailCount = layer === 2 ? 15 : layer === 1 ? 25 : 35;
    for(let i = 0; i < detailCount; i++){
      const xPos = (i / detailCount) * W * 1.6 - W * 0.3 + (layer * W * 0.05) + (Math.random()-0.5)*30;
      const terrainIndex = Math.max(0, Math.min(bgTerrain[layer].length-1, Math.floor((xPos + W * 0.3) / 4)));
      const yPos = bgTerrain[layer][terrainIndex] ? bgTerrain[layer][terrainIndex].y : H * 0.35;
      const detailTypeRoll = Math.random();
      let detailType = 'tree';
      if(detailTypeRoll >= 0.5) detailType = 'tree';
      else if(detailTypeRoll < 0.75) detailType = 'rock';
      else detailType = 'log';
      bgDetails[layer].push({x: xPos, y: yPos, type: detailType, seed: Math.random()});
    }
  }

  const riverY = H * 0.78;
  for(let x = 0; x <= W; x += 4){
    river.push({x, y: riverY + Math.sin(x * 0.01) * 5, flow: Math.random() * Math.PI * 2});
  }
}

function generateStars(){
  stars = [];
  for(let i = 0; i < 200; i++){
    stars.push({
      x: Math.random() * W,
      y: Math.random() * (H * 0.6),
      size: 0.5 + Math.random() * 1.5,
      alpha: Math.random(),
      speed: 0.01 + Math.random() * 0.015,
      bright: false
    });
  }
  
  const now = new Date();
  const lst = (now.getHours() + now.getMinutes() / 60 + LON / 15) % 24;
  
  for(let star of brightStars){
    const ha = (lst - star.ra) * 15;
    const alt = Math.asin(Math.sin(LAT * Math.PI / 180) * Math.sin(star.dec * Math.PI / 180) +
      Math.cos(LAT * Math.PI / 180) * Math.cos(star.dec * Math.PI / 180) * Math.cos(ha * Math.PI / 180)) * 180 / Math.PI;
    
    if(alt > 10){
      const az = Math.atan2(Math.sin(ha * Math.PI / 180),
        Math.cos(ha * Math.PI / 180) * Math.sin(LAT * Math.PI / 180) -
        Math.tan(star.dec * Math.PI / 180) * Math.cos(LAT * Math.PI / 180)) * 180 / Math.PI + 180;
      
      const pos = altAzToScreen(alt, az);
      if(pos.x > 0 && pos.x < W && pos.y > 0 && pos.y < H * 0.6){
        const size = Math.max(1.5, 3.2 - star.mag * 0.35); // scale by brightness
        stars.push({
          x: pos.x,
          y: pos.y,
          size,
          alpha: 0,
          speed: 0.02,
          bright: true,
          name: star.name,
          mag: star.mag,
          constellation: star.con,
          ra: star.ra,
          dec: star.dec,
          alt,
          az
        });
      }
    }
  }
}

function generateClouds(){
  clouds = [];
  cloudShadows = [];
  const baseCount = Math.floor(weatherData.cloudCover / 10) + 1;
  const count = weatherData.condition === 'Cloudy' ? baseCount + 2 : weatherData.condition === 'Rain' ? baseCount + 4 : weatherData.condition === 'Storm' ? baseCount + 5 : baseCount;
  
  for(let i = 0; i < count; i++){
    const puffs = [];
    const baseX = Math.random() * W * 1.5 - W * 0.25;
    const baseY = H * 0.05 + Math.random() * (H * 0.25);
    const puffCount = 3 + Math.floor(Math.random() * 4);
    
    for(let j = 0; j < puffCount; j++){
      puffs.push({
        ox: j * 40 - puffCount * 20 + Math.random() * 20,
        oy: (Math.random() - 0.5) * 20,
        size: 30 + Math.random() * 40
      });
    }
    
    const cloud = {
      x: baseX,
      y: baseY,
      puffs,
      speed: 0.05 + Math.random() * 0.15 + weatherData.windSpeed * 0.01,
      opacity: 0.3 + Math.random() * 0.4
    };
    clouds.push(cloud);
    
    cloudShadows.push({
      cloudIndex: i,
      opacity: 0.2 + Math.random() * 0.15
    });
  }
}

function generateGrassPatches(){
  grassPatches = [];
  for(let i = 0; i < 60; i++){
    const x = Math.random() * W;
    const terrainY = getTerrainY(x);
    
    if(terrainY < H * 0.85){
      const blades = [];
      for(let j = 0; j < 8; j++){
        blades.push({
          ox: (Math.random() - 0.5) * 15,
          height: 8 + Math.random() * 15,
          sway: Math.random() * Math.PI * 2,
          speed: 0.015 + Math.random() * 0.02
        });
      }
      grassPatches.push({x, y: terrainY, blades});
    }
  }
}

function generateFish(){
  fish = [];
  const fishTypes = [
    {name:'minnow', size:0.3, speed:0.4, color:'rgb(180,200,220)'},
    {name:'bluegill', size:0.6, speed:0.3, color:'rgb(100,150,200)'},
    {name:'bass', size:1, speed:0.5, color:'rgb(80,120,80)'},
    {name:'trout', size:0.8, speed:0.7, color:'rgb(150,130,100)'},
    {name:'catfish', size:1.2, speed:0.4, color:'rgb(60,60,50)'}
  ];
  
  const waterY = H * 0.78;
  let minnowSchoolId = 0;
  let bluegillSchoolId = 100; // Start at 100 to keep separate from minnows
  
  // Define exact fish counts
  const fishCounts = {
    minnow: 12,
    bluegill: 6,
    bass: 3,
    trout: 5,
    catfish: 8
  };
  
  // Create fish with proper schooling and specific counts
  for(let [typeName, count] of Object.entries(fishCounts)){
    const typeData = fishTypes.find(t => t.name === typeName);
    
    for(let i = 0; i < count; i++){
      const fsize = typeData.size * (0.7 + Math.random() * 0.6);
      
      let depth, currentSchoolId;
      
      if(typeName === 'minnow'){
        // Minnows: right at the very top of the water
        depth = 0 + Math.random() * 0.06; // 0-5px below surface
        // Schools of 6: schoolId 0 for fish 0-5, schoolId 1 for fish 6-11
        currentSchoolId = Math.floor(i / 6);
      }else if(typeName === 'bluegill'){
        // Bluegills: below minnows, separate school IDs
        depth = 0.19 + Math.random() * 0.12; // 15-25px below surface
        // Schools of 3: use separate ID range (100+)
        currentSchoolId = bluegillSchoolId + Math.floor(i / 3);
      }else if(typeName === 'trout'){
        // Trout: mid-level, ~50px spacing from bluegill
        depth = 0.5 + Math.random() * 0.25; // 40-60px below surface
        currentSchoolId = null;
      }else if(typeName === 'bass'){
        // Bass: deeper than trout, ~50px spacing
        depth = 0.81 + Math.random() * 0.25; // 65-85px below surface
        currentSchoolId = null;
      }else if(typeName === 'catfish'){
        // Catfish: very low at bottom, ~200px depth
        depth = 2.5 + Math.random() * 0.25; // 200-220px below surface
        currentSchoolId = null;
      }
      
      const fish_obj = {
        x: Math.random() * W,
        y: waterY + 10 + Math.random() * 30,
        type: typeName,
        size: fsize,
        speed: typeData.speed * (0.7 + Math.random() * 0.6),
        direction: Math.random() < 0.5 ? 1 : -1,
        color: typeData.color,
        wiggle: Math.random() * Math.PI * 2,
        depth: depth,
        jumpState: 'idle',
        jumpTimer: 0,
        jumpDuration: 0,
        jumpType: null,
        isSmall: fsize < 0.9,
        schoolId: currentSchoolId,
      };
      
      fish.push(fish_obj);
    }
  }
}
function updateCreatures(){
  const light = calculateLighting();
  const hours = new Date().getHours();
  
  // Owl spawn handled by scheduler (2â€“7 AM), do not auto-spawn here
  
  // Remove owl only during full daylight (sun well above horizon)
  if(owl && sunAlt > 5){
    owl = null;
  }
  
  if(owl){
    owl.blink += owl.blinkRate;
    // Keep owl position fixed - only update if tree position changed
    if(owl.tree.screenX !== owl.lastTreeX || owl.tree.screenY !== owl.lastTreeY){
      owl.x = owl.tree.screenX;
      owl.y = owl.tree.screenY - owl.tree.maxH * 0.7;
      owl.lastTreeX = owl.tree.screenX;
      owl.lastTreeY = owl.tree.screenY;
    }
    
    owl.hootTimer++;
    const h = new Date().getHours();
    if(owl.hootTimer >= owl.nextHoot && soundEnabled && h >= 2 && h < 7){
      createOwlHoot();
      owl.hootTimer = 0;
      owl.nextHoot = 800 + Math.random() * 1200;
    }
  }
  
  if(light < 0.1){
    if(creatures.length < 4 && Math.random() < 0.4){
      const type = Math.random();
      let x, y;
      
      if(type < 0.5){
        x = Math.random() * W;
        y = getTerrainY(x) - 10;
      }else{
        x = Math.random() * W;
        y = H * 0.78 + Math.sin(x * 0.01) * 5;
      }
      
      const colors = ['#ffff00', '#00ff00', '#ff6600', '#ff0000', '#00ffff'];
      creatures.push({
        x, y,
        blink: Math.random() * Math.PI * 2,
        blinkRate: 0.01 + Math.random() * 0.02,
        color: colors[Math.floor(Math.random() * colors.length)],
        lifetime: 400 + Math.random() * 600
      });
    }
  }else{
    creatures = [];
  }
  
  for(let i = creatures.length - 1; i >= 0; i--){
    creatures[i].lifetime--;
    if(creatures[i].lifetime <= 0 || Math.random() < 0.03){
      creatures.splice(i, 1);
    }
  }
}

// Weather API cache with 5-minute TTL
const weatherCache = {
  data: null,
  timestamp: null,
  ttl: 5*60*1000, // 5 minutes
  isValid(){
    return this.data && this.timestamp && (Date.now() - this.timestamp) < this.ttl;
  },
  set(data){
    this.data = data;
    this.timestamp = Date.now();
  },
  get(){
    return this.isValid() ? this.data : null;
  },
  clear(){
    this.data = null;
    this.timestamp = null;
  }
};

async function fetchWeather(){
  try{
    // Check cache first
    const cached = weatherCache.get();
    let d = cached;
    
    if(!cached){
      // Fetch from API if not cached
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000);
      
      const r = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${LAT}&longitude=${LON}&current=temperature_2m,precipitation,wind_speed_10m,relative_humidity_2m,weather_code,cloud_cover&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch`, {
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      if(!r.ok) throw new Error(`HTTP error! status: ${r.status}`);
      
      d = await r.json();
      
      // Cache the data
      weatherCache.set(d);
      console.log('Weather data cached at', new Date().toLocaleTimeString());
    }else{
      console.log('Using cached weather data from', new Date(weatherCache.timestamp).toLocaleTimeString());
    }
    
    weatherData.temp = Math.round(d.current.temperature_2m);
    weatherData.windSpeed = Math.round(d.current.wind_speed_10m);
    weatherData.precipitation = d.current.precipitation || 0;
    weatherData.humidity = d.current.relative_humidity_2m;
    weatherData.cloudCover = d.current.cloud_cover || 0;
    
    const code = d.current.weather_code;
    if(code === 0) weatherData.condition = 'Clear';
    else if(code <= 3) weatherData.condition = 'Cloudy';
    else if(code <= 67) {
      // Check temperature to determine rain vs snow
      weatherData.condition = weatherData.temp <= 32 ? 'Snow' : 'Rain';
    }
    else if(code >= 71 && code <= 77) weatherData.condition = 'Snow';
    else if(code >= 95) weatherData.condition = 'Storm';
    else weatherData.condition = 'Cloudy';
    
    if(weatherData.condition === 'Storm' || weatherData.windSpeed > 25){
      showWeatherAlert();
    }
    
    generateClouds();
    updateWeatherDisplay();
    updateWeatherSounds();
  }catch(e){
    console.log('Weather fetch failed:', e.message);
    weatherCache.clear(); // Clear cache on error
    weatherData = {
      temp: 65,
      condition: 'Clear',
      windSpeed: 5,
      precipitation: 0,
      humidity: 50,
      cloudCover: 20
    };
    updateWeatherDisplay();
    setTimeout(fetchWeather, 60000);
  }
}

function showWeatherAlert(){
  document.getElementById('alertTitle').textContent = 'âš ï¸ Weather Alert';
  let msg = '';
  if(weatherData.condition === 'Storm'){
    msg = 'Severe thunderstorm conditions.';
    if(soundEnabled) createTornadoSiren();
  }
  if(weatherData.windSpeed > 25){
    msg += ' High winds: ' + weatherData.windSpeed + 'mph.';
    if(!msg.includes('Storm') && soundEnabled) createTornadoSiren();
  }
  document.getElementById('alertMessage').textContent = msg;
  document.getElementById('weatherAlert').classList.add('visible');
  document.getElementById('weatherBeacon').style.display = 'block';
  setTimeout(() => document.getElementById('weatherAlert').classList.remove('visible'), 8000);
}

function hideWeatherBeacon(){
  if(weatherData.condition !== 'Storm' && weatherData.windSpeed <= 25){
    document.getElementById('weatherBeacon').style.display = 'none';
  }
}

function updateWeatherDisplay(){
  document.getElementById('temp').textContent = weatherData.temp + 'Â°F';
  document.getElementById('wind').textContent = weatherData.windSpeed + 'mph';
  document.getElementById('humidity').textContent = weatherData.humidity + '%';
  document.getElementById('weather').textContent = weatherData.condition;
  const icons = {Clear:'â˜€ï¸', Cloudy:'â˜ï¸', Rain:'ğŸŒ§ï¸', Snow:'â„ï¸', Storm:'â›ˆï¸'};
  document.getElementById('weatherIcon').textContent = icons[weatherData.condition] || '';
  hideWeatherBeacon();
}

function updateWeatherEffects(){
  // Realistic snow accumulation and melting based on temperature
  if(weatherData.condition === 'Snow' && weatherData.temp < 35){
    // Snow is actively falling and accumulating
    snowCover = Math.min(1, snowCover + 0.002);
  }else if(weatherData.condition !== 'Snow' && snowCover > 0){
    // Snow melts based on temperature when not actively snowing
    const meltRate = Math.max(0, weatherData.temp - 32) / 40; // No melt below 32Â°F, faster above
    snowCover = Math.max(0, snowCover - (meltRate * 0.0005)); // Slow realistic melt
  }
  
  if(weatherData.condition === 'Storm'){
    if(!lightning.active && Math.random() < 0.015){
      lightning.active = true;
      lightning.intensity = 0.6 + Math.random() * 0.4;
      lightning.countdown = 3 + Math.floor(Math.random() * 8);
      lightning.x = Math.random() * W;
      if(soundEnabled) setTimeout(() => createThunder(lightning.intensity), lightning.countdown * 100);
    }
  }
  
  if(lightning.active){
    lightning.intensity *= 0.85;
    if(lightning.intensity < 0.05) lightning.active = false;
  }
}

function spawnBird(){
  // Only active from dawn through dusk
  if(birds.length > 12 || sunAlt <= -6 || sunAlt >= 89) return; // leave at dusk (sunAlt<=-6), return at dawn (>-6), no zenith overflow
  const x = Math.random() < 0.5 ? -50 : W + 50;
  const y = H * 0.15 + Math.random() * H * 0.25;
  const types = ['cardinal', 'robin', 'generic', 'generic'];
  
  const targetTree = items.find(item => item.type === 'plant' && !item.isBush && Math.random() < 0.3);
  
  birds.push(new Bird(x, y, types[Math.floor(Math.random() * types.length)], targetTree));
}

function spawnCrow(){
  // spawn either a lone crow or a small 'murder' group
  if(birds.length > 18) return;
  if(sunAlt <= -6 || sunAlt >= 89) return; // civil dawn/dusk window only
  const mode = Math.random() < 0.6 ? 'single' : 'murder';
  if(mode === 'single'){
    const x = Math.random() < 0.5 ? -80 : W + 80;
    const y = H * 0.12 + Math.random() * H * 0.18;
    const c = new Bird(x, y, 'crow', null);
    c.color = '#000';
    birds.push(c);
    if(soundEnabled) setTimeout(() => createCrowCaw('single'), Math.random() * 600);
  }else{
    const count = 3 + Math.floor(Math.random() * 4);
    const startX = Math.random() < 0.5 ? -100 : W + 100;
    const baseY = H * 0.12 + Math.random() * H * 0.18;
    for(let i = 0; i < count; i++){
      const b = new Bird(startX + i * (Math.random()*30+10), baseY + (Math.random()-0.5)*20, 'crow', null);
      b.color = '#111';
      b.vx = (startX < 0) ? 2 + Math.random()*1.5 : -(2 + Math.random()*1.5);
      birds.push(b);
    }
    if(soundEnabled){
      setTimeout(() => createCrowCaw('murder'), 180);
    }
  }
}

function calculateLighting(){
  let light = 0.01;
  
  // Base lighting purely on sun altitude for accurate day/night
  if(sunAlt > 0){
    // Daytime: sun is above horizon
    light = 0.45 + (sunAlt / 90) * 0.45; // range ~0.45 -> 0.9
  }else if(sunAlt > -6){
    // Civil twilight
    light = 0.25 + (sunAlt + 6) / 6 * 0.20;
  }else if(sunAlt > -12){
    // Nautical twilight
    light = 0.12 + (sunAlt + 12) / 6 * 0.13;
  }else if(sunAlt > -18){
    // Astronomical twilight
    light = 0.05 + (sunAlt + 18) / 6 * 0.07;
  }else{
    // Night - much darker
    light = 0.005;
  }
  
  // Add moonlight when sun is down
  if(moonAlt > 0 && sunAlt < -6){
    const moonBright = moonPhase > 0.4 && moonPhase < 0.6 ? 0.20 : 0.10;
    light += moonAlt / 90 * moonBright;
  }
  
  // Clouds dim the scene
  if(weatherData.cloudCover > 10){
    const cloudFactor = Math.max(0.3, 1 - weatherData.cloudCover / 150);
    light *= cloudFactor;
  }
  
  if(lightning.active) light = Math.min(1, light + lightning.intensity * 0.7);

  return Math.max(0.003, Math.min(1, light));
}

function getSunsetSunriseColors(progress){
  if(progress < 0.15 || progress > 0.85){
    const t = progress < 0.15 ? progress / 0.15 : (1 - progress) / 0.15;
    return {
      top: [Math.floor(20 + t * 100), Math.floor(20 + t * 80), Math.floor(60 + t * 100)],
      mid: [Math.floor(255 * t), Math.floor(120 * t), Math.floor(60 * t)],
      bot: [Math.floor(255 * t), Math.floor(180 * t), Math.floor(100 * t)]
    };
  }
  return null;
}
function init(){
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  if(isMobile){
    CONFIG.SPAWN_RATES.BIRD_INTERVAL = 15000;
    CONFIG.WEATHER.RAIN_SPAWN_CHANCE = 0.1;
  }
  
  loadSettings();
  const loader = document.getElementById('loader');
  const progressFill = document.getElementById('progressFill');
  const loadingText = document.querySelector('.loading-text');
  
  let progress = 0;
  const updateProgress = (percent, text) => {
    progress = percent;
    progressFill.style.width = percent + '%';
    loadingText.textContent = text;
  };
  
  updateProgress(10, 'Initializing canvas...');
  
  setTimeout(() => {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    canvasLayer1.width = W; canvasLayer1.height = H;
    canvasLayer2.width = W; canvasLayer2.height = H;
    canvasLayer3.width = W; canvasLayer3.height = H;
    canvasLayer4.width = W; canvasLayer4.height = H;
    lightSourceX = W * 0.5;
    lightSourceY = H * 0.3;
    updateProgress(30, 'Building terrain...');
  }, 100);
  
  setTimeout(() => {
    buildTerrain();
    updateProgress(50, 'Generating stars...');
  }, 200);
  
  setTimeout(() => {
    generateStars();
    generateClouds();
    updateProgress(70, 'Creating atmosphere...');
  }, 300);
  
  setTimeout(() => {
    generateGrassPatches();
    generateMoonCraters();
    generateFish();
    updateProgress(85, 'Fetching weather...');
  }, 400);

  setTimeout(() => {
    determineSeason();
    updateAstronomy();
    fetchWeather();
    updateProgress(100, 'Ready!');
  }, 500);
  
  setTimeout(() => {
    loader.classList.add('hidden');
    ready = true;
    
    if(showClock){
      document.getElementById('clock').classList.add('visible');
      document.getElementById('clockBtn').classList.add('active');
    }
    // Sound is always OFF on page load - user must click to enable (browser requirement)
    
    setInterval(updateAstronomy, 60000);
    setInterval(fetchWeather, 120000);
    setInterval(updateClock, 1000);
    setInterval(spawnBird, 8000);
    setInterval(spawnCrow, 45000);
    setInterval(updateWeatherEffects, 100);
    setInterval(updateCreatures, 5000);
    setInterval(checkAlarm, 10000);
    // drop all falling leaves to ground now
    if(fallingLeaves && fallenLeafAccum){
      for(let lf of fallingLeaves){
        const terrainY = getTerrainY(lf.x || Math.random()*W);
        let placed = false;
        for(let pa of fallenLeafAccum){ if(Math.abs(pa.x - (lf.x||0)) < 12){ pa.count = (pa.count||1)+1; placed = true; break; } }
        if(!placed) fallenLeafAccum.push({x: lf.x||0, y: terrainY - 2, color: lf.color || '#b35a2b', size: lf.size || 6, count: 1});
      }
      fallingLeaves.length = 0;
    }
    requestAnimationFrame(draw);
  }, 2200);
}
function draw(){
  if(!ready){ requestAnimationFrame(draw); return; }
  try{
  
  const light = calculateLighting();
  const darken = 1 - light;
  
  const hours = new Date().getHours() + new Date().getMinutes() / 60;
  const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
  
  // DEBUG: Log sun altitude and light level periodically
  if(Math.random() < 0.01){
    console.log(`Sun Alt: ${sunAlt.toFixed(2)}Â° Light: ${light.toFixed(3)}`);
  }
  
  // Determine if we're in sunrise/sunset based on actual sun altitude
  // Sunrise/sunset happens when sun is between -6Â° and 6Â° altitude
  const inTwilight = sunAlt >= -6 && sunAlt <= 6;
  let sunsetColors = null;
  
  if(inTwilight && sunAlt > -6){
    // Map sun altitude to progress (0 to 1)
    // -6Â° to 6Â° = twilight/sunrise/sunset range
    const sunProgress = (sunAlt + 6) / 12;
    sunsetColors = getSunsetSunriseColors(sunProgress);
  }
  
  if(sunsetColors){
    skyGrad.addColorStop(0, `rgb(${sunsetColors.top[0]},${sunsetColors.top[1]},${sunsetColors.top[2]})`);
    skyGrad.addColorStop(0.4, `rgb(${sunsetColors.mid[0]},${sunsetColors.mid[1]},${sunsetColors.mid[2]})`);
    skyGrad.addColorStop(1, `rgb(${sunsetColors.bot[0]},${sunsetColors.bot[1]},${sunsetColors.bot[2]})`);
  }else if(light > 0.3){
    const i = Math.pow(light, 0.6);
    skyGrad.addColorStop(0, `rgb(${70*i},${140*i},${220*i})`);
    skyGrad.addColorStop(1, `rgb(${135*i},${195*i},${235*i})`);
  }else{
    const ni = Math.max(0, light / 0.3);
    skyGrad.addColorStop(0, `rgb(${8+12*ni},${12+18*ni},${28+32*ni})`);
    skyGrad.addColorStop(1, `rgb(${18+12*ni},${22+18*ni},${55+35*ni})`);
  }
  
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, H);
  // Morning fog/mist layer (soft, near-horizon)
  const morningFogActive = (hours >= 5 && hours <= 10);
  if(morningFogActive){
    const fogStrength = Math.min(0.6, 0.12 + (weatherData.cloudCover / 100) * 0.5 + (0.25 - light * 0.2));
    if(fogStrength > 0.02){
      const fogGrad = ctx.createLinearGradient(0, H * 0.35, 0, H);
      fogGrad.addColorStop(0, `rgba(255,255,255,${Math.min(0.45,fogStrength)})`);
      fogGrad.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = fogGrad;
      ctx.fillRect(0, H * 0.35, W, H * 0.5);
      ctx.restore();
    }
  }
  
  const starVis = Math.max(0, 1 - light * 5) * (1 - weatherData.cloudCover / 100 * 0.8);
  for(let s of stars){
    if(starVis > 0.1){
      s.alpha += s.speed;
      const tw = s.bright ? 1 : Math.sin(s.alpha) * 0.3 + 0.7;
      const brightness = s.bright ? 1.2 : 1;
      ctx.fillStyle = `rgba(${255*brightness},${255*brightness},${255*brightness},${starVis*tw})`;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  // Aurora (high-latitude nights)
  if(Math.abs(LAT) >= 50 && sunAlt < -6){
    const auroraCount = 3 + Math.floor((Math.abs(LAT) - 50) / 10);
    for(let i = 0; i < auroraCount; i++){
      const baseY = H * 0.15 + i * 30 + Math.sin(animTime * 0.02 + i) * 18;
      const amp = 40 + i * 18;
      ctx.save();
      const grad = ctx.createLinearGradient(0, baseY - amp, 0, baseY + amp * 1.5);
      grad.addColorStop(0, 'rgba(20,140,110,0)');
      grad.addColorStop(0.3, 'rgba(80,220,160,0.18)');
      grad.addColorStop(0.6, 'rgba(60,190,140,0.09)');
      grad.addColorStop(1, 'rgba(20,140,110,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.moveTo(0, baseY);
      for(let x = 0; x <= W; x += 12){
        const y = baseY + Math.sin((x * 0.01) + animTime * 0.02 + i) * (amp * Math.sin(animTime * 0.006 + i * 0.5));
        ctx.lineTo(x, y);
      }
      ctx.lineTo(W, baseY + amp * 2);
      ctx.lineTo(0, baseY + amp * 2);
      ctx.closePath();
      ctx.globalCompositeOperation = 'lighter';
      ctx.globalAlpha = 0.65;
      ctx.fill();
      ctx.restore();
    }
  }
  
  const moonPos = altAzToScreen(moonAlt, moonAz);
  if(moonPos.visible && sunAlt < -6){
    const moonBrightness = moonPhase > 0.4 && moonPhase < 0.6 ? 0.6 : 0.4;
    const auraSize = 80 + Math.sin(animTime * 0.05) * 10;
    const auraGrad = ctx.createRadialGradient(moonPos.x, moonPos.y, 45, moonPos.x, moonPos.y, auraSize);
    auraGrad.addColorStop(0, 'rgba(232,232,224,0)');
    auraGrad.addColorStop(0.5, `rgba(200,210,220,${moonBrightness*0.15})`);
    auraGrad.addColorStop(1, 'rgba(180,190,210,0)');
    ctx.fillStyle = auraGrad;
    ctx.beginPath();
    ctx.arc(moonPos.x, moonPos.y, auraSize, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#e8e8e0';
    ctx.beginPath();
    ctx.arc(moonPos.x, moonPos.y, 45, 0, Math.PI * 2);
    ctx.fill();
    
    if(moonPhase < 0.45 || moonPhase > 0.55){
      ctx.fillStyle = `rgba(20,25,50,${0.6+darken*0.2})`;
      ctx.beginPath();
      ctx.arc(moonPos.x + (moonPhase - 0.5) * 90, moonPos.y, 45, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Draw craters with realistic depth and shadows
    for(let crater of moonCraters){
      const cx = moonPos.x + crater.x;
      const cy = moonPos.y + crater.y;
      const phaseOffset = (moonPhase - 0.5) * 90;
      const distFromEdge = Math.abs(cx - (moonPos.x + phaseOffset));
      
      if(distFromEdge < 45){
        ctx.save();
        // Clip to moon circle
        ctx.beginPath();
        ctx.arc(moonPos.x, moonPos.y, 45, 0, Math.PI * 2);
        ctx.clip();
        
        if(crater.mare){
          // Mare (dark sea) regions - darker basaltic plains
          const mareGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, crater.r);
          mareGrad.addColorStop(0, 'rgba(100,100,95,0.5)');
          mareGrad.addColorStop(1, 'rgba(120,120,110,0.3)');
          ctx.fillStyle = mareGrad;
          ctx.beginPath();
          ctx.arc(cx, cy, crater.r, 0, Math.PI * 2);
          ctx.fill();
        }else{
          // Regular impact craters with depth
          // Shadow side based on phase
          const shadowAngle = (moonPhase - 0.5) * Math.PI;
          const shadowX = Math.cos(shadowAngle) * crater.r * 0.3;
          const shadowY = Math.sin(shadowAngle) * crater.r * 0.2;
          
          // Outer rim highlight
          ctx.strokeStyle = `rgba(255,255,250,${0.15 * crater.depth})`;
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.arc(cx - shadowX * 0.5, cy - shadowY * 0.5, crater.r * 0.95, 0, Math.PI * 2);
          ctx.stroke();
          
          // Inner crater (darker)
          const craterGrad = ctx.createRadialGradient(
            cx + shadowX, cy + shadowY, 0,
            cx + shadowX, cy + shadowY, crater.r * 0.8
          );
          craterGrad.addColorStop(0, `rgba(80,80,75,${0.6 * crater.depth})`);
          craterGrad.addColorStop(0.5, `rgba(140,140,130,${0.4 * crater.depth})`);
          craterGrad.addColorStop(1, `rgba(180,180,170,${0.2 * crater.depth})`);
          ctx.fillStyle = craterGrad;
          ctx.beginPath();
          ctx.arc(cx, cy, crater.r * 0.85, 0, Math.PI * 2);
          ctx.fill();
          
          // Central peak for larger craters
          if(crater.r > 4){
            ctx.fillStyle = `rgba(200,200,190,${0.3 * crater.depth})`;
            ctx.beginPath();
            ctx.arc(cx - shadowX * 0.3, cy - shadowY * 0.3, crater.r * 0.2, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        ctx.restore();
      }
    }
  }
  
  const sunPos = altAzToScreen(sunAlt, sunAz);
  // prefer a vertically-moving sun that rises from behind the background mountains (centered)
  if(sunPos.visible && sunAlt > 0){
    sunPos.x = W * 0.5;
    const sg = ctx.createRadialGradient(sunPos.x, sunPos.y, 20, sunPos.x, sunPos.y, 100);
    sg.addColorStop(0, 'rgba(255,255,220,1)');
    sg.addColorStop(0.3, 'rgba(255,240,150,1)');
    sg.addColorStop(0.6, 'rgba(255,230,100,0.5)');
    sg.addColorStop(1, 'rgba(255,200,50,0)');
    ctx.fillStyle = sg;
    ctx.beginPath();
    ctx.arc(sunPos.x, sunPos.y, 100, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Light source preference: sun when above horizon; otherwise moon when above horizon; fallback stays as set earlier
  if(sunAlt > -0.5 && sunPos.visible){
    lightSourceX = sunPos.x;
    lightSourceY = sunPos.y;
    lightSourceAlt = sunAlt;
  }else if(moonPos.visible && moonAlt > -0.5){
    lightSourceX = moonPos.x;
    lightSourceY = moonPos.y;
    lightSourceAlt = moonAlt;
  }
  
  if(lightning.active && lightning.intensity > 0.3){
    ctx.save();
    ctx.strokeStyle = `rgba(200,220,255,${lightning.intensity})`;
    ctx.lineWidth = 3 + Math.random() * 5;
    ctx.beginPath();
    ctx.moveTo(lightning.x, 0);
    let lx = lightning.x, ly = 0;
    for(let i = 0; i < 8; i++){
      lx += (Math.random() - 0.5) * 60;
      ly += H * 0.12;
      ctx.lineTo(lx, ly);
    }
    ctx.stroke();
    ctx.restore();
  }
  const needsFullCoverage = weatherData.condition === 'Snow' || weatherData.condition === 'Rain' || weatherData.condition === 'Storm' || weatherData.cloudCover > 70;

  if(needsFullCoverage){
    const cloudDrift = animTime * 0.15;
    
    for(let c of clouds){
      c.x += c.speed * 0.3;
      if(c.x > W + 200) c.x = -200;
    }
    
    const patchCount = 20;
    for(let i = 0; i < patchCount; i++){
      const cloudIndex = i % clouds.length;
      const baseCloud = clouds[cloudIndex];
      
      const px = (i / patchCount) * W * 1.2 - W * 0.1 + Math.sin(cloudDrift + i * 0.5) * W * 0.05;
      const py = H * 0.05 + Math.sin(i * 0.5 + cloudDrift * 0.5) * H * 0.08;
      const patchSize = W * 0.15 + (Math.sin(i * 2.5) * 0.5 + 0.5) * W * 0.1;
      
      const darknessVariation = Math.sin(i * 1.3 + cloudDrift * 0.2) * 0.2 + 0.8;
      const brightness = darknessVariation;

      const grad = ctx.createRadialGradient(px, py, 0, px, py, patchSize);
      const softEdge = {
        r: Math.floor((cloudSettings.endColor.r + 40) * brightness),
        g: Math.floor((cloudSettings.endColor.g + 50) * brightness),
        b: Math.floor((cloudSettings.endColor.b + 70) * brightness)
      };

      grad.addColorStop(0, `rgba(${softEdge.r},${softEdge.g},${softEdge.b},${cloudSettings.startColor.a*0.85})`);
      grad.addColorStop(0.3, `rgba(${softEdge.r},${softEdge.g},${softEdge.b},${(cloudSettings.startColor.a+cloudSettings.endColor.a)*0.45})`);
      grad.addColorStop(0.6, `rgba(${softEdge.r},${softEdge.g},${softEdge.b},${cloudSettings.endColor.a*0.8})`);
      grad.addColorStop(1, `rgba(${cloudSettings.endColor.r+10},${cloudSettings.endColor.g+20},${cloudSettings.endColor.b+70},${cloudSettings.endColor.a*0.6})`);
      
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.ellipse(px, py, patchSize, patchSize * 0.6, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    
    const crackCount = 12;
    for(let i = 0; i < crackCount; i++){
      const crackX = (i / crackCount) * W + Math.sin(cloudDrift * 0.2 + i) * W * 0.1;
      const crackY = H * 0.1 + Math.sin(i * 1.5 + cloudDrift * 0.3) * H * 0.1;
      const crackSize = W * 0.15;
      
      const crackGrad = ctx.createRadialGradient(crackX, crackY, 0, crackX, crackY, crackSize);
      const lightAmount = sunAlt > 0 ? 0.15 : 0.08;
      crackGrad.addColorStop(0, `rgba(255,255,255,${lightAmount})`);
      crackGrad.addColorStop(0.4, `rgba(230,240,250,${lightAmount*0.7})`);
      crackGrad.addColorStop(1, 'rgba(200,210,220,0)');
      
      ctx.fillStyle = crackGrad;
      ctx.beginPath();
      ctx.ellipse(crackX, crackY, crackSize, crackSize * 0.6, Math.sin(animTime * 0.05 + i) * 0.5, 0, Math.PI * 2);
      ctx.fill();
    }
    
    if(sunAlt > 0){
      // deterministic soft bright spots across cloud bank (avoid per-frame randomness)
      const brightSpots = 8;
      for(let i = 0; i < brightSpots; i++){
        const t = animTime * 0.08 + i * 1.37;
        const nx = (Math.sin(t * 1.23) * 0.5 + 0.5);
        const ny = (Math.cos(t * 0.77) * 0.5 + 0.5);
        const spotX = nx * W;
        const spotY = H * 0.05 + ny * H * 0.2;
        const spotSize = W * (0.06 + (Math.abs(Math.sin(t * 0.5)) * 0.06));

        const spotGrad = ctx.createRadialGradient(spotX, spotY, 0, spotX, spotY, spotSize);
        spotGrad.addColorStop(0, 'rgba(255,250,220,0.12)');
        spotGrad.addColorStop(0.5, 'rgba(255,245,200,0.05)');
        spotGrad.addColorStop(1, 'rgba(255,240,180,0)');

        ctx.fillStyle = spotGrad;
        ctx.beginPath();
        ctx.arc(spotX, spotY, spotSize, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    if(moonAlt > 0 && sunAlt < -6){
      const moonPos = altAzToScreen(moonAlt, moonAz);
      const rayCount = 6;
      
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.globalAlpha = 0.08;
      
      for(let i = 0; i < rayCount; i++){
        const angle = (i / rayCount) * Math.PI * 2 + animTime * 0.008;
        const rayLength = H * 1.2;
        
        const grad = ctx.createLinearGradient(
          moonPos.x, moonPos.y,
          moonPos.x + Math.cos(angle) * rayLength,
          moonPos.y + Math.sin(angle) * rayLength
        );
        
        grad.addColorStop(0, 'rgba(200,210,230,0.3)');
        grad.addColorStop(0.3, 'rgba(180,190,210,0.1)');
        grad.addColorStop(1, 'rgba(160,170,190,0)');
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(moonPos.x, moonPos.y);
        ctx.arc(moonPos.x, moonPos.y, rayLength, angle - 0.08, angle + 0.08);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
    }
  }else{
    for(let i = 0; i < clouds.length; i++){
      const c = clouds[i];
      if(i < clouds.length / 2){
        c.x += c.speed * 0.3;
        if(c.x > W + 200) c.x = -200;
        
        const bluePurple = Math.sin(c.x * 0.001 + animTime * 0.01) * 0.5 + 0.5;
        const r = Math.floor(170 + bluePurple * 70);
        const g = Math.floor(200 - bluePurple * 70);
        const b = Math.floor(235 + bluePurple * 20);
        const cloudAlpha = c.opacity * 0.4 * Math.max(0.3, light);
        
        ctx.fillStyle = `rgba(${r},${g},${b},${cloudAlpha})`;
        
        for(let puff of c.puffs){
          ctx.beginPath();
          ctx.ellipse(c.x + puff.ox, c.y + Math.abs(puff.oy) * 0.3, puff.size, puff.size * 0.5, 0, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
    
    for(let i = Math.floor(clouds.length / 2); i < clouds.length; i++){
      const c = clouds[i];
      c.x += c.speed;
      if(c.x > W + 200) c.x = -200;
      
      const bluePurple = Math.sin(c.x * 0.002 + animTime * 0.015) * 0.5 + 0.5;
      const r = Math.floor(200 + bluePurple * 50);
      const g = Math.floor(220 - bluePurple * 90);
      const b = Math.floor(250 + bluePurple * 5);
      let cloudAlpha = c.opacity * Math.max(0.5, light);
      
      if(sunAlt < 0){
        cloudAlpha = c.opacity * Math.max(0.3, light * 1.5);
      }
      
      const hours = new Date().getHours() + new Date().getMinutes() / 60;
      const sunProgress = (hours - 6) / 12;
      if(sunProgress > 0 && sunProgress < 0.15 || sunProgress > 0.85 && sunProgress < 1){
        const warmth = sunProgress < 0.15 ? sunProgress / 0.15 : (1 - sunProgress) / 0.15;
        ctx.fillStyle = `rgba(${200+warmth*55},${150+warmth*50},${180-warmth*80},${cloudAlpha})`;
      }else{
        ctx.fillStyle = `rgba(${r},${g},${b},${cloudAlpha})`;
      }
      
      for(let puff of c.puffs){
        ctx.beginPath();
        ctx.ellipse(c.x + puff.ox, c.y + Math.abs(puff.oy) * 0.4, puff.size, puff.size * 0.55, 0, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  // Bats: spawn at dusk/dawn windows and draw updates (only in warm spring/summer)
  try{
    const warmEnough = weatherData.temp >= 50; // Bats only active when 50Â°F or warmer
    const isWarmSeason = season === 'spring' || season === 'summer';
    if(warmEnough && isWarmSeason){
      if(hours >= 18 && hours <= 20){ if(Math.random() < 0.01) window._spawnBat(); }
      if(hours >= 4 && hours <= 6){ if(Math.random() < 0.006) window._spawnBat(); }
    }
    if(window._updateAndDrawBats) window._updateAndDrawBats(ctx);
  }catch(e){/* non-fatal */}
  
  // Deer: check for scheduled events (will draw later after foreground)
  try{
    if(window._checkDeerEvents) window._checkDeerEvents();
  }catch(e){/* non-fatal */}
  
  // Bunny: check for scheduled events (will draw later after foreground)
  try{
    if(window._checkBunnyEvents) window._checkBunnyEvents();
  }catch(e){/* non-fatal */}

    // rake cursor drawing moved to later so it appears above foreground
  // Rainbow: show after rain while sun is at the right angle (opposite the sun)
  try{
    const rainForRainbow = (weatherData.condition === 'Rain' || weatherData.precipitation > 0.04) && weatherData.condition !== 'Storm' && sunAlt > 6 && weatherData.precipitation > 0.01;
    if(rainForRainbow){
      const oppAz = (sunAz + 180) % 360;
      const center = altAzToScreen(20, oppAz);
      if(center){
        const cx = Math.max(50, Math.min(W-50, center.x));
        const cy = H * 0.7;
        const colors = ['#9400D3','#4B0082','#0000FF','#00FF00','#FFFF00','#FF7F00','#FF0000'];
        ctx.save();
        ctx.globalAlpha = 0.8 * Math.min(1, weatherData.precipitation * 6 + (1 - weatherData.cloudCover/100));
        for(let i = 0; i < colors.length; i++){
          ctx.strokeStyle = colors[i];
          ctx.lineWidth = 8 - i;
          ctx.beginPath();
          ctx.arc(cx, cy, 140 + i * 10, Math.PI * 0.22, Math.PI * 0.78);
          ctx.stroke();
        }
        ctx.restore();
      }
    }
  }catch(e){/* non-fatal rainbow math */}
  if(weatherData.condition === 'Rain' || weatherData.condition === 'Storm' || weatherData.precipitation > 0.01){
    const rainIntensity = weatherData.precipitation > 0.15 ? 3 : weatherData.precipitation > 0.05 ? 2 : 1;
    const spawnChance = 0.2 * rainIntensity;
    
    if(Math.random() < spawnChance){
      raindrops.push({
        x: Math.random() * W,
        y: -10,
        speed: 12 + Math.random() * 6 * rainIntensity,
        angle: weatherData.windSpeed * 0.1,
        size: rainIntensity
      });
    }
    
    const rainAlpha = sunAlt < 0 ? Math.min(0.6, 0.25 * rainIntensity + light * 0.35) : Math.min(0.7, 0.35 * rainIntensity);
    
    for(let i = raindrops.length - 1; i >= 0; i--){
      const rd = raindrops[i];
      rd.y += rd.speed;
      rd.x += rd.angle;
      
      ctx.strokeStyle = `rgba(180,200,255,${rainAlpha})`;
      ctx.lineWidth = rd.size;
      ctx.beginPath();
      ctx.moveTo(rd.x, rd.y);
      ctx.lineTo(rd.x - rd.angle * 3, rd.y + 10 * rd.size);
      ctx.stroke();
      
      const waterY = H * 0.78;
      if(rd.y >= waterY && rd.y < waterY + 30){
        splashes.push({
          x: rd.x,
          y: waterY + Math.sin(rd.x * 0.01) * 5,
          radius: 2,
          alpha: 0.6,
          life: 15,
          speed: 1.5
        });
        if(soundEnabled && Math.random() < 0.05) createSplashSound();
        raindrops.splice(i, 1);
      }else if(rd.y > H){
        raindrops.splice(i, 1);
      }
    }
  }
  
  if(weatherData.condition === 'Snow'){
    if(Math.random() < 0.3) snowflakes.push({x: Math.random() * W, y: -10, vx: (Math.random() - 0.5) * 1.5, vy: 1 + Math.random() * 1.5, size: 2 + Math.random() * 4, layer: Math.random()});
  }
  
  for(let layer = 0; layer <= 2; layer++){
    // Normalize daylight so clear daytime returns full color
    const daylight = Math.max(0, Math.min(1, (light - 0.25) / 0.65));
    const layerDark = 1 - daylight;
    
    const patternSize = layer === 2 ? 14 : layer === 1 ? 10 : 7;
    const patternCanvas = document.createElement('canvas');
    patternCanvas.width = patternSize;
    patternCanvas.height = patternSize;
    const pctx = patternCanvas.getContext('2d');
    
    // Use darker base colors for background terrain (darker than foreground)
    const baseBrown = {
      r: 85 - layer * 12,
      g: 70 - layer * 10,
      b: 55 - layer * 8
    };
    
    const darkGreen = {
      r: 45 - layer * 8,
      g: 70 - layer * 10,
      b: 40 - layer * 8
    };
    
    for(let py = 0; py < patternSize; py++){
      for(let px = 0; px < patternSize; px++){
        const noise = Math.random();
        const isGreenPatch = noise > 0.62;
        
        if(isGreenPatch){
          const variation = noise * 0.2 - 0.1;
          pctx.fillStyle = `rgb(${Math.floor(darkGreen.r*(1+variation))},${Math.floor(darkGreen.g*(1+variation))},${Math.floor(darkGreen.b*(1+variation))})`;
        }else{
          const variation = noise * 0.3 - 0.15;
          pctx.fillStyle = `rgb(${Math.floor(baseBrown.r*(1+variation))},${Math.floor(baseBrown.g*(1+variation))},${Math.floor(baseBrown.b*(1+variation))})`;
        }
        pctx.fillRect(px, py, 1, 1);
      }
    }
    
    const pattern = ctx.createPattern(patternCanvas, 'repeat');
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = pattern;
    ctx.globalAlpha = 1;
    ctx.beginPath();
    ctx.moveTo(-W * 0.5, H);
    for(let t of bgTerrain[layer]){
      if(t.x >= -W * 0.5 && t.x <= W * 1.5) ctx.lineTo(t.x, t.y);
    }
    ctx.lineTo(W * 1.5, H);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    
    if(layer < 2){
      ctx.globalAlpha = 0.25;
      ctx.strokeStyle = `rgba(0,0,0,${0.3+layer*0.15})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      let firstPoint = true;
      for(let t of bgTerrain[layer]){
        if(t.x >= -W * 0.5 && t.x <= W * 1.5){
          if(firstPoint){
            ctx.moveTo(t.x, t.y);
            firstPoint = false;
          }else{
            ctx.lineTo(t.x, t.y);
          }
        }
      }
      ctx.stroke();
    }
  }
  
  ctx.globalAlpha = 1;

  // draw deterministic background details per-layer (opaque)
  for(let layer = 0; layer <= 2; layer++){
    // Normalize daylight so clear daytime returns full color
    const daylight = Math.max(0, Math.min(1, (light - 0.25) / 0.65));
    const layerDark = 1 - daylight;
    ctx.globalCompositeOperation = 'source-over';
    for(let det of bgDetails[layer]){
      const xPos = det.x;
      const yPos = det.y;
      const s = det.seed;
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = 1; // ensure opaque details

      if(det.type === 'tree'){
        const isWinter = season === 'winter';
        const isEvergreen = (s > 0.7);
        const treeH = 12 + (s * 30);
        const treeW = treeH * 0.38;
        // Assign distinct colors per tree based on seed and season
        let treeColorStyle;
        if(isWinter){
          if(isEvergreen){
            // Evergreen trees stay dark green in winter, darkest on distant layer
            if(layer === 0){
              treeColorStyle = `rgb(25,45,30)`; // Darkest, touching sky
            }else if(layer === 1){
              treeColorStyle = `rgb(35,60,40)`;
            }else{
              treeColorStyle = `rgb(45,75,50)`;
            }
          }else{
            // Deciduous trees go gray/brown in winter - darker on distant layer
            const shade = Math.floor(s * 25);
            if(layer === 0){
              treeColorStyle = `rgb(${70+shade},${70+shade},${65+shade})`; // Darker gray
            }else if(layer === 1){
              treeColorStyle = `rgb(${90+shade},${90+shade},${85+shade})`;
            }else{
              treeColorStyle = `rgb(${110+shade},${110+shade},${105+shade})`;
            }
          }
        }else{
          // Spring/summer/fall colors - darker greens on distant layer
          const greenVariation = Math.floor(s * 30);
          if(layer === 0){
            treeColorStyle = `rgb(${50+greenVariation},${80+greenVariation},${55+greenVariation})`; // Darkest
          }else if(layer === 1){
            treeColorStyle = `rgb(${70+greenVariation},${110+greenVariation},${75+greenVariation})`;
          }else{
            treeColorStyle = `rgb(${85+greenVariation},${130+greenVariation},${90+greenVariation})`;
          }
        }
        ctx.fillStyle = treeColorStyle;
        ctx.beginPath();
        ctx.moveTo(xPos, yPos - treeH);
        ctx.lineTo(xPos - treeW, yPos);
        ctx.lineTo(xPos + treeW, yPos);
        ctx.closePath();
        ctx.fill();
        for(let j = 0; j < 3; j++){
          const layH = treeH * (0.28 + j * 0.24);
          ctx.beginPath();
          ctx.moveTo(xPos, yPos - layH - 4);
          ctx.lineTo(xPos - treeW * 0.78, yPos - layH);
          ctx.lineTo(xPos + treeW * 0.78, yPos - layH);
          ctx.closePath();
          ctx.fill();
        }
        // Add darkened snow on tree top
        if(snowCover > 0.02){
          const snowDarken = 1 - (darken * 0.6);
          ctx.fillStyle = `rgba(${Math.floor(255*snowDarken)},${Math.floor(255*snowDarken)},${Math.floor(255*snowDarken)},${(0.65 + (2-layer)*0.12)*(1-darken*0.4)})`;
          ctx.beginPath();
          ctx.moveTo(xPos, yPos - treeH - snowCover*3);
          ctx.lineTo(xPos - treeW*0.6, yPos - snowCover*2);
          ctx.lineTo(xPos + treeW*0.6, yPos - snowCover*2);
          ctx.closePath();
          ctx.fill();
        }
      }else if(det.type === 'rock'){
        const rockW = 8 + s * 18;
        const rockH = 6 + s * 10;
        // Darker gray for distant rocks, lighter for closer ones
        let rockColor;
        if(layer === 0){
          rockColor = 'rgb(60,60,65)'; // Darkest, touching sky
        }else if(layer === 1){
          rockColor = 'rgb(80,80,85)';
        }else{
          rockColor = 'rgb(100,100,105)';
        }
        ctx.fillStyle = rockColor;
        ctx.beginPath();
        ctx.ellipse(xPos, yPos - rockH * 0.5, rockW, rockH, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = `rgba(255,255,255,0.15)`;
        ctx.beginPath();
        ctx.ellipse(xPos - rockW * 0.28, yPos - rockH * 0.6, rockW * 0.38, rockH * 0.38, 0, 0, Math.PI * 2);
        ctx.fill();
      }else{
        const logL = 10 + s * 20;
        // Use base log color - brown wood that's visible in all lighting
        let logColor;
        if(layer === 0){
          logColor = 'rgb(100,75,55)';
        }else if(layer === 1){
          logColor = 'rgb(85,65,50)';
        }else{
          logColor = 'rgb(95,70,55)';
        }
        ctx.strokeStyle = logColor;
        ctx.lineWidth = 3 + s * 3;
        ctx.beginPath();
        ctx.moveTo(xPos - logL, yPos - 2);
        ctx.lineTo(xPos + logL, yPos + 2);
        ctx.stroke();
        ctx.strokeStyle = `rgba(150,130,100,0.4)`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(xPos - logL*0.4, yPos, 2, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.restore();
    }
    // draw light snow highlights on mountain tops only when there's snow accumulation
    if(snowCover > 0.02){
      for(let layer = 0; layer <= 2; layer++){
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        // Front layers have more opaque snow; back layers fade more so they stay behind
        // Apply darkening to snow on background terrain
        const snowDarken = 1 - (darken * 0.6);
        const snowAlpha = (0.55 + (2 - layer) * 0.12) * (1 - darken * 0.5);
        ctx.globalAlpha = Math.max(0.05, snowAlpha);
        ctx.fillStyle = `rgba(${Math.floor(255*snowDarken)},${Math.floor(255*snowDarken)},${Math.floor(255*snowDarken)},0.9)`;
        ctx.beginPath();
        ctx.moveTo(-W * 0.5, H);
        for(let t of bgTerrain[layer]){
          if(t.x >= -W * 0.5 && t.x <= W * 1.5) ctx.lineTo(t.x, t.y - snowCover * 8);
        }
        ctx.lineTo(W * 1.5, H);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }
    ctx.globalAlpha = 1;
  }
  let foregroundLight = light;
  // if heavy cloud/snow cover, dim foreground more
  if(needsFullCoverage){
    foregroundLight = light * 0.4 + 0.1;
  }
  // at night, ensure foreground is very dark, nearly matching the background sky
  if(sunAlt < -6){
    foregroundLight = Math.max(0.005, light * 0.03); // Much darker at night
  }
  const foregroundDarken = 1 - foregroundLight;
  
  if(sunAlt > 0 && cloudShadows.length > 0){
    for(let cs of cloudShadows){
      const cloud = clouds[cs.cloudIndex];
      if(!cloud) continue;
      
      const sunAltClamped = Math.max(-10, Math.min(85, lightSourceAlt));
      const sunZenith = 90 - sunAltClamped;
      const shadowOffsetX = lightSourceAlt > 0 ? Math.min(200, Math.tan(sunZenith * Math.PI / 180) * 200) : 0;
      const shadowX = cloud.x + shadowOffsetX;
      
      let shadowWidth = 0;
      for(let puff of cloud.puffs){
        shadowWidth = Math.max(shadowWidth, Math.abs(puff.ox) + puff.size);
      }
      shadowWidth *= 2;
      
      const shadowGrad = ctx.createRadialGradient(shadowX, H * 0.65, 0, shadowX, H * 0.65, shadowWidth);
      shadowGrad.addColorStop(0, `rgba(0,0,0,${cs.opacity*0.3*light})`);
      shadowGrad.addColorStop(0.6, `rgba(0,0,0,${cs.opacity*0.15*light})`);
      shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
      
      ctx.fillStyle = shadowGrad;
      ctx.beginPath();
      ctx.moveTo(shadowX - shadowWidth, H);
      for(let x = shadowX - shadowWidth; x <= shadowX + shadowWidth; x += 5){
        const terrainY = getTerrainY(x);
        if(terrainY) ctx.lineTo(x, terrainY);
      }
      ctx.lineTo(shadowX + shadowWidth, H);
      ctx.closePath();
      ctx.fill();
    }
  }
  
  // Terrain - apply darkening
  const terrainDarkenFactor = foregroundDarken > 0.95 ? 0.95 : foregroundDarken * 0.8;
  const baseGreen = Math.floor(150 * Math.pow(1 - terrainDarkenFactor, 1.2));
  const baseR = Math.floor(50 * Math.pow(1 - terrainDarkenFactor, 1.2));
  const baseB = Math.floor(30 * Math.pow(1 - terrainDarkenFactor, 1.3));
  ctx.fillStyle = `rgb(${Math.max(0, baseR)},${Math.max(0, baseGreen)},${Math.max(0, baseB)})`;
  ctx.beginPath();
  ctx.moveTo(0, H);
  for(let t of terrain) ctx.lineTo(t.x, t.y);
  ctx.lineTo(W, H);
  ctx.closePath();
  ctx.fill();
  
  if(snowCover > 0.02){
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    // Snow layer on terrain - dimmer at night
    const snowDimming = sunAlt < -6 ? 0.15 : 0.85;
    ctx.fillStyle = `rgba(255,255,255,${snowCover*snowDimming*(1-darken*0.3)})`;
    ctx.beginPath();
    ctx.moveTo(0, H);
    for(let t of terrain) ctx.lineTo(t.x, t.y - snowCover * 15);
    ctx.lineTo(W, H);
    ctx.closePath();
    ctx.fill();
    
    // Add subtle snow dust overlay across entire scene when significant snow cover
    if(snowCover > 0.1){
      const dustDimming = sunAlt < -6 ? 0.03 : 0.2;
      ctx.fillStyle = `rgba(255,255,255,${Math.min(0.25, snowCover * dustDimming)})`;
      ctx.fillRect(0, 0, W, H);
    }
    ctx.restore();
  }
  
  const grassGreen = Math.floor(140 * (1 - foregroundDarken * 0.5));
  ctx.strokeStyle = `rgba(${40*(1-foregroundDarken*0.5)},${grassGreen},${35*(1-foregroundDarken*0.6)},0.7)`;
  ctx.lineWidth = 1.5;
  
  for(let gp of grassPatches){
    for(let blade of gp.blades){
      blade.sway += blade.speed;
      const windBend = weatherData.windSpeed > 10 ? weatherData.windSpeed * 0.3 : 1;
      const bend = Math.sin(blade.sway + weatherData.windSpeed * 0.05) * 3 * Math.min(1, windBend / 10);
      ctx.beginPath();
      ctx.moveTo(gp.x + blade.ox, gp.y);
      ctx.lineTo(gp.x + blade.ox + bend, gp.y - blade.height);
      ctx.stroke();
    }
  }
  
  for(let i = birds.length - 1; i >= 0; i--){
    const b = birds[i];
    // Remove and skip birds after dark
    if(sunAlt < 0){
      birds.splice(i, 1);
      continue;
    }
    b.update();
    b.drawShadow(light);
    b.draw(light, darken, sunPos);
    if(b.x < -100 || b.x > W + 100 || (b.state === 'landed' && b.landTimer <= 0 && !b.nestTree) || (b.state === 'nesting' && b.nestTimer <= 0)){
      birds.splice(i, 1);
    }
  }
  
  // Clear all canvas layers
  ctxLayer1.clearRect(0, 0, W, H);
  ctxLayer2.clearRect(0, 0, W, H);
  ctxLayer3.clearRect(0, 0, W, H);
  ctxLayer4.clearRect(0, 0, W, H);
  
  // Helper to draw items on specific layer by temporarily changing global ctx
  const originalCtx = ctx;
  window.ctx = ctx;
  
  // Creature positions (both walk on flat terrain at H * 0.65)
  const animalWalkY = H * 0.65;
  
  // BACKGROUND ONLY MODE: Remove any existing foreground items on load (run once)
  if(!window._backgroundOnlyCleanupDone){
    for(let i = items.length - 1; i >= 0; i--){
      const itemY = items[i].screenY !== undefined ? items[i].screenY : items[i].y;
      if(itemY >= animalWalkY + 60){
        items.splice(i, 1);
      }
    }
    window._backgroundOnlyCleanupDone = true;
  }
  
  // Layer items based on their screen Y position
  // ALL ITEMS RESTRICTED TO BACKGROUND: z:1, z:3 only
  // Bunny = z:8
  // Deer = z:10  
  
  for(let item of items){
    item.grow();
    item.updateScreenPosition();
    
    const itemY = item.screenY;
    let targetCtx;
    let layerName = 'unknown';
    
    // Distribute items: top items use low z-index, bottom items use high z-index
    if(itemY < animalWalkY - 50){
      // Top of screen - base canvas z-index 1 (behind everything)
      targetCtx = originalCtx;
      layerName = 'base (z:1, background)';
    } else if(itemY < animalWalkY + 10){
      // Upper middle - layer 1, z-index 3 (behind animals)
      targetCtx = ctxLayer1;
      layerName = 'layer1 (z:3, behind animals)';
    } else {
      // BACKGROUND ONLY MODE: Reroute all foreground items to background
      targetCtx = ctxLayer1;
      layerName = 'layer1 (z:3, behind animals - foreground blocked)';
    }
    
    // Draw shadow and item on same layer
    window.ctx = targetCtx;
    item.drawShadow(foregroundLight);
    item.draw(foregroundLight, foregroundDarken, snowCover);
  }
  
  // Restore original context
  window.ctx = originalCtx;
  
  // Set creature z-indices to place them BETWEEN top and bottom items:
  // Top items (z:1, 3) â†’ Bunny (z:8) â†’ Deer (z:10) â†’ Bottom items (z:12, 14)
  if(bunny){
    if(typeof bunnyHopImg !== 'undefined' && bunnyHopImg) bunnyHopImg.style.zIndex = '8';
    if(typeof bunnyScratchImg !== 'undefined' && bunnyScratchImg) bunnyScratchImg.style.zIndex = '8';
    if(typeof babyBunnyHopImg1 !== 'undefined' && babyBunnyHopImg1) babyBunnyHopImg1.style.zIndex = '8';
    if(typeof babyBunnyScratchImg1 !== 'undefined' && babyBunnyScratchImg1) babyBunnyScratchImg1.style.zIndex = '8';
    if(typeof babyBunnyHopImg2 !== 'undefined' && babyBunnyHopImg2) babyBunnyHopImg2.style.zIndex = '8';
    if(typeof babyBunnyScratchImg2 !== 'undefined' && babyBunnyScratchImg2) babyBunnyScratchImg2.style.zIndex = '8';
  }
  
  if(deer){
    if(typeof deerWalkImg !== 'undefined' && deerWalkImg) deerWalkImg.style.zIndex = '10';
    if(typeof deerIdleImg !== 'undefined' && deerIdleImg) deerIdleImg.style.zIndex = '10';
  }
  
  // Draw creatures (HTML positioned elements updated by their respective functions)
  try{
    if(window._updateAndDrawDeer) window._updateAndDrawDeer(ctx);
  }catch(e){/* non-fatal */}
  
  try{
    if(window._updateAndDrawBunny) window._updateAndDrawBunny(ctx);
  }catch(e){/* non-fatal */}
  
  // Falling leaves: spawn in autumn, update positions, and accumulate on terrain
  if(season === 'fall'){
    // spawn probability influenced by wind and cloud cover; prefer spawning from tree positions
    const spawnProb = 0.002 + Math.min(0.02, (weatherData.windSpeed||0) * 0.0015) + (weatherData.cloudCover/1500);
    if(Math.random() < spawnProb){
      if(fallingLeaves.length < 500){
        // spawn only from foreground non-pine trees
        const treeCandidates = items.filter(it=> it.type === 'plant' && it.leafCount && !it.isPine);
        if(treeCandidates.length){
          const t = treeCandidates[Math.floor(Math.random()*treeCandidates.length)];
          const sx = t.screenX + (Math.random()-0.5) * Math.max(8, t.trunkW * 6);
          const colorPalette = ['#c94e25','#e07a2f','#f2c94c','#a83e2a','#8b4513','#b35a2b'];
          const leaf = {
            x: sx,
            y: -6 - Math.random() * 30,
            vx: (weatherData.windSpeed||0) * 0.12 + (Math.random()-0.5) * 0.6,
            vy: 0.4 + Math.random() * 1.0,
            angle: Math.random() * Math.PI * 2,
            spin: (Math.random()-0.5) * 0.09,
            size: 4 + Math.random() * 7,
            color: colorPalette[Math.floor(Math.random()*colorPalette.length)],
            alpha: 0.95,
            originTreeId: t.baseX // tag origin for possible debugging
          };
          fallingLeaves.push(leaf);
        }
      }
    }
  }

  // Update falling leaves
  for(let i = fallingLeaves.length - 1; i >= 0; i--){
    const lf = fallingLeaves[i];
    // simple physics
    lf.vy += 0.02; // gravity
    // wind nudging
    lf.vx += ((weatherData.windSpeed||0) - (lf.vx*5)) * 0.002;
    // occasional updraft/wind lift when wind is strong
    if((weatherData.windSpeed||0) > 6 && Math.random() < Math.min(0.02, (weatherData.windSpeed-6)/50)){
      lf.vy -= 0.6 + Math.random()*0.6; // lift
    }
    lf.x += lf.vx;
    lf.y += lf.vy;
    lf.angle += lf.spin * (0.6 + Math.abs(lf.vx)*0.12); // spin influenced by horizontal speed
    // off-screen cleanup
    if(lf.x < -50 || lf.x > W + 50 || lf.y > H + 50){ fallingLeaves.splice(i,1); continue; }
    // landed check against terrain
    const terrainY = getTerrainY(lf.x);
    if(lf.y >= terrainY - 2){
      // Only accumulate leaves under foreground (user-placed) non-pine trees
      const nearbyTree = items.find(it => it.type === 'plant' && !it.isPine && Math.abs(it.screenX - lf.x) < 40);
      if(!nearbyTree){
        // no suitable tree below: discard leaf
        fallingLeaves.splice(i,1);
        continue;
      }
      // accumulate near the tree's base so piles appear under trees only
      const px = nearbyTree.screenX + (Math.random()-0.5) * Math.max(8, nearbyTree.trunkW * 4);
      const radius = 12;
      let placed = false;
      for(let pa of fallenLeafAccum){
        if(Math.abs(pa.x - px) < radius){
          pa.count = (pa.count || 1) + 1;
          pa.size = Math.max(pa.size, lf.size);
          placed = true; break;
        }
      }
      if(!placed){
        fallenLeafAccum.push({x: px, y: terrainY - 2, color: lf.color, size: lf.size, count: 1});
      }
      fallingLeaves.splice(i,1);
    }
  }

  // Draw falling leaves (above ground)
  for(let lf of fallingLeaves){
    ctx.save();
    ctx.translate(lf.x, lf.y);
    ctx.rotate(lf.angle);
    ctx.fillStyle = lf.color;
    ctx.globalAlpha = lf.alpha * (1 - Math.min(1, (lf.y / H)));
    // leaf tilt: draw as slightly rotated ellipse with variable tilt
    const tilt = Math.sin(lf.angle*1.5) * 0.8;
    ctx.beginPath();
    ctx.ellipse(0, 0, lf.size, lf.size * (0.5 + 0.3 * tilt), tilt, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  // Draw accumulated leaf piles (simple layered dots)
  for(let pa of fallenLeafAccum){
    const pileHeight = Math.min(8, pa.count);
    // subsurface shading (darker base)
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(pa.x, pa.y + 2, pa.size * 1.6, pa.size * 0.6, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    for(let k = 0; k < pileHeight; k++){
      ctx.save();
      ctx.translate(pa.x + (Math.sin(k*3.1 + pa.x*0.01) * 2), pa.y - k * 1.2);
      ctx.rotate(((pa.x+k)%7-3)/12 + Math.sin(pa.x*0.001 + k));
      // slightly modulate color per layer
      ctx.fillStyle = shadeColor(pa.color, -6 * k);
      ctx.globalAlpha = 0.95 - (k * 0.08);
      ctx.beginPath();
      ctx.ellipse(0, 0, pa.size * (1 - k*0.06), pa.size * 0.5 * (1 - k*0.05), 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  // Fallen piles: merge nearby piles and cap total piles for performance; slowly decay piles when raining or outside fall
  if(fallenLeafAccum.length > 220){
    // merge nearest pairs until under cap
    fallenLeafAccum.sort((a,b)=>a.x-b.x);
    for(let i = fallenLeafAccum.length - 1; i > 0 && fallenLeafAccum.length > 180; i--){
      const a = fallenLeafAccum[i];
      const b = fallenLeafAccum[i-1];
      if(Math.abs(a.x - b.x) < 18){
        b.count = (b.count||1) + (a.count||1);
        b.size = Math.max(b.size || 4, a.size || 4);
        fallenLeafAccum.splice(i,1);
      }
    }
  }
  for(let i = fallenLeafAccum.length - 1; i >= 0; i--){
    const pa = fallenLeafAccum[i];
    // rain washes leaves away faster
    const precip = (weatherData.precipitation || weatherData.precipitation_probability || 0);
    const decay = (season === 'fall' ? 0.0 : 0.005) + (precip > 20 ? 0.02 : 0);
    if(Math.random() < decay){
      pa.count = Math.max(0, (pa.count||1) - 1);
      if(pa.count <= 0) fallenLeafAccum.splice(i,1);
    }
  }

  // Water - gradient for depth with darkening
  const waterDarken = 1 - foregroundDarken * 0.6;
  const waterY = H * 0.78;
  
  const waterGrad = ctx.createLinearGradient(0, waterY, 0, H);
  waterGrad.addColorStop(0, `rgba(${Math.floor(65*waterDarken)},${Math.floor(150*waterDarken)},${Math.floor(210*waterDarken)},0.90)`);      // Lighter blue-cyan at surface
  waterGrad.addColorStop(0.25, `rgba(${Math.floor(45*waterDarken)},${Math.floor(130*waterDarken)},${Math.floor(190*waterDarken)},0.92)`);   // Mid-light blue
  waterGrad.addColorStop(0.5, `rgba(${Math.floor(30*waterDarken)},${Math.floor(100*waterDarken)},${Math.floor(160*waterDarken)},0.95)`);    // Mid-depth blue
  waterGrad.addColorStop(0.75, `rgba(${Math.floor(20*waterDarken)},${Math.floor(70*waterDarken)},${Math.floor(130*waterDarken)},0.97)`);    // Deep blue
  waterGrad.addColorStop(1, `rgba(${Math.floor(10*waterDarken)},${Math.floor(45*waterDarken)},${Math.floor(90*waterDarken)},0.98)`);        // Very deep blue at bottom
  ctx.fillStyle = waterGrad;
  ctx.beginPath();
  ctx.moveTo(0, waterY);
  for(let r of river){
    r.flow += 0.04;
    const w = Math.sin(r.flow) * 4;
    ctx.lineTo(r.x, waterY + w);
  }
  ctx.lineTo(W, H);
  ctx.lineTo(0, H);
  ctx.closePath();
  ctx.fill();
  
  ctx.strokeStyle = `rgba(${Math.floor(110*waterDarken)},${Math.floor(230*waterDarken)},${Math.floor(255*waterDarken)},0.7)`;
  ctx.lineWidth = 3;
  ctx.beginPath();
  for(let i = 0; i < river.length; i++){
    const w = Math.sin(river[i].flow) * 4;
    if(i === 0) ctx.moveTo(river[i].x, waterY + w);
    else ctx.lineTo(river[i].x, waterY + w);
  }
  ctx.stroke();
  
  if(sunAlt > 0 && light > 0.4){
    for(let i = 0; i < river.length; i += 20){
      if(Math.sin(river[i].flow + i * 0.1) > 0.7){
        ctx.fillStyle = `rgba(255,255,200,${0.3*light})`;
        ctx.beginPath();
        ctx.arc(river[i].x, waterY + Math.sin(river[i].flow) * 4, 4, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }
  
  for(let i = splashes.length - 1; i >= 0; i--){
    const sp = splashes[i];
    sp.life--;
    sp.radius += sp.speed;
    sp.alpha -= 0.03;
    
    if(sp.life <= 0 || sp.alpha <= 0){
      splashes.splice(i, 1);
    }else{
      ctx.strokeStyle = `rgba(180,210,255,${sp.alpha})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(sp.x, sp.y, sp.radius, 0, Math.PI * 2);
      ctx.stroke();
    }
  }
  
  if(weatherData.condition === 'Snow'){
    const snowAlphaBase = sunAlt < 0 ? Math.min(0.8, 0.5 + light * 0.4) : 0.9;
    for(let i = snowflakes.length - 1; i >= 0; i--){
      const sf = snowflakes[i];
      sf.x += sf.vx + Math.sin(animTime * 0.1 + i) * 0.5 + weatherData.windSpeed * 0.05;
      sf.y += sf.vy;

      // Draw all layers: farther flakes smaller/fainter, nearer flakes larger/brighter
      const sizeScaled = sf.size * (0.6 + sf.layer * 0.8);
      const alphaScaled = snowAlphaBase * (0.4 + sf.layer * 0.6);
      ctx.fillStyle = `rgba(255,255,255,${alphaScaled})`;
      ctx.beginPath();
      ctx.arc(sf.x, sf.y, sizeScaled, 0, Math.PI * 2);
      ctx.fill();

      // Remove when off screen or past ground
      const terrainY = getTerrainY(sf.x);
      if(sf.y > H || (terrainY && sf.y > terrainY)) snowflakes.splice(i, 1);
    }
  }
  
  if(light < 0.1){
    for(let cr of creatures){
      cr.blink += cr.blinkRate;
      const blinkOpen = Math.sin(cr.blink) > 0.88 ? 0 : 1;
      if(blinkOpen){
        const eyeGlow = ctx.createRadialGradient(cr.x, cr.y, 0, cr.x, cr.y, 10);
        eyeGlow.addColorStop(0, cr.color);
        eyeGlow.addColorStop(0.4, `${cr.color}aa`);
        eyeGlow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = eyeGlow;
        ctx.beginPath();
        ctx.arc(cr.x - 5, cr.y, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(cr.x + 5, cr.y, 4, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }
 
  for(let f of fish){
    // jumping / feeding behavior only during allowed windows
    const hours = new Date().getHours();
    const allowedJump = (hours >= 5 && hours < 9) || (hours >= 17 && hours < 20);
    
    // Catfish special behavior: stay deep until 9pm-11pm feeding time
    const isCatfish = f.type === 'catfish';
    const catfishFeedingTime = hours >= 21 && hours < 23; // 9pm to 11pm
    
    if(isCatfish){
      if(catfishFeedingTime){
        // Catfish feeding time - come to surface
        f.depth = Math.max(0, f.depth - 0.02); // Gradually rise to surface
      }else{
        // Stay at bottom
        f.depth = Math.min(1, f.depth + 0.02); // Gradually sink to bottom
      }
    }

    // start jump with small probability when allowed (catfish only jump during feeding time)
    if(f.jumpState === 'idle' && allowedJump && (!isCatfish || catfishFeedingTime)){
      if(f.isSmall && Math.random() < 0.003){
        f.jumpState = 'surface';
        f.jumpTimer = 0;
        f.jumpDuration = 30 + Math.floor(Math.random() * 20);
      }else if(!f.isSmall && Math.random() < 0.0015){
        f.jumpState = 'arch';
        f.jumpTimer = 0;
        f.jumpDuration = 60 + Math.floor(Math.random() * 60);
        f.jumpStartX = f.x;
        f.jumpStartY = f.y;
        f.jumpPeakX = f.x + f.direction * (80 + Math.random() * 140);
        // reduce jump height: make arcs about half as tall as before
        f.jumpPeakY = waterY - (30 + Math.random() * 40);
        createFishJumpExitSound(); // Play exit sound
      }
    }

    // update jump states
    if(f.jumpState === 'surface'){
      const t = f.jumpTimer / f.jumpDuration;
      const progress = t < 0.5 ? (t / 0.5) : (1 - (t - 0.5) / 0.5);
      // quick upward burst (reduced amplitude)
      f.wiggle += 0.12;
      const baseY = waterY + 15 + Math.sin(f.wiggle) * 5 + f.depth * 20;
      f.y = baseY - progress * 15;
      f.jumpTimer++;
      if(f.jumpTimer > f.jumpDuration){
        f.jumpState = 'idle';
        f.y = waterY + 10 + Math.random() * 30;
        splashes.push({x: f.x, y: waterY + Math.sin(f.x * 0.01) * 5, radius: 3 + Math.random()*3, alpha:0.6, life:16, speed:1.8});
        createSplashSound(); // Play splash sound when fish surfaces
        // Only larger fish (not minnows) make eating sounds
        if(f.type !== 'minnow' && Math.random() < 0.3) createFishEatingSound();
      }
    }else if(f.jumpState === 'arch'){
      const t = f.jumpTimer / f.jumpDuration;
      if(t <= 1){
        // parabolic arc: interpolate x, compute parabola for y
        f.x = f.jumpStartX + (f.jumpPeakX - f.jumpStartX) * t;
        const parab = 4 * t * (1 - t); // peak at t=0.5
        // smaller extra offset so big fish don't arc excessively
        f.y = f.jumpStartY - parab * (Math.abs(f.jumpPeakY - waterY) + 20);
        f.jumpTimer++;
      }else{
        // land and splash
        splashes.push({x: f.x, y: waterY + Math.sin(f.x * 0.01) * 5, radius: 6 + Math.random()*6, alpha:0.8, life:24, speed:2.2});
        createSplashSound(); // Play splash sound when fish lands
        createFishJumpEntrySound(); // Play entry sound
        f.jumpState = 'idle';
        f.y = waterY + 10 + Math.random() * 30;
      }
    }else{
      // normal swimming
      const oldX = f.x;
      
      // School behavior for small fish
      if(f.schoolId !== null && f.schoolId !== undefined){
        // Small fish in schools - stay close together
        const schoolMembers = fish.filter(sf => sf.schoolId === f.schoolId);
        if(schoolMembers.length > 1){
          const avgX = schoolMembers.reduce((sum, sf) => sum + sf.x, 0) / schoolMembers.length;
          const avgDepth = schoolMembers.reduce((sum, sf) => sum + sf.depth, 0) / schoolMembers.length;
          
          // Gently move toward school center
          f.x += (avgX - f.x) * 0.01 + f.speed * f.direction;
          // School moves together at same depth
          f.depth = avgDepth + (Math.random() - 0.5) * 0.05;
        }else{
          f.x += f.speed * f.direction;
        }
      }
      // Catfish aggressive loner behavior
      else if(f.type === 'catfish'){
        // Catfish avoid each other aggressively
        const otherCatfish = fish.filter(cf => cf.type === 'catfish' && cf !== f);
        for(let other of otherCatfish){
          const dist = Math.abs(f.x - other.x);
          if(dist < 100){
            // Run away from other catfish
            f.direction = f.x < other.x ? -1 : 1;
            f.x += f.speed * f.direction * 1.5;
            break;
          }
        }
        f.x += f.speed * f.direction * (Math.random() > 0.95 ? 0.5 : 1);
      }
      // Regular movement for other fish
      else{
        f.x += f.speed * f.direction;
      }
      
      // Update direction based on actual movement
      const actualMovement = f.x - oldX;
      if(Math.abs(actualMovement) > 0.1){
        f.direction = actualMovement > 0 ? 1 : -1;
      }
      
      f.wiggle += 0.05;
      if(Math.random() < 0.002) f.direction *= -1;
      if(f.x < -50) f.x = W + 50;
      if(f.x > W + 50) f.x = -50;
      // Depth dramatically affects Y position: 80px range instead of 20px
      f.y = waterY + 15 + Math.sin(f.wiggle) * 5 + f.depth * 80;
      // Constrain fish to stay in the water (below waterY)
      f.y = Math.max(waterY + 5, f.y);
    }

    const fishY = f.y;
    const fishLength = 15 * f.size;
    const fishHeight = 8 * f.size;

    ctx.save();
    // Depth dramatically affects visibility: barely visible at bottom (depth=1), full color at top (depth=0)
    const depthOpacity = 0.2 + (1 - f.depth) * 0.75; // Range: 0.2 (bottom) to 0.95 (top)
    const depthDarkness = f.depth * 0.8; // Range: 0 (top, no darkness) to 0.8 (bottom, very dark)
    ctx.globalAlpha = depthOpacity * (1 - foregroundDarken * 0.4);
    
    // Darken fish color based on depth
    const fishColorMatch = f.color.match(/\d+/g);
    if(fishColorMatch){
      const r = Math.floor(fishColorMatch[0] * (1 - depthDarkness));
      const g = Math.floor(fishColorMatch[1] * (1 - depthDarkness));
      const b = Math.floor(fishColorMatch[2] * (1 - depthDarkness));
      ctx.fillStyle = `rgb(${r},${g},${b})`;
    }else{
      ctx.fillStyle = f.color;
    }

    ctx.translate(f.x, fishY);
    // Fish is drawn facing right (tail on left), flip when moving left
    if(f.direction < 0) ctx.scale(-1, 1);

    // Draw fish body facing right (tail extends to left)
    ctx.beginPath();
    ctx.ellipse(0, 0, fishLength, fishHeight, 0, 0, Math.PI * 2);
    ctx.fill();

    // Draw tail on left side
    ctx.beginPath();
    ctx.moveTo(-fishLength, 0);
    ctx.lineTo(-fishLength - 8 * f.size, 5 * f.size);
    ctx.lineTo(-fishLength - 8 * f.size, -5 * f.size);
    ctx.closePath();
    ctx.fill();

    // Draw dorsal fin
    ctx.beginPath();
    ctx.moveTo(fishLength * 0.3, -fishHeight);
    ctx.lineTo(fishLength * 0.5, -fishHeight - 5 * f.size);
    ctx.lineTo(fishLength * 0.6, -fishHeight);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }
  
  if(owl && owlImg && owl.visible !== false){
    const owlSize = 30; // fixed size per user preference
    // Position owl GIF as HTML element for animation
    owlImg.style.display = 'block';
    owlImg.style.left = (owl.x - owlSize/2) + 'px';
    owlImg.style.top = (owl.y - owlSize/2) + 'px';
    owlImg.style.width = owlSize + 'px';
    owlImg.style.height = owlSize + 'px';
  } else if(owlImg) {
    owlImg.style.display = 'none';
  }
  
  document.getElementById('itemCount').textContent = items.length;
  document.getElementById('birds').textContent = birds.length;
  
  // when snow is accumulating or persisting, draw a full-scene overlay so snow covers background and foreground
  if(snowCover > 0.02){
    ctx.save();
    if(weatherData.condition === 'Snow'){
      // Active snowfall - more opaque overlay
      ctx.globalAlpha = Math.min(0.35, snowCover * 0.4);
    }else{
      // Persistent snow cover without active snowfall - subtle overlay
      ctx.globalAlpha = Math.min(0.15, snowCover * 0.15);
    }
    ctx.fillStyle = 'rgba(255,255,255,1)';
    ctx.fillRect(0, 0, W, H);
    ctx.restore();
  }

  // Dragonflies (summer daytime) â€” hover over water
  try{
    if(season === 'summer' && sunAlt > 0){
      if(Math.random() < 0.02 && dragonflies.length < 40){
        const x = Math.random() * W;
        const d = {x, y: waterY - (20 + Math.random() * 40), vx: (Math.random() - 0.5) * 1.2, phase: Math.random() * Math.PI * 2, life: 200 + Math.random() * 400};
        dragonflies.push(d);
      }
      for(let i = dragonflies.length - 1; i >= 0; i--){
        const d = dragonflies[i];
        d.x += d.vx;
        d.phase += 0.12;
        d.life--;
        if(d.life <= 0 || d.x < -50 || d.x > W + 50) dragonflies.splice(i, 1);
        else{
          const wy = d.y + Math.sin(animTime * 5 + d.phase) * 3;
          ctx.save();
          ctx.translate(d.x, wy);
          // body
          ctx.fillStyle = 'rgba(80,140,60,0.95)';
          ctx.beginPath();
          ctx.ellipse(0, 0, 6, 2.5, 0, 0, Math.PI * 2);
          ctx.fill();
          // wings (flutter)
          ctx.globalCompositeOperation = 'lighter';
          const wing = Math.sin(animTime * 20 + d.phase) * 0.6 + 0.8;
          ctx.fillStyle = 'rgba(220,240,255,0.7)';
          ctx.beginPath(); ctx.ellipse(-4, -1, 6 * wing, 2.6, -0.6, 0, Math.PI * 2); ctx.fill();
          ctx.beginPath(); ctx.ellipse(4, -1, 6 * wing, 2.6, 0.6, 0, Math.PI * 2); ctx.fill();
          ctx.globalCompositeOperation = 'source-over';
          ctx.restore();
        }
      }
    }
  }catch(e){/* non-fatal */}

  // Fireflies (summer night) â€” glow near foreground/trees
  try{
    if(season === 'summer' && sunAlt < 0){
      if(Math.random() < 0.02 && fireflies.length < 100){
        // try to spawn near a random foreground non-pine plant
        const candidates = items.filter(it => it.type === 'plant' && !it.isPine);
        let sx = Math.random() * W, sy = H * 0.8;
        if(candidates.length){ const t = candidates[Math.floor(Math.random() * candidates.length)]; sx = t.screenX + (Math.random() - 0.5) * 30; sy = t.screenY - 10 + (Math.random() - 0.5) * 12; }
        fireflies.push({x: sx, y: sy, vx: (Math.random() - 0.5) * 0.4, vy: (Math.random() - 0.5) * 0.2, phase: Math.random() * Math.PI * 2, life: 600 + Math.random() * 800});
      }
      for(let i = fireflies.length - 1; i >= 0; i--){
        const f = fireflies[i];
        f.x += f.vx + Math.sin(f.phase + animTime * 0.5) * 0.1;
        f.y += f.vy + Math.cos(f.phase + animTime * 0.3) * 0.05;
        f.phase += 0.08;
        f.life--;
        if(f.life <= 0) fireflies.splice(i, 1);
        else{
          const alpha = 0.3 + 0.6 * (0.5 + 0.5 * Math.sin(animTime * 3 + f.phase));
          ctx.save();
          ctx.globalCompositeOperation = 'lighter';
          const g = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, 12);
          g.addColorStop(0, `rgba(255,240,140,${alpha})`);
          g.addColorStop(0.5, `rgba(255,200,80,${alpha * 0.55})`);
          g.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = g;
          ctx.beginPath(); ctx.arc(f.x, f.y, 10, 0, Math.PI * 2); ctx.fill();
          ctx.globalCompositeOperation = 'source-over';
          ctx.restore();
        }
      }
    }
  }catch(e){/* non-fatal */}

  // Deer and Bunny: z-index layering handled in CSS above



  animTime += 0.1;
  updateFPS(); // Update frame rate counter
  requestAnimationFrame(draw);
  }catch(e){
    console.error('Draw error:', e);
    try{
      const loader = document.getElementById('loader');
      const loadingText = document.querySelector('.loading-text');
      if(loader && loadingText){
        loader.classList.remove('hidden');
        loadingText.textContent = 'Error: ' + (e && e.message ? e.message : String(e));
      }
    }catch(err){ console.error('Error showing loader:', err); }
    ready = false;
  }
}
class Item{
  constructor(x, y, type, subtype){
    this.baseX = x;
    this.baseY = y;
    this.screenX = x;
    this.screenY = y;
    this.type = type;
    this.subtype = subtype;
    this.age = 0;
    this.maxAge = 250;
    this.sizeMultiplier = 0.5 + Math.random() * 0.5;
    this.plantedDate = new Date(); // Track when plant was planted
    this.healthScore = 1.0; // Initial health
    
    if(type === 'accessory' && (subtype === 'custom' || subtype === 'customsaved')){
      this.customText = customSignText;
    }
    
    if(type === 'plant'){
      const types = {
        oak: {trunk:'#4a3520', maxH:120, trunkW:12, leafCount:120},
        pine: {trunk:'#3a2f20', maxH:160, trunkW:9, leafCount:0, isPine:true},
        willow: {trunk:'#4a3a25', maxH:110, trunkW:11, leafCount:150, isWillow:true},
        maple: {trunk:'#4a3520', maxH:115, trunkW:11, leafCount:110},
        birch: {trunk:'#e8e8e8', maxH:130, trunkW:10, leafCount:100},
        beech: {trunk:'#6a5a4a', maxH:125, trunkW:13, leafCount:130},
        basswood: {trunk:'#5a4a3a', maxH:118, trunkW:12, leafCount:115},
        laurel: {trunk:'#3a4a2f', maxH:95, trunkW:9, leafCount:140},
        walnut: {trunk:'#3a2a1a', maxH:135, trunkW:14, leafCount:125},
        hickory: {trunk:'#5a4a3a', maxH:140, trunkW:13, leafCount:120},
        chestnut: {trunk:'#4a3a2a', maxH:128, trunkW:13, leafCount:135},
        poplar: {trunk:'#6a5a4a', maxH:150, trunkW:10, leafCount:110},
        sycamore: {trunk:'#d8d8c8', maxH:145, trunkW:15, leafCount:140},
        rosebush: {trunk:'#2a4a1f', maxH:35, trunkW:4, leafCount:50, isBush:true},
        blueberry: {trunk:'#3a4a2f', maxH:30, trunkW:4, leafCount:45, isBush:true},
        lavender: {trunk:'#3a5a2f', maxH:25, trunkW:3, leafCount:40, isBush:true},
        tomato: {trunk:'#3a5a2f', maxH:40, trunkW:3, leafCount:35, isBush:true},
        pepper: {trunk:'#2a4a2f', maxH:35, trunkW:3, leafCount:30, isBush:true},
        eggplant: {trunk:'#2a3a3f', maxH:38, trunkW:3, leafCount:32, isBush:true},
        peas: {trunk:'#3a6a2f', maxH:20, trunkW:2, leafCount:25, isBush:true},
        lettuce: {trunk:'#4a7a3f', maxH:15, trunkW:2, leafCount:40, isBush:true},
        spinach: {trunk:'#3a6a3f', maxH:12, trunkW:2, leafCount:35, isBush:true},
        kale: {trunk:'#2a5a2f', maxH:18, trunkW:2, leafCount:38, isBush:true},
        beans: {trunk:'#3a5a2f', maxH:25, trunkW:2, leafCount:30, isBush:true},
        corn: {trunk:'#4a5a2f', maxH:60, trunkW:3, leafCount:20, isBush:true},
        squash: {trunk:'#5a6a2f', maxH:22, trunkW:3, leafCount:45, isBush:true},
        zucchini: {trunk:'#5a6a2f', maxH:20, trunkW:3, leafCount:42, isBush:true},
        cucumber: {trunk:'#3a6a2f', maxH:18, trunkW:2, leafCount:40, isBush:true},
        melon: {trunk:'#5a7a2f', maxH:20, trunkW:3, leafCount:45, isBush:true},
        pumpkin: {trunk:'#6a5a1f', maxH:25, trunkW:4, leafCount:50, isBush:true},
        broccoli: {trunk:'#2a5a2f', maxH:28, trunkW:3, leafCount:50, isBush:true},
        cabbage: {trunk:'#3a5a2f', maxH:25, trunkW:3, leafCount:48, isBush:true},
        beets: {trunk:'#5a3a2f', maxH:16, trunkW:2, leafCount:32, isBush:true},
        carrots: {trunk:'#6a4a1f', maxH:18, trunkW:2, leafCount:35, isBush:true},
        radish: {trunk:'#5a3a3f', maxH:12, trunkW:2, leafCount:28, isBush:true},
        chard: {trunk:'#4a6a3f', maxH:20, trunkW:2, leafCount:40, isBush:true},
        onion: {trunk:'#6a5a1f', maxH:14, trunkW:2, leafCount:25, isBush:true},
        leek: {trunk:'#5a6a2f', maxH:16, trunkW:2, leafCount:28, isBush:true},
        potato: {trunk:'#5a4a2f', maxH:18, trunkW:2, leafCount:30, isBush:true},
        garlic: {trunk:'#6a5a2f', maxH:12, trunkW:2, leafCount:20, isBush:true},
        asparagus: {trunk:'#4a6a2f', maxH:32, trunkW:2, leafCount:35, isBush:true},
        rhubarb: {trunk:'#6a3a2f', maxH:24, trunkW:3, leafCount:38, isBush:true},
        strawberry: {trunk:'#5a4a3f', maxH:12, trunkW:2, leafCount:35, isBush:true},
        microgreens: {trunk:'#4a6a3f', maxH:8, trunkW:2, leafCount:30, isBush:true},
        covercrop: {trunk:'#4a5a3f', maxH:15, trunkW:2, leafCount:40, isBush:true}
      };
      
      const t = types[subtype] || types.oak;
      this.trunk = t.trunk;
      this.maxH = t.maxH * this.sizeMultiplier;
      this.trunkW = t.trunkW * this.sizeMultiplier;
      this.leafCount = t.leafCount;
      this.isPine = t.isPine;
      this.isWillow = t.isWillow;
      this.isBush = t.isBush;
      
      this.leaves = [];
      if(!this.isPine){
        for(let i = 0; i < this.leafCount; i++){
          this.leaves.push({
            angle: Math.random() * Math.PI * 2,
            dist: this.isWillow ? Math.random() * 50 : Math.random() * 45,
            size: 4 + Math.random() * 7,
            sway: Math.random() * Math.PI * 2,
            speed: 0.02 + Math.random() * 0.03,
            yOffset: this.isWillow ? (Math.random() - 0.3) * 60 : 0
          });
        }
      }
    }
  }
  
  grow(){ 
    // For non-plants, use old system
    if(this.type !== 'plant' || !PLANT_CATALOG[this.subtype]){
      if(this.age < this.maxAge) this.age++;
      return;
    }
    
    // Real-time plant growth based on actual days
    const plant = PLANT_CATALOG[this.subtype];
    const now = new Date();
    const daysSincePlanted = (now - this.plantedDate) / (1000 * 60 * 60 * 24);
    
    // Calculate temperature and humidity scores
    const temp = (window.weatherData && (window.weatherData.temperature_current || window.weatherData.temp)) || 70;
    const humidity = 65 + Math.sin(Date.now() / 10000) * 15;
    
    let tempScore = 1;
    if(temp < plant.minTemp || temp > plant.maxTemp){
      const targetMin = plant.minTemp, targetMax = plant.maxTemp;
      const optimalRange = (targetMax - targetMin) / 2 + targetMin;
      const deviation = Math.abs(temp - optimalRange);
      tempScore = Math.max(0.3, 1 - (deviation / 20));
    }
    
    let humidityScore = 1;
    if(humidity < 30 || humidity > 85){
      const deviation = humidity < 30 ? (30 - humidity) : (humidity - 85);
      humidityScore = Math.max(0.4, 1 - (deviation / 30));
    }
    
    // Seasonal bonus
    const currentMonth = now.getMonth();
    const seasonalForMonth = getSeasonalPlants(currentMonth);
    let seasonalBonus = seasonalForMonth.includes(this.subtype) ? 1.2 : 0.8;
    
    // Update health score (slowly adapts to conditions)
    const targetHealth = tempScore * humidityScore * seasonalBonus;
    this.healthScore = this.healthScore * 0.95 + targetHealth * 0.05;
    this.healthScore = Math.max(0.2, Math.min(1.5, this.healthScore));
    
    // Real-time growth: age represents growth percentage (0-250 = 0%-100%)
    // Growth rate affected by health
    const effectiveDaysToMaturity = plant.daysToMaturity / this.healthScore;
    const growthPercent = Math.min(1, daysSincePlanted / effectiveDaysToMaturity);
    this.age = Math.floor(growthPercent * 250);
    this.maxAge = 250;
  }
  
  updateScreenPosition(){
    const currentTerrainY = getTerrainY(this.baseX);
    
    // For plants: if baseY is significantly different from terrain Y, use baseY (planted on slope)
    // Otherwise update to current terrain Y (normal placement or terrain changed)
    if(this.type === 'plant'){
      const yDifference = Math.abs(this.baseY - currentTerrainY);
      if(yDifference > 5){
        // Planted on slope, keep the offset relative to terrain
        this.screenY = this.baseY;
      } else {
        // Normal placement at terrain surface, update to current terrain
        this.screenY = currentTerrainY;
        this.baseY = currentTerrainY; // Update baseY too
      }
    } else {
      this.screenY = currentTerrainY;
      this.baseY = currentTerrainY;
    }
    this.screenX = this.baseX;
  }
  
  drawShadow(light){
    const shadowOpacity = light > 0.5 ? 0.4 : light > 0.2 ? 0.25 : 0.15;
    
    const dx = this.screenX - lightSourceX;
    const dy = this.screenY - lightSourceY;
    const shadowAngle = Math.atan2(dy, dx);
    
    const sunAltClamped = Math.max(-10, Math.min(85, lightSourceAlt));
    const sunZenith = 90 - sunAltClamped;
    const shadowLength = Math.max(6, Math.min(200, Math.tan(sunZenith * Math.PI / 180) * 60));
    
    const shadowEndX = this.screenX + Math.cos(shadowAngle) * shadowLength;
    const shadowEndY = this.screenY + Math.sin(shadowAngle) * shadowLength * 0.5;
    
    ctx.save();
    ctx.globalAlpha = shadowOpacity;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    
    if(this.type === 'accessory'){
      ctx.beginPath();
      ctx.ellipse(shadowEndX, shadowEndY, 15, 8, shadowAngle, 0, Math.PI * 2);
      ctx.fill();
    }else{
      const growth = Math.min(1, this.age / this.maxAge);
      const shadowW = this.trunkW * growth * 2;
      
      ctx.beginPath();
      ctx.ellipse(shadowEndX, shadowEndY, shadowW * 3, shadowW * 1.5, shadowAngle, 0, Math.PI * 2);
      ctx.fill();
    }
    
    ctx.restore();
  }
  
  getSeasonalColor(){
    const baseColors = {
      oak: ['#5a7a4f', '#4a6a3f', '#d4691f', '#8a7a6a'],
      pine: ['#2d4a2f', '#2d4a2f', '#2d4a2f', '#2d4a2f'],
      willow: ['#8a9a6f', '#6a8a5f', '#c4a51f', '#9a8a7a'],
      maple: ['#6a8a5f', '#5a7a4f', '#ff4444', '#7a6a5a'],
      birch: ['#8aaa7f', '#7a9a6f', '#f4b827', '#aaa090'],
      beech: ['#6a9a5f', '#5a8a4f', '#d4882f', '#8a7a6a'],
      basswood: ['#7aaa6f', '#6a9a5f', '#f4b030', '#9a8a7a'],
      laurel: ['#3a6a4f', '#3a6a4f', '#3a6a4f', '#3a6a4f'],
      walnut: ['#6a8a5f', '#5a7a4f', '#c4863f', '#7a6a5a'],
      hickory: ['#7a9a6f', '#6a8a5f', '#e4953f', '#8a7a6a'],
      chestnut: ['#6a9a5f', '#5a8a4f', '#d4884f', '#7a6a5a'],
      poplar: ['#7aaa6f', '#6a9a5f', '#f4b53f', '#9a8a7a'],
      sycamore: ['#6a9a6f', '#5a8a5f', '#e4984f', '#9a8a7a'],
      rosebush: ['#ff79c4', '#ff69b4', '#ff9aa9', '#8a7a6a'],
      blueberry: ['#6a8a7f', '#5a7a6f', '#8a6a5f', '#7a6a5a'],
      lavender: ['#bb79f0', '#ab69e0', '#9b59d0', '#8a7a7a']
    };
    
    const seasons = ['spring', 'summer', 'fall', 'winter'];
    const idx = seasons.indexOf(season);
    const colors = baseColors[this.subtype] || baseColors.oak;
    return colors[idx];
  }
  
  draw(light, darken, snowCover){
    if(this.type === 'accessory'){
      ctx.save();
      ctx.translate(this.screenX, this.screenY);
      
      if(this.subtype === 'rock'){
        ctx.fillStyle = `rgb(${Math.floor(120*(1-darken*0.6))},${Math.floor(120*(1-darken*0.6))},${Math.floor(130*(1-darken*0.6))})`;
        ctx.beginPath();
        ctx.ellipse(0, -10, 15, 10, 0, 0, Math.PI * 2);
        ctx.fill();
      }else if(this.subtype === 'boulder'){
        ctx.fillStyle = `rgb(${Math.floor(100*(1-darken*0.6))},${Math.floor(100*(1-darken*0.6))},${Math.floor(110*(1-darken*0.6))})`;
        ctx.beginPath();
        ctx.ellipse(0, -20, 25, 20, 0, 0, Math.PI * 2);
        ctx.fill();
      }else if(this.subtype === 'welcome' || this.subtype === 'keepout' || this.subtype === 'custom' || this.subtype === 'customsaved'){
        ctx.fillStyle = `rgb(${Math.floor(139*(1-darken*0.6))},${Math.floor(90*(1-darken*0.6))},${Math.floor(43*(1-darken*0.6))})`;
        ctx.fillRect(-20, -60, 40, 40);
        ctx.fillRect(-3, -20, 6, 20);
        ctx.fillStyle = `rgb(${Math.floor(255*(1-darken*0.4))},${Math.floor(255*(1-darken*0.4))},${Math.floor(255*(1-darken*0.4))})`;
        ctx.font = '9px Arial';
        ctx.textAlign = 'center';
        const text = this.subtype === 'welcome' ? 'WELCOME' : this.subtype === 'keepout' ? 'KEEP OUT' : this.customText;
        ctx.fillText(text, 0, -35);
      }
      
      ctx.restore();
      return;
    }
    
    const growth = Math.min(1, this.age / this.maxAge);
    const h = this.maxH * growth;
    const windBend = weatherData.windSpeed > 15 ? weatherData.windSpeed * 0.15 : weatherData.windSpeed * 0.08;
    const windSway = Math.sin(animTime * 0.08) * windBend * growth;
    
    ctx.save();
    ctx.translate(this.screenX, this.screenY);
    
    // Use trunk color directly without darkening
    ctx.strokeStyle = this.trunk;
    ctx.lineWidth = this.trunkW * growth;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(0, 0);
    if(this.isPine){
      ctx.lineTo(windSway * 0.4, -h * 0.65);
      ctx.stroke();
      
      // Use foliage color directly without darkening
      ctx.fillStyle = this.getSeasonalColor();
      const layers = 12;
      for(let i = 0; i < layers; i++){
        const progress = i / layers;
        const layerY = -h * 0.2 - (h * 0.8) * progress;
        const layerW = (layers - i) * 10 * growth;
        
        ctx.beginPath();
        ctx.moveTo(windSway * progress, layerY - (h * 0.8) / layers * 1.2);
        ctx.lineTo(-layerW + windSway * progress, layerY);
        ctx.lineTo(layerW + windSway * progress, layerY);
        ctx.closePath();
        ctx.fill();
        
        for(let j = 0; j < 3; j++){
          const offset = (j - 1) * layerW * 0.6;
          ctx.beginPath();
          ctx.moveTo(offset + windSway * progress, layerY - 5);
          ctx.lineTo(offset - layerW * 0.3 + windSway * progress, layerY + 5);
          ctx.lineTo(offset + layerW * 0.3 + windSway * progress, layerY + 5);
          ctx.closePath();
          ctx.fill();
        }
      }
    }else{
      ctx.lineTo(windSway * 0.3, -h * 0.5);
      ctx.stroke();
      
      ctx.globalAlpha = 0.88 * (1 - darken * 0.4);
      // Use leaf color directly without darkening
      ctx.fillStyle = this.getSeasonalColor();
      
      if(this.isWillow){
        for(let leaf of this.leaves){
          leaf.sway += leaf.speed;
          const leafWind = weatherData.windSpeed > 15 ? weatherData.windSpeed * 0.2 : weatherData.windSpeed * 0.1;
          const swayAmount = Math.sin(leaf.sway + weatherData.windSpeed * 0.03) * leafWind;
          const lx = Math.cos(leaf.angle) * leaf.dist * growth + swayAmount + windSway;
          const ly = -h * 0.6 + leaf.yOffset * growth + Math.sin(leaf.angle) * 10;
          
          ctx.beginPath();
          ctx.ellipse(lx, ly, leaf.size * growth, leaf.size * growth * 1.2, leaf.angle, 0, Math.PI * 2);
          ctx.fill();
        }
      }else if(this.isBush){
        for(let leaf of this.leaves){
          leaf.sway += leaf.speed;
          const swayAmount = Math.sin(leaf.sway + weatherData.windSpeed * 0.03) * 4;
          const lx = Math.cos(leaf.angle) * leaf.dist * 0.5 * growth + swayAmount;
          const ly = -h * 0.6 + Math.sin(leaf.angle) * leaf.dist * 0.4 * growth;
          
          ctx.beginPath();
          ctx.ellipse(lx, ly, leaf.size * growth, leaf.size * growth * 0.7, leaf.angle, 0, Math.PI * 2);
          ctx.fill();
        }
      }else{
        for(let leaf of this.leaves){
          leaf.sway += leaf.speed;
          const leafWind = weatherData.windSpeed > 15 ? weatherData.windSpeed * 0.25 : weatherData.windSpeed * 0.15;
          const swayAmount = Math.sin(leaf.sway + weatherData.windSpeed * 0.03) * leafWind;
          const lx = Math.cos(leaf.angle) * leaf.dist * growth + swayAmount + windSway * 0.5;
          const ly = -h * 0.75 + Math.sin(leaf.angle) * leaf.dist * growth * 0.5;
          
          ctx.beginPath();
          ctx.ellipse(lx, ly, leaf.size * growth, leaf.size * growth * 0.65, leaf.angle, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
    
    if(snowCover > 0.02){
      ctx.fillStyle = `rgba(255,255,255,${Math.min(0.9, snowCover*0.9)})`;
      ctx.beginPath();
      ctx.ellipse(windSway * 0.5, -h * 0.7, this.trunkW * 3 * growth, this.trunkW * 1.5 * growth, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Draw health meter only for vegetables/fruits (actual crops), not trees or berries
    const vegetablesList = ['tomato','pepper','eggplant','peas','lettuce','spinach','kale','beans','corn','squash','zucchini','cucumber','melon','pumpkin','broccoli','cabbage','beets','carrots','radish','chard','onion','leek','potato','garlic','asparagus','rhubarb','microgreens','covercrop'];
    if(this.type === 'plant' && PLANT_CATALOG[this.subtype] && vegetablesList.includes(this.subtype)){
      const meterWidth = 40;
      const meterHeight = 5;
      const meterX = -meterWidth / 2;
      const meterY = -h - 15;
      
      // Background
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(meterX, meterY, meterWidth, meterHeight);
      
      // Health bar (color based on health level)
      const healthPercent = Math.max(0, Math.min(1, this.healthScore));
      let healthColor = '#ff3333'; // Red for poor
      if(healthPercent > 0.7) healthColor = '#33ff33'; // Green for good
      else if(healthPercent > 0.4) healthColor = '#ffff33'; // Yellow for ok
      
      ctx.fillStyle = healthColor;
      ctx.fillRect(meterX, meterY, meterWidth * healthPercent, meterHeight);
      
      // Border
      ctx.strokeStyle = 'rgba(255,255,255,0.6)';
      ctx.lineWidth = 1;
      ctx.strokeRect(meterX, meterY, meterWidth, meterHeight);
      
      // Growth percentage text
      const growthPercent = Math.floor((this.age / this.maxAge) * 100);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.font = 'bold 8px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(`${growthPercent}%`, 0, meterY - 3);
    }
    
    ctx.globalAlpha = 1;
    ctx.restore();
  }
}
class Bird{
  constructor(x, y, type = 'generic', nestTree = null){
    this.x = x;
    this.y = y;
    this.type = type;
    this.vx = Math.random() < 0.5 ? 1.8 + Math.random() * 1.5 : -(1.8 + Math.random() * 1.5);
    this.vy = (Math.random() - 0.5) * 0.6;
    this.frame = 0;
    this.size = type === 'cardinal' || type === 'robin' ? 9 : 7;
    this.wingSpeed = 0.12 + Math.random() * 0.06;
    this.state = 'flying';
    this.landTimer = 0;
    this.nestTimer = 0;
    this.pickTimer = 0;
    this.nestTree = nestTree;
    
    if(type === 'cardinal') this.color = '#d32f2f';
    else if(type === 'robin') this.color = '#ff5722';
    else this.color = ['#4169E1', '#1E90FF', '#000', '#8B4513'][Math.floor(Math.random() * 4)];
    
    this.chirpTimer = Math.random() * 300;
    this.nextChirp = 200 + Math.random() * 500;
    
    if(!nestTree && Math.random() < 0.15){
      this.targetLand = true;
      this.landX = 200 + Math.random() * (W - 400);
    }
  }
  
  update(){
    if(this.state === 'flying'){
      this.x += this.vx;
      this.y += this.vy;
      
      this.vy += Math.sin(this.frame * 0.02) * 0.03;
      this.vy = Math.max(-2, Math.min(2, this.vy));
      
      if(this.y < H * 0.1) this.vy += 0.05;
      if(this.y > H * 0.5) this.vy -= 0.05;
      
      if(this.nestTree && Math.abs(this.x - this.nestTree.screenX) < 40 && this.y > this.nestTree.screenY - 100){
        this.state = 'nesting';
        this.nestTimer = 200 + Math.floor(Math.random() * 150);
        this.x = this.nestTree.screenX + (Math.random() - 0.5) * 30;
        this.y = this.nestTree.screenY - this.nestTree.maxH * 0.6;
      }else if(this.targetLand && Math.abs(this.x - this.landX) < 50 && this.y > H * 0.45){
        this.state = 'landing';
        this.targetY = getTerrainY(this.landX);
      }
    }else if(this.state === 'landing'){
      this.x += (this.landX - this.x) * 0.1;
      this.y += (this.targetY - this.y) * 0.15;
      
      if(Math.abs(this.y - this.targetY) < 5){
        this.state = 'landed';
        this.landTimer = 60 + Math.floor(Math.random() * 80);
      }
    }else if(this.state === 'landed'){
      this.landTimer--;
      this.pickTimer++;
      
      if(this.landTimer <= 0){
        this.state = 'flying';
        this.vy = -2;
      }
    }else if(this.state === 'nesting'){
      this.nestTimer--;
      this.pickTimer++;
      
      if(Math.random() < 0.02){
        this.x = this.nestTree.screenX + (Math.random() - 0.5) * 30;
      }
    }
    
    this.frame++;
    
    this.chirpTimer++;
    if(this.chirpTimer >= this.nextChirp && soundEnabled && sunAlt > 0){
      createBirdChirp(this.type);
      this.chirpTimer = 0;
      this.nextChirp = 250 + Math.random() * 600;
    }
  }
  
  drawShadow(light){
    if(this.state === 'flying') return;
    
    const shadowOpacity = light > 0.5 ? 0.3 : light > 0.2 ? 0.2 : 0.12;
    
    if(this.state === 'landed' || this.state === 'nesting'){
      const dx = this.x - lightSourceX;
      const dy = this.y - lightSourceY;
      const shadowAngle = Math.atan2(dy, dx);
      
      const sunAltClamped = Math.max(-10, Math.min(85, lightSourceAlt));
      const sunZenith = 90 - sunAltClamped;
      const shadowLength = Math.max(6, Math.min(120, Math.tan(sunZenith * Math.PI / 180) * 15));
      
      const shadowEndX = this.x + Math.cos(shadowAngle) * shadowLength;
      const shadowEndY = this.y + Math.sin(shadowAngle) * shadowLength * 0.3;
      
      ctx.save();
      ctx.globalAlpha = shadowOpacity;
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.beginPath();
      ctx.ellipse(shadowEndX, shadowEndY, this.size * 1.5, this.size * 0.5, shadowAngle, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }
  
  draw(light, darken, sunPos){
    const isOverDarkTerrain = this.x < W * 0.25;
    const isOnGround = this.state === 'landed' || this.state === 'nesting';
    const isInFrontOfSun = sunPos.visible && Math.abs(this.x - sunPos.x) < 120 && Math.abs(this.y - sunPos.y) < 120;
    
    let birdDarken = darken;
    let birdColor = this.color;
    
    if(isInFrontOfSun && !isOnGround){
      birdColor = 'rgba(0,0,0,0.8)';
    }else if(isOnGround){
      birdColor = this.color;
      birdDarken = isOverDarkTerrain ? Math.max(darken, 0.6) : darken;
    }else{
      birdDarken = isOverDarkTerrain ? Math.max(darken, 0.6) : darken;
      if(!isOnGround) birdColor = isOverDarkTerrain ? `rgba(0,0,0,${0.7*(1-light*0.3)})` : this.color;
    }
    
    ctx.save();
    ctx.globalAlpha = 0.95 * (1 - birdDarken * 0.5);
    
    if(this.state === 'landed' || this.state === 'nesting'){
      const peck = Math.sin(this.pickTimer * 0.2) > 0.5 ? 5 : 0;
      
      ctx.fillStyle = birdColor;
      ctx.beginPath();
      ctx.ellipse(this.x, this.y - 8 + peck, this.size * 0.7, this.size * 0.5, 0, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(this.x + this.size * 0.5, this.y - 12 + peck, this.size * 0.4, 0, Math.PI * 2);
      ctx.fill();
      
      if(this.state === 'landed'){
        ctx.strokeStyle = birdColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x - 3, this.y - 5);
        ctx.lineTo(this.x - 3, this.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(this.x + 3, this.y - 5);
        ctx.lineTo(this.x + 3, this.y);
        ctx.stroke();
      }
    }else{
      const facing = this.vx > 0 ? 1 : -1;
      const wingFlap = Math.sin(this.frame * this.wingSpeed) * this.size * 0.7;
      
      ctx.fillStyle = birdColor;
      ctx.beginPath();
      ctx.ellipse(this.x, this.y, this.size * 0.8, this.size * 0.5, 0, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(this.x + facing * this.size * 0.6, this.y - this.size * 0.2, this.size * 0.4, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.quadraticCurveTo(this.x - this.size * 1.5 * facing, this.y + wingFlap, this.x - this.size * 2 * facing, this.y - this.size * 0.3);
      ctx.quadraticCurveTo(this.x - this.size * 1.2 * facing, this.y + this.size * 0.2, this.x, this.y + this.size * 0.2);
      ctx.closePath();
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.quadraticCurveTo(this.x + this.size * 1.5 * facing, this.y - wingFlap, this.x + this.size * 2 * facing, this.y - this.size * 0.3);
      ctx.quadraticCurveTo(this.x + this.size * 1.2 * facing, this.y + this.size * 0.2, this.x, this.y + this.size * 0.2);
      ctx.closePath();
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(this.x - facing * this.size * 0.5, this.y + this.size * 0.2);
      ctx.lineTo(this.x - facing * this.size * 1.2, this.y + this.size * 0.5);
      ctx.lineTo(this.x - facing * this.size * 0.5, this.y + this.size * 0.4);
      ctx.fill();
      
      if(!isOverDarkTerrain && !isInFrontOfSun){
        ctx.fillStyle = this.type === 'cardinal' || this.type === 'robin' ? '#FFA500' : '#000';
        ctx.beginPath();
        ctx.moveTo(this.x + facing * this.size * 0.8, this.y - this.size * 0.2);
        ctx.lineTo(this.x + facing * this.size * 1.1, this.y - this.size * 0.15);
        ctx.lineTo(this.x + facing * this.size * 0.8, this.y - this.size * 0.1);
        ctx.fill();
      }
    }
    
    ctx.globalAlpha = 1;
    ctx.restore();
  }
}

init();
</script>
<div style="position:fixed;bottom:5px;left:50%;transform:translateX(-50%);font-size:9px;color:rgba(0,255,255,0.3);z-index:1000;text-align:center;">
  <a href="#" onclick="alert('Privacy: No personal data collected. Location data stays on your device.');return false;" style="color:inherit;text-decoration:none;">Privacy</a> | 
  <a href="#" onclick="alert('Terms: Free to use for personal enjoyment. Powered by Open-Meteo API.');return false;" style="color:inherit;text-decoration:none;">Terms</a>
</div>
<div style="position:fixed;bottom:5px;left:50%;transform:translateX(-50%);font-size:10px;color:rgba(0,255,255,0.4);z-index:1000;text-align:center;pointer-events:none;">
  Created by Chris Fisher Â© 2025
</div>
<div id="credit" style="position:fixed;bottom:10px;left:10px;font-size:9px;color:rgba(0,255,255,0.3);z-index:100;font-family:'Courier New',monospace;">
  Â© 2025 Chris Fisher
</div>

<!-- UI: Constellation tooltip, forecast, bird guide, moon calendar, seasonal overlays -->
<style>
  #constellationTooltip{position:fixed;pointer-events:none;z-index:1200;background:rgba(0,0,0,0.7);color:#fff;padding:8px;border-radius:6px;font-size:12px;max-width:260px;display:none}
  #forecastPanel{display:none;position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:260px;background:rgba(0,0,0,0.8);backdrop-filter:blur(4px);border:1px solid rgba(255,255,255,0.06);padding:8px;border-radius:8px;color:#e8f6ff;font-family:Arial;z-index:1100}
  #forecastPanel h4{margin:0 0 6px 0;font-size:13px}
  #birdGuideBtn{position:fixed;right:12px;top:12px;padding:6px 8px;border-radius:6px;background:rgba(0,0,0,0.5);color:#fff;border:1px solid rgba(255,255,255,0.06);cursor:pointer;z-index:1101}
  #birdGuideModal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:320px;max-height:60vh;overflow:auto;background:rgba(0,0,0,0.95);color:#0ff;padding:10px;border-radius:8px;border:2px solid rgba(0,255,255,0.5);display:none;z-index:250;visibility:visible}
    #fishGuideModal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:320px;max-height:60vh;overflow:auto;background:rgba(0,0,0,0.95);color:#0ff;padding:10px;border-radius:8px;border:2px solid rgba(0,255,255,0.5);display:none;z-index:250;visibility:visible}
    #treeGuideModal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:320px;max-height:60vh;overflow:auto;background:rgba(0,0,0,0.95);color:#0ff;padding:10px;border-radius:8px;border:2px solid rgba(0,255,255,0.5);display:none;z-index:250;visibility:visible}
  #moonCalendar{display:none;position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:500px;background:rgba(0,30,40,0.98);color:#dfefff;padding:8px;border-radius:12px;border:3px solid #0ff;z-index:1100}
  .moonGrid{display:grid;grid-template-columns:repeat(7,1fr);gap:4px;font-size:11px}
  .moonCell{padding:6px;background:rgba(255,255,255,0.02);border-radius:4px;text-align:center}
  #iceOverlay{position:fixed;left:0;right:0;bottom:0;height:22%;pointer-events:none;z-index:1000;background:linear-gradient(rgba(180,220,255,0.08),rgba(220,245,255,0.12));display:none}
  .bloomPetal{position:absolute;width:10px;height:10px;pointer-events:none;opacity:0.9}
  /* Accessibility quick styles toggled from Settings */
  .reduce-motion *{transition:none!important;animation:none!important}
  .high-contrast #forecastPanel, .high-contrast #moonCalendar, .high-contrast #birdGuideModal{background:rgba(0,0,0,0.95);border-color:rgba(255,255,255,0.2)}
    .high-contrast #fishGuideModal{background:rgba(0,0,0,0.95);border-color:rgba(255,255,255,0.2)}
    .high-contrast #treeGuideModal{background:rgba(0,0,0,0.95);border-color:rgba(255,255,255,0.2)}
  .high-contrast .btn{border-color:rgba(255,255,255,0.18);color:#fff}
  .large-text {font-size:1.05rem}
</style>

<div id="constellationTooltip"></div>
<!-- Small buttons placed below the main control buttons to match existing style -->
<button id="forecastBtn" class="btn">Forecast</button>
<button id="moonBtn" class="btn">Moon</button>
<div id="forecastPanel" class="modal" style="display:none;left:50%;top:50%;transform:translate(-50%,-50%);width:260px;padding:10px;">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
    <h4 style="margin:0">Next 3 Hours</h4>
    <button class="modal-btn" onclick="document.getElementById('forecastPanel').style.display='none'">âœ•</button>
  </div>
  <div id="forecastList">Loadingâ€¦</div>
</div>
<div id="birdGuideModal" class="modal" style="display:none;left:50%;top:50%;transform:translate(-50%,-50%);width:320px;padding:10px;z-index:250;visibility:visible">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
    <h4 style="margin:0">Bird Guide</h4>
    <button class="modal-btn" onclick="document.getElementById('birdGuideModal').style.display='none'">âœ•</button>
  </div>
  <div id="birdGuideContent"></div>
</div>

<div id="fishGuideModal" class="modal" style="display:none;left:50%;top:50%;transform:translate(-50%,-50%);width:320px;padding:10px;z-index:250;visibility:visible">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
    <h4 style="margin:0">Fish Guide</h4>
    <button class="modal-btn" onclick="document.getElementById('fishGuideModal').style.display='none'">âœ•</button>
  </div>
  <div id="fishGuideContent"></div>
</div>

<div id="treeGuideModal" class="modal" style="display:none;left:50%;top:50%;transform:translate(-50%,-50%);width:320px;padding:10px;z-index:250;visibility:visible">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
    <h4 style="margin:0">Tree Guide</h4>
    <button class="modal-btn" onclick="document.getElementById('treeGuideModal').style.display='none'">âœ•</button>
  </div>
  <div id="treeGuideContent"></div>
</div>

<div id="moonCalendar" class="modal" style="display:none;left:50%;top:50%;transform:translate(-50%,-50%);width:580px;max-height:85vh;overflow-y:auto;padding:10px;">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
    <h4 style="margin:0">ğŸŒ¾ Farmer's Almanac</h4>
    <button class="modal-btn" onclick="document.getElementById('moonCalendar').style.display='none'">âœ•</button>
  </div>
  <div id="almanacAdvice" style="margin-bottom:8px;padding:8px;background:rgba(0,100,50,0.3);border-radius:4px;font-size:12px"></div>
  <div id="moonGrid" class="moonGrid"></div>
  <div style="margin-top:8px;font-size:11px" id="meteorList"></div>
  <div id="fishingForecast" style="margin-top:8px;padding:8px;background:rgba(0,80,120,0.3);border-radius:4px;font-size:12px"></div>
</div>
  <div id="communityHistoryModal" class="modal" style="display:none;left:50%;top:50%;transform:translate(-50%,-50%);width:600px;max-height:85vh;overflow:hidden;padding:10px;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;border-bottom:2px solid #0ff;padding-bottom:8px;">
      <h4 style="margin:0;color:#0cf;">ğŸ“š Community History</h4>
      <button class="modal-btn" onclick="document.getElementById('communityHistoryModal').style.display='none'">âœ•</button>
    </div>
    <div id="communityHistoryScroll" style="max-height:65vh;overflow-y:auto;padding-right:6px;">
      <div id="historyContent" style="font-size:12px;line-height:1.6;color:#0cf;background:rgba(0,60,80,0.25);padding:10px;border-radius:6px;"></div>
      <div id="astronomyConnection" style="margin-top:12px;padding:12px;background:rgba(0,150,200,0.2);border-left:4px solid #0ff;border-radius:4px;font-size:11px;color:#aaf;"></div>
    </div>
  </div>
<div id="iceOverlay"></div>

<div id="plantHealthPanel">
  <h2>ğŸŒ± Plant Health Reference</h2>
  <div style="font-size:12px;color:#aaa;margin-bottom:16px;line-height:1.4">
    Plants thrive based on current weather, season, and optimal growing conditions. Check back throughout the season to see growth changes.
  </div>
  <div id="plantHealthContent">Loading plant health...</div>
</div>

<script>
// Lightweight utilities and UI wiring for constellations, forecast, bird guide, moon calendar, seasonal visuals
(function(){
  const canvas = document.querySelector('canvas');
  const tip = document.getElementById('constellationTooltip');
  const forecastList = document.getElementById('forecastList');
  const birdGuideModal = document.getElementById('birdGuideModal');
  const fishGuideModal = document.getElementById('fishGuideModal');
  const treeGuideModal = document.getElementById('treeGuideModal');
  const moonGrid = document.getElementById('moonGrid');
  const meteorList = document.getElementById('meteorList');
  const almanacAdvice = document.getElementById('almanacAdvice');
  const fishingForecast = document.getElementById('fishingForecast');
  const birdGuideContent = document.getElementById('birdGuideContent');
  const fishGuideContent = document.getElementById('fishGuideContent');
  const treeGuideContent = document.getElementById('treeGuideContent');
  const forecastBtn = document.getElementById('forecastBtn');
  const moonBtn = document.getElementById('moonBtn');
  const forecastPanel = document.getElementById('forecastPanel');
  const moonCalendar = document.getElementById('moonCalendar');
  const clockBtn = document.getElementById('clockBtn');
  const settingsBtn = document.getElementById('settingsBtn');
  const settingsModal = document.getElementById('settingsModal');
  const rakeBtnEl = document.getElementById('rakeBtn');
  const iceOverlay = document.getElementById('iceOverlay');
  const openBirdGuideBtn = document.getElementById('openBirdGuideBtn');
  const openFishGuideBtn = document.getElementById('openFishGuideBtn');
  const openTreeGuideBtn = document.getElementById('openTreeGuideBtn');

  const CONSTELLATION_INFO = {
    'Orion':'A prominent winter constellation containing Betelgeuse and Rigel, recognizable by the three-star belt.',
    'Ursa Major':'Contains the Big Dipper asterism; useful for finding north.',
    'Cassiopeia':'W-shaped constellation visible in northern skies, opposite the Big Dipper.',
    'Scorpius':'A summer constellation with bright red Antares near its heart.'
  };

  const METEOR_SHOWERS = [
    {name:'Quadrantids',month:1,day:3},
    {name:'Lyrids',month:4,day:22},
    {name:'Perseids',month:8,day:12},
    {name:'Geminids',month:12,day:14}
  ];

  function nearestStar(x,y,maxDist=16){
    const s = (stars || window.stars || window._stars || []).filter(st => st.bright);
    if(!s.length) return null;
    let best=null,bd=Infinity;
    for(let st of s){
      const dx=st.x - x, dy=st.y - y;
      const d = Math.sqrt(dx*dx+dy*dy);
      if(d<bd && d<=maxDist){bd=d;best=st}
    }
    return best;
  }

  // Helper function to show tooltips
  function showTooltipsAt(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const mx = clientX - rect.left;
    const my = clientY - rect.top;
    
    // Check for plant hover
    checkPlantHover(mx, my);
    
    const star = nearestStar(mx,my,18);
    if(star){
      const name = star.name || ('Mag '+(star.mag||'?'));
      const cons = star.constellation || star.con || 'Unknown constellation';
      const info = CONSTELLATION_INFO[cons] || '';
      tip.style.left = (clientX+12)+'px';
      tip.style.top = (clientY+12)+'px';
      const mag = star.mag !== undefined ? `Mag ${star.mag.toFixed(2)}` : '';
      const alt = star.alt !== undefined ? `${star.alt.toFixed(0)}Â° alt` : '';
      const meta = [mag, alt].filter(Boolean).join(' â€¢ ');
      tip.innerHTML = `<strong>${name}</strong><div style="font-size:12px;margin-top:6px">${cons}</div><div style="font-size:11px;color:#cfe8ff;margin-top:4px">${meta}</div><div style="margin-top:6px;font-size:11px;color:#cfe8ff">${info}</div>`;
      tip.style.display='block';
    }else{ tip.style.display='none'; }
  }

  // Mouse events
  canvas && canvas.addEventListener('mousemove', (ev)=>{
    showTooltipsAt(ev.clientX, ev.clientY);
  });

  canvas && canvas.addEventListener('mouseleave', ()=> tip.style.display='none');

  // Touch events for mobile devices
  canvas && canvas.addEventListener('touchmove', (ev)=>{
    if(ev.touches.length > 0){
      showTooltipsAt(ev.touches[0].clientX, ev.touches[0].clientY);
    }
  }, {passive:true});

  canvas && canvas.addEventListener('touchend', ()=> {
    tip.style.display='none';
    document.getElementById('plantTooltip').style.display = 'none';
  });

  // Forecast: build a minimal 3-hour forecast from available weatherData or synthesize
  function updateForecast(){
    const wd = window.weatherData || {};
    let hours=[];
    const now = new Date();
    const currentMonth = now.getMonth();
    const currentHour = now.getHours();
    
    // Calculate current environmental conditions
    const baseTemp = (wd.temperature_current !== undefined) ? wd.temperature_current : (wd.temp || 12);
    const humidity = Math.round(50 + Math.random()*30); // 50-80%
    const baseWind = Math.round(5 + Math.random()*10); // 5-15 mph base
    
    // Pollen levels by season (higher in spring/summer)
    const pollenSeasonFactor = (currentMonth >= 2 && currentMonth <= 8) ? 1.5 : 0.3;
    const basePollen = Math.round((20 + Math.random()*60) * pollenSeasonFactor);
    
    // UV index based on time of day and season
    const uvSeasonFactor = (currentMonth >= 4 && currentMonth <= 8) ? 1.3 : 0.7;
    
    // Air quality (better in winter, worse in summer heat)
    const aqSeasonFactor = (currentMonth >= 5 && currentMonth <= 8) ? 0.8 : 1.0;
    
    for(let i=0;i<5;i++){
      const h = new Date(now.getTime() + i*60*60*1000);
      let temp = Math.round(baseTemp + (Math.random()*3-1.5) + (i*0.5)); // Slight temp change over hours
      const precip = Math.random()< (wd.precipitation_probability || 0.12) ? (Math.random()*60|0) : 0;
      const sky = precip>20 ? 'Rain' : (Math.random()<0.2 ? 'Cloudy' : 'Clear');
      
      // Wind speed varies throughout day
      const wind = Math.round(baseWind + (Math.random()*5-2.5));
      const windDir = ['N','NE','E','SE','S','SW','W','NW'][Math.floor(Math.random()*8)];
      
      // Pollen varies by hour (lower at night)
      const hourOfDay = h.getHours();
      const pollenTimeFactor = (hourOfDay >= 6 && hourOfDay <= 18) ? 1.0 : 0.2;
      const pollen = Math.round(basePollen * pollenTimeFactor);
      const pollenLevel = pollen < 30 ? 'Low' : pollen < 60 ? 'Medium' : pollen < 90 ? 'High' : 'Very High';
      
      // UV index (0 at night, peak midday)
      let uv = 0;
      if(hourOfDay >= 6 && hourOfDay <= 18){
        const midday = Math.abs(hourOfDay - 12);
        uv = Math.round((10 - midday) * uvSeasonFactor);
        if(uv < 0) uv = 0;
        if(sky === 'Cloudy') uv = Math.round(uv * 0.7);
        if(sky === 'Rain') uv = Math.round(uv * 0.5);
      }
      const uvLevel = uv <= 2 ? 'Low' : uv <= 5 ? 'Moderate' : uv <= 7 ? 'High' : uv <= 10 ? 'Very High' : 'Extreme';
      
      // Fire danger (temp, wind, humidity, precip)
      let fireDanger = 0;
      if(temp > 70) fireDanger += (temp - 70) / 5;
      if(wind > 10) fireDanger += (wind - 10) / 3;
      if(humidity < 40) fireDanger += (40 - humidity) / 10;
      if(precip > 0) fireDanger -= precip / 10;
      fireDanger = Math.max(0, Math.round(fireDanger));
      const fireDangerLevel = fireDanger < 2 ? 'Low' : fireDanger < 5 ? 'Moderate' : fireDanger < 8 ? 'High' : 'Extreme';
      
      // Air quality (AQI estimate)
      const baseAQI = Math.round((30 + Math.random()*50) * aqSeasonFactor);
      const aqi = sky === 'Rain' ? Math.round(baseAQI * 0.7) : baseAQI;
      const aqiLevel = aqi <= 50 ? 'Good' : aqi <= 100 ? 'Moderate' : aqi <= 150 ? 'Unhealthy for Sensitive' : 'Unhealthy';
      
      // 12-hour time format
      const hh = h.getHours();
      const ampm = hh >= 12 ? 'PM' : 'AM';
      const hour12 = ((hh + 11) % 12) + 1;
      const timeStr = hour12 + ':00 ' + ampm;
      
      hours.push({time: timeStr, temp, precip, sky, wind, windDir, pollen, pollenLevel, uv, uvLevel, fireDanger, fireDangerLevel, aqi, aqiLevel, humidity});
    }
    
    // Display comprehensive forecast
    forecastList.innerHTML = hours.map(h=>`
      <div style="margin-bottom:10px;padding:8px;background:rgba(255,255,255,0.05);border-radius:4px">
        <div style="font-weight:600;margin-bottom:4px">${h.time}</div>
        <div style="font-size:11px;line-height:1.5">
          <strong>${h.sky}</strong> â€¢ ${h.temp}Â°F ${h.precip?('â€¢ '+h.precip+'% rain'):''}<br>
          ğŸ’¨ Wind: ${h.wind} mph ${h.windDir} â€¢ ğŸ’§ Humidity: ${h.humidity}%<br>
          ğŸŒ¸ Pollen: ${h.pollenLevel} â€¢ â˜€ï¸ UV: ${h.uv} (${h.uvLevel})<br>
          ğŸ”¥ Fire Danger: ${h.fireDangerLevel} â€¢ ğŸŒ«ï¸ AQI: ${h.aqi} (${h.aqiLevel})
        </div>
      </div>
    `).join('');
  }
  updateForecast();
  setInterval(updateForecast, 5*60*1000);
  
  // Farmers Almanac Data - Detailed monthly planting guide (DEFINE BEFORE USE)
  const PLANTING_CALENDAR = {
    0: {plant:['Order seeds (1-15): Tomatoes, peppers, eggplant','Plan garden (1-31)'],harvest:['Indoor microgreens','Stored root vegetables'],activity:'Indoor seed starting prep, inventory tools'},
    1: {plant:['Sow indoors (1-28): Tomatoes, peppers, eggplant','Onion sets (15-28)'],harvest:['Winter storage crops'],activity:'Prune fruit trees (1-15), start seed trays'},
    2: {plant:['Direct sow (15-31): Peas, lettuce, spinach, kale','Plant potatoes (20-31)'],harvest:['Early greens from cold frames'],activity:'Prepare soil, add compost'},
    3: {plant:['Sow (1-15): Beets, carrots, radishes, Swiss chard','Plant (15-30): Onions, leeks'],harvest:['Asparagus (15-30), rhubarb, early lettuce'],activity:'Direct sow cool-season vegetables'},
    4: {plant:['Plant (1-15): Beans, corn, squash','Transplant (15-30): Tomatoes, peppers after last frost'],harvest:['Lettuce, spinach, peas, radishes'],activity:'Transplant warm-season seedlings, mulch'},
    5: {plant:['Sow (1-30): Cucumbers, melons, pumpkins','Succession plant: Beans, corn (every 2 weeks)'],harvest:['Strawberries, early potatoes, lettuce'],activity:'Mulch and weed control, water regularly'},
    6: {plant:['Start indoors (1-15): Broccoli, cabbage for fall','Succession lettuce (1-30)'],harvest:['Tomatoes, beans, summer squash, zucchini'],activity:'Harvest daily, preserve peak crops'},
    7: {plant:['Sow (1-31): Fall carrots, beets, kale','Plant (15-31): Fall lettuce, spinach'],harvest:['Corn, peppers, eggplant, tomatoes'],activity:'Can and freeze produce, save seeds'},
    8: {plant:['Plant garlic cloves (15-30)','Sow (1-15): Fall spinach, cover crops'],harvest:['Potatoes, onions, tomatoes, squash'],activity:'Cure storage crops, save seeds'},
    9: {plant:['Plant garlic (1-15), winter wheat','Cover crops (15-30)'],harvest:['Pumpkins, winter squash, late tomatoes'],activity:'Prepare beds for winter, clean up'},
    10: {plant:['Plant spring bulbs (1-30)','Cover crops if not done'],harvest:['Late greens, Brussels sprouts, kale'],activity:'Mulch perennials, protect tender plants'},
    11: {plant:['Plan next year\'s garden','Order seed catalogs'],harvest:['Winter storage harvest, kale, collards'],activity:'Tool maintenance, garden cleanup'}
  };

  // Plant catalog with all plants from almanac (DEFINE BEFORE USE)
  const PLANT_CATALOG = {
    // Vegetables (with real daysToMaturity)
    tomato: {name:'Tomato', type:'vegetable', icon:'ğŸ…', minTemp:50, maxTemp:95, water:7, daysToMaturity:70},
    pepper: {name:'Pepper', type:'vegetable', icon:'ğŸ«‘', minTemp:55, maxTemp:90, water:6, daysToMaturity:75},
    eggplant: {name:'Eggplant', type:'vegetable', icon:'ğŸ†', minTemp:60, maxTemp:95, water:7, daysToMaturity:80},
    peas: {name:'Peas', type:'vegetable', icon:'ğŸ«›', minTemp:40, maxTemp:75, water:5, daysToMaturity:60},
    lettuce: {name:'Lettuce', type:'vegetable', icon:'ğŸ¥¬', minTemp:45, maxTemp:75, water:6, daysToMaturity:45},
    spinach: {name:'Spinach', type:'vegetable', icon:'ğŸ¥¬', minTemp:40, maxTemp:70, water:6, daysToMaturity:40},
    kale: {name:'Kale', type:'vegetable', icon:'ğŸ¥¬', minTemp:40, maxTemp:75, water:6, daysToMaturity:55},
    beans: {name:'Beans', type:'vegetable', icon:'ğŸ«˜', minTemp:60, maxTemp:85, water:6, daysToMaturity:50},
    corn: {name:'Corn', type:'vegetable', icon:'ğŸŒ½', minTemp:60, maxTemp:90, water:6, daysToMaturity:75},
    squash: {name:'Squash', type:'vegetable', icon:'ğŸƒ', minTemp:65, maxTemp:90, water:7, daysToMaturity:85},
    zucchini: {name:'Zucchini', type:'vegetable', icon:'ğŸ¥’', minTemp:65, maxTemp:85, water:7, daysToMaturity:50},
    cucumber: {name:'Cucumber', type:'vegetable', icon:'ğŸ¥’', minTemp:65, maxTemp:95, water:7, daysToMaturity:55},
    melon: {name:'Melon', type:'vegetable', icon:'ğŸˆ', minTemp:70, maxTemp:95, water:7, daysToMaturity:85},
    pumpkin: {name:'Pumpkin', type:'vegetable', icon:'ğŸƒ', minTemp:65, maxTemp:90, water:6, daysToMaturity:100},
    broccoli: {name:'Broccoli', type:'vegetable', icon:'ğŸ¥¦', minTemp:45, maxTemp:75, water:6, daysToMaturity:70},
    cabbage: {name:'Cabbage', type:'vegetable', icon:'ğŸ¥¬', minTemp:45, maxTemp:75, water:6, daysToMaturity:70},
    beets: {name:'Beets', type:'vegetable', icon:'ğŸ«•', minTemp:50, maxTemp:75, water:5, daysToMaturity:55},
    carrots: {name:'Carrots', type:'vegetable', icon:'ğŸ¥•', minTemp:50, maxTemp:80, water:5, daysToMaturity:70},
    radish: {name:'Radish', type:'vegetable', icon:'ğŸ¥¬', minTemp:45, maxTemp:75, water:5, daysToMaturity:25},
    chard: {name:'Swiss Chard', type:'vegetable', icon:'ğŸ¥¬', minTemp:50, maxTemp:75, water:6, daysToMaturity:55},
    onion: {name:'Onion', type:'vegetable', icon:'ğŸ§…', minTemp:45, maxTemp:80, water:5, daysToMaturity:100},
    leek: {name:'Leek', type:'vegetable', icon:'ğŸ§…', minTemp:40, maxTemp:75, water:6, daysToMaturity:90},
    potato: {name:'Potato', type:'vegetable', icon:'ğŸ¥”', minTemp:50, maxTemp:80, water:6, daysToMaturity:90},
    garlic: {name:'Garlic', type:'vegetable', icon:'ğŸ§„', minTemp:30, maxTemp:75, water:4, daysToMaturity:180},
    asparagus: {name:'Asparagus', type:'vegetable', icon:'ğŸŒ¿', minTemp:40, maxTemp:80, water:5, daysToMaturity:730},
    rhubarb: {name:'Rhubarb', type:'vegetable', icon:'ğŸŒ¿', minTemp:40, maxTemp:75, water:5, daysToMaturity:365},
    
    // Fruits
    strawberry: {name:'Strawberry', type:'fruit', icon:'ğŸ“', minTemp:50, maxTemp:80, water:6, daysToMaturity:90},
    blueberry: {name:'Blueberry', type:'fruit', icon:'ğŸ«', minTemp:40, maxTemp:85, water:7, daysToMaturity:730},
    
    // Herbs & Cover Crops
    microgreens: {name:'Microgreens', type:'herb', icon:'ğŸŒ±', minTemp:60, maxTemp:75, water:5, daysToMaturity:10},
    wheatgerm: {name:'Winter Wheat', type:'cover', icon:'ğŸŒ¾', minTemp:20, maxTemp:70, water:4, daysToMaturity:240},
    covercrop: {name:'Cover Crop', type:'cover', icon:'ğŸŒ¾', minTemp:40, maxTemp:75, water:4, daysToMaturity:60}
  };

  // Get current seasonal plants for store
  function getSeasonalPlants(month){
    const allPlants = Object.keys(PLANT_CATALOG);
    const monthData = PLANTING_CALENDAR[month];
    const seasonalPlants = [];
    
    // Parse plant names from planting calendar
    if(monthData && monthData.plant){
      monthData.plant.forEach(entry => {
        // Extract plant names from entries like "Sow (1-28): Tomatoes, peppers, eggplant"
        const match = entry.match(/:\s*(.+)$/);
        if(match){
          const plants = match[1].split(',').map(p => p.trim().toLowerCase());
          plants.forEach(p => {
            // Map common names to catalog keys
            const mapped = p
              .replace('tomatoes', 'tomato')
              .replace('peppers', 'pepper')
              .replace('eggplant', 'eggplant')
              .replace('peas', 'peas')
              .replace('lettuce', 'lettuce')
              .replace('spinach', 'spinach')
              .replace('kale', 'kale')
              .replace('beans', 'beans')
              .replace('corn', 'corn')
              .replace('squash', 'squash')
              .replace('zucchini', 'zucchini')
              .replace('cucumbers', 'cucumber')
              .replace('melons', 'melon')
              .replace('pumpkins', 'pumpkin')
              .replace('broccoli', 'broccoli')
              .replace('cabbage', 'cabbage')
              .replace('beets', 'beets')
              .replace('carrots', 'carrots')
              .replace('radishes', 'radish')
              .replace('swiss chard', 'chard')
              .replace('chard', 'chard')
              .replace('onions', 'onion')
              .replace('onion sets', 'onion')
              .replace('leeks', 'leek')
              .replace('potatoes', 'potato')
              .replace('garlic', 'garlic')
              .replace('asparagus', 'asparagus')
              .replace('rhubarb', 'rhubarb')
              .replace('strawberries', 'strawberry')
              .replace('blueberry', 'blueberry')
              .replace('microgreens', 'microgreens')
              .replace('wheat', 'wheatgerm')
              .replace('cover crops', 'covercrop');
            
            if(PLANT_CATALOG[mapped] && !seasonalPlants.find(x => x === mapped)){
              seasonalPlants.push(mapped);
            }
          });
        }
      });
    }
    return seasonalPlants.length > 0 ? seasonalPlants : ['lettuce','spinach','tomato','beans'];
  }
  
  // Update seasonal vegetables in store based on month
  function updateSeasonalStore(){
    const month = new Date().getMonth();
    const seasonalPlants = getSeasonalPlants(month);
    const veggieContainer = document.getElementById('seasonalVegetables');
    if(!veggieContainer) return;
    
    veggieContainer.innerHTML = seasonalPlants.map(key => {
      const plant = PLANT_CATALOG[key];
      if(!plant) return '';
      return `<div class="item" data-type="plant" data-subtype="${key}">
        <div class="item-icon">${plant.icon}</div>
        <div class="item-name">${plant.name}</div>
      </div>`;
    }).join('');
    
    // Reattach click handlers for newly added plants
    document.querySelectorAll('#seasonalVegetables .item').forEach(item => {
      item.addEventListener('click', () => {
        if(removeMode) return;
        document.querySelectorAll('.item').forEach(i => i.classList.remove('selected'));
        item.classList.add('selected');
        selectedType = 'plant';
        selectedSubtype = item.dataset.subtype;
        document.getElementById('selected').textContent = item.querySelector('.item-name').textContent;
      });
    });
  }
  updateSeasonalStore();
  setInterval(updateSeasonalStore, 60000); // Update every minute to catch month changes
  
  // Make plant functions accessible globally for debugging
  window.PLANT_CATALOG = PLANT_CATALOG;
  window.getSeasonalPlants = getSeasonalPlants;
  window.updateSeasonalStore = updateSeasonalStore;

  // Plant Health Display
  function calculatePlantHealth(plant) {
    const now = new Date();
    const currentMonth = now.getMonth();
    const temp = (window.weatherData && (window.weatherData.temperature_current || window.weatherData.temp)) || 70;
    const humidity = 65 + Math.sin(Date.now() / 10000) * 15; // Vary 50-80%
    
    // Temperature suitability score
    let tempScore = 1;
    if (temp < plant.minTemp || temp > plant.maxTemp) {
      const optimalRange = (plant.maxTemp - plant.minTemp) / 2 + plant.minTemp;
      const deviation = Math.abs(temp - optimalRange);
      tempScore = Math.max(0.3, 1 - (deviation / 20));
    }
    
    // Humidity suitability score
    let humidityScore = 1;
    if (humidity < 30 || humidity > 85) {
      const deviation = humidity < 30 ? (30 - humidity) : (humidity - 85);
      humidityScore = Math.max(0.4, 1 - (deviation / 30));
    }
    
    // Seasonal bonus/penalty
    const seasonalPlants = getSeasonalPlants(currentMonth);
    let seasonalBonus = seasonalPlants.includes(plant.name.toLowerCase().replace(/\s+/g, '')) || 
                        seasonalPlants.some(p => p.includes(plant.name.toLowerCase())) ? 1.2 : 0.7;
    
    // Combined health score (0-1)
    const healthScore = Math.min(1, tempScore * humidityScore * seasonalBonus);
    return {
      score: healthScore,
      tempScore: tempScore,
      humidityScore: humidityScore,
      seasonalBonus: seasonalBonus,
      isSeasonal: seasonalBonus > 1
    };
  }

  function updatePlantHealthDisplay() {
    const plantHealthContent = document.getElementById('plantHealthContent');
    const temp = (window.weatherData && (window.weatherData.temperature_current || window.weatherData.temp)) || 70;
    const humidity = 65 + Math.sin(Date.now() / 10000) * 15;
    
    // Get all plants and calculate their health
    const plantHealthData = Object.entries(PLANT_CATALOG).map(([key, plant]) => {
      const health = calculatePlantHealth(plant);
      return {
        key,
        ...plant,
        health
      };
    });
    
    // Sort by health score (best first)
    plantHealthData.sort((a, b) => b.health.score - a.health.score);
    
    // Current conditions summary
    let conditionsHTML = `<div style="background:rgba(0,150,180,0.2);padding:10px;border-radius:6px;margin-bottom:12px;font-size:11px;border:1px solid rgba(0,255,255,0.2)">
      <strong>Current Conditions:</strong><br>
      ğŸŒ¡ï¸ Temp: ${Math.round(temp)}Â°F | ğŸ’§ Humidity: ${Math.round(humidity)}%
    </div>`;
    
    // Get current month
    const now = new Date();
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    const currentMonth = monthNames[now.getMonth()];
    
    // Build health cards
    let cardsHTML = plantHealthData.map(p => {
      const health = p.health;
      const healthPercent = Math.round(health.score * 100);
      let healthClass = '';
      let healthText = '';
      
      if (healthPercent >= 85) {
        healthClass = 'health-excellent';
        healthText = 'Excellent';
      } else if (healthPercent >= 70) {
        healthClass = 'health-good';
        healthText = 'Good';
      } else if (healthPercent >= 50) {
        healthClass = 'health-fair';
        healthText = 'Fair';
      } else if (healthPercent >= 25) {
        healthClass = 'health-poor';
        healthText = 'Poor';
      } else {
        healthClass = 'health-critical';
        healthText = 'Critical';
      }
      
      const seasonalBadge = health.isSeasonal ? 
        `<span class="seasonal-badge">âœ“ In Season</span>` : 
        `<span class="seasonal-badge" style="background:rgba(255,100,100,0.2);border-color:#ff6666;color:#ff9999;">âœ— Out of Season</span>`;
      
      return `<div class="plant-health-item">
        <div class="plant-health-header">
          <div class="plant-health-icon">${p.icon}</div>
          <div class="plant-health-name">${p.name}</div>
          <div style="font-size:13px;color:#0cf;font-weight:bold;">${healthPercent}%</div>
        </div>
        <div class="health-bar">
          <div class="health-fill ${healthClass}" style="width:${healthPercent}%">
            <span style="display:${healthPercent > 40 ? 'inline' : 'none'}">${healthText}</span>
          </div>
        </div>
        <div class="plant-health-status">
          ğŸŒ¡ï¸ Ideal: ${p.minTemp}â€“${p.maxTemp}Â°F | Current: ${Math.round(temp)}Â°F<br>
          ğŸ’§ Prefers: ~65% humidity | Current: ${Math.round(humidity)}%<br>
          ${seasonalBadge}
        </div>
      </div>`;
    }).join('');
    
    plantHealthContent.innerHTML = conditionsHTML + cardsHTML;
  }

  // Update plant health display when weather updates
  updatePlantHealthDisplay(); // Initial update
  setInterval(updatePlantHealthDisplay, 30000); // Update every 30 seconds

  // UI button wiring: show/hide panels on demand
  function positionUnderClock(el){
    if(!clockBtn) return;
    const r = clockBtn.getBoundingClientRect();
    // ensure we can measure width even if hidden: show invisibly to measure
    const prevDisplay = el.style.display;
    const prevVis = el.style.visibility;
    el.style.display = 'block';
    el.style.visibility = 'hidden';
    const panelW = el.offsetWidth || 260;
    // prefer left aligned with clock; ensure panel stays inside viewport
    const left = Math.max(8, Math.min(window.innerWidth - panelW - 8, r.left));
    const top = Math.min(window.innerHeight - 40, r.bottom + 6);
    el.style.left = left + 'px';
    el.style.top = top + 'px';
    el.style.right = 'auto';
    el.style.position = 'fixed';
    el.style.visibility = prevVis || '';
    el.style.display = prevDisplay || 'none';
  }

  if(forecastBtn){
    forecastBtn.addEventListener('click', ()=>{
      const open = forecastPanel.style.display !== 'block';
      if(open){
        positionUnderClock(forecastPanel);
        forecastPanel.style.display = 'block';
        moonCalendar.style.display='none';
        if(birdGuideModal) birdGuideModal.style.display='none';
        if(fishGuideModal) fishGuideModal.style.display='none';
        updateForecast();
      }else{
        forecastPanel.style.display = 'none';
      }
    });
  }

  // Plant Health Button
  const plantHealthBtn = document.getElementById('plantHealthBtn');
  const plantHealthPanel = document.getElementById('plantHealthPanel');
  if(plantHealthBtn && plantHealthPanel) {
    plantHealthBtn.addEventListener('click', ()=>{
      const open = plantHealthPanel.classList.contains('visible');
      if(!open){
        updatePlantHealthDisplay();
        plantHealthPanel.classList.add('visible');
        forecastPanel.style.display='none';
        moonCalendar.style.display='none';
        if(birdGuideModal) birdGuideModal.style.display='none';
        if(fishGuideModal) fishGuideModal.style.display='none';
      }else{
        plantHealthPanel.classList.remove('visible');
      }
    });
  }

  if(moonBtn){
    moonBtn.addEventListener('click', ()=>{
      const open = moonCalendar.style.display !== 'block';
      if(open){
        moonCalendar.style.display = 'block';
        forecastPanel.style.display='none';
        if(birdGuideModal) birdGuideModal.style.display='none';
        if(fishGuideModal) fishGuideModal.style.display='none';
        buildMoonGrid();
      }else{
        moonCalendar.style.display = 'none';
      }
    });
  }
  // Close modals when clicking outside
  document.addEventListener('click', (e)=>{
    const plantHealthPanel = document.getElementById('plantHealthPanel');
    const settingsModal = document.getElementById('settingsModal');
    const settingsBtn = document.getElementById('settingsBtn');
    const plantHealthBtn = document.getElementById('plantHealthBtn');
    
    if(plantHealthPanel && plantHealthPanel.classList.contains('visible')){
      if(!plantHealthPanel.contains(e.target) && e.target !== plantHealthBtn && !plantHealthBtn.contains(e.target)){
        plantHealthPanel.classList.remove('visible');
      }
    }
    
    if(settingsModal && settingsModal.classList.contains('visible')){
      if(!settingsModal.contains(e.target) && e.target !== settingsBtn && !settingsBtn.contains(e.target)){
        settingsModal.classList.remove('visible');
      }
    }
  });

  // Bird guide is accessible from Settings 'Open Bird Guide' button
  if(settingsBtn){
    settingsBtn.addEventListener('click', ()=>{
      const settingsModal = document.getElementById('settingsModal');
      if(settingsModal) settingsModal.classList.toggle('visible');
      // Update button states when opening settings
      if(settingsModal && settingsModal.classList.contains('visible')){
        updateSoundButtonStates();
      }
    });
  }
  
  // Quick Actions button
  const quickActionsBtn = document.getElementById('quickActionsBtn');
  if(quickActionsBtn){
    quickActionsBtn.addEventListener('click', ()=>{
      const quickActionsModal = document.getElementById('quickActionsModal');
      if(quickActionsModal) quickActionsModal.classList.toggle('visible');
    });
  }
  
  function updateSoundButtonStates(){
    const toggleOwlBtn = document.getElementById('toggleOwlBtn');
    const toggleFishSplashBtn = document.getElementById('toggleFishSplashBtn');
    const toggleFishEatingBtn = document.getElementById('toggleFishEatingBtn');
    const toggleFishJumpingBtn = document.getElementById('toggleFishJumpingBtn');
    const toggleBatsBtn = document.getElementById('toggleBatsBtn');
    const toggleAmbienceBtn = document.getElementById('toggleAmbienceBtn');
    const toggleCrowsBtn = document.getElementById('toggleCrowsBtn');
    
    if(toggleOwlBtn){
      toggleOwlBtn.textContent = muteOwl ? 'ğŸ¦‰ Owl: OFF' : 'ğŸ¦‰ Owl: ON';
      toggleOwlBtn.classList.toggle('active', !muteOwl);
    }
    if(toggleFishSplashBtn){
      toggleFishSplashBtn.textContent = muteFishSplashes ? 'ğŸ’¦ Fish Splash: OFF' : 'ğŸ’¦ Fish Splash: ON';
      toggleFishSplashBtn.classList.toggle('active', !muteFishSplashes);
    }
    if(toggleFishEatingBtn){
      toggleFishEatingBtn.textContent = muteFishEating ? 'ğŸŸ Fish Eating: OFF' : 'ğŸŸ Fish Eating: ON';
      toggleFishEatingBtn.classList.toggle('active', !muteFishEating);
    }
    if(toggleFishJumpingBtn){
      toggleFishJumpingBtn.textContent = muteFishJumping ? 'ğŸ£ Fish Jumping: OFF' : 'ğŸ£ Fish Jumping: ON';
      toggleFishJumpingBtn.classList.toggle('active', !muteFishJumping);
    }
    if(toggleBatsBtn){
      toggleBatsBtn.textContent = muteBats ? 'ğŸ¦‡ Bats: OFF' : 'ğŸ¦‡ Bats: ON';
      toggleBatsBtn.classList.toggle('active', !muteBats);
    }
    if(toggleAmbienceBtn){
      toggleAmbienceBtn.textContent = muteAmbience ? 'ğŸµ Ambience: OFF' : 'ğŸµ Ambience: ON';
      toggleAmbienceBtn.classList.toggle('active', !muteAmbience);
    }
    if(toggleCrowsBtn){
      toggleCrowsBtn.textContent = muteCrows ? 'ğŸ¦ Crows: OFF' : 'ğŸ¦ Crows: ON';
      toggleCrowsBtn.classList.toggle('active', !muteCrows);
    }
  }
  if(openBirdGuideBtn){
    openBirdGuideBtn.addEventListener('click', ()=>{
      try{ openBirdGuide(); }catch(e){ if(window.openBirdGuide) window.openBirdGuide(); }
      settingsModal.classList.remove('visible');
      document.getElementById('quickActionsModal').classList.remove('visible');
    });
  }
  if(openFishGuideBtn){
    openFishGuideBtn.addEventListener('click', ()=>{
      try{ openFishGuide(); }catch(e){ if(window.openFishGuide) window.openFishGuide(); }
      settingsModal.classList.remove('visible');
      document.getElementById('quickActionsModal').classList.remove('visible');
    });
  }
  if(openTreeGuideBtn){
    openTreeGuideBtn.addEventListener('click', ()=>{
      try{ openTreeGuide(); }catch(e){ if(window.openTreeGuide) window.openTreeGuide(); }
      settingsModal.classList.remove('visible');
      document.getElementById('quickActionsModal').classList.remove('visible');
    });
  }

  // settings modal controls: accessibility toggles and sharing
  const reduceMotionCheckbox = document.getElementById('reduceMotionCheckbox');
  const highContrastCheckbox = document.getElementById('highContrastCheckbox');
  const largeTextCheckbox = document.getElementById('largeTextCheckbox');
  if(reduceMotionCheckbox){ reduceMotionCheckbox.addEventListener('change', ()=>{ document.body.classList.toggle('reduce-motion', reduceMotionCheckbox.checked); }); }
  if(highContrastCheckbox){ highContrastCheckbox.addEventListener('change', ()=>{ document.body.classList.toggle('high-contrast', highContrastCheckbox.checked); }); }
  if(largeTextCheckbox){ largeTextCheckbox.addEventListener('change', ()=>{ document.body.classList.toggle('large-text', largeTextCheckbox.checked); }); }

  window.shareScene = function(){
    const title = document.title || 'Nature Scene';
    const text = `Check out this scene: ${LOCATION_NAME}`;
    if(navigator.share){ navigator.share({title,text,url:location.href}).catch(()=>{}); }
    else{ copyShareLink(); alert('Share link copied to clipboard'); }
  }
  window.copyShareLink = function(){ navigator.clipboard && navigator.clipboard.writeText(location.href); }
  // Bird guide modal content (simple, derived from in-game bird types)
  function openBirdGuide(){
    const birdArray = Array.isArray(window.birds) ? window.birds : [];
    const types = Array.from(new Set(birdArray.map(b=>b.type||'Unknown')));
    if(!types.length) types.push('cardinal','sparrow','robin','crow');
    const descriptions = {
      'robin':'Small red-breasted songbird often found on lawns. Eats worms and insects.',
      'crow':'Large omnivorous bird, black plumage, loud caws. Highly social and intelligent.',
      'cardinal':'West Virginia\'s State Bird! Males are vivid red with a crest; females are tan/olive with red accents. Found in woodlands, gardens, and thickets year-round.',
      'sparrow':'Small brownish bird; often found near human habitation.'
    };
    const birdImages = {
      robin:{src:'images/birds/robin.jpg', fallback:'./WestVirginia game data/robin.jpg'},
      crow:{src:'images/birds/crow.jpg', fallback:'./WestVirginia game data/crow.jpg'},
      cardinal:{src:'images/birds/cardinals.jpg', fallback:'./WestVirginia game data/cardinals.jpg'},
      sparrow:{src:'images/birds/sparrow.jpg', fallback:'./WestVirginia game data/sparrow.jpg'}
    };
    if(birdGuideContent) {
      birdGuideContent.innerHTML = types.map(t=>{
        const imgInfo = birdImages[t];
        const imgTag = imgInfo ? `<img src="${imgInfo.src}" data-fallback="${imgInfo.fallback}" alt="${t}" style="width:100%;max-width:200px;border-radius:6px;display:block;margin:6px 0" onerror="if(this.dataset.fallback){this.src=this.dataset.fallback;this.dataset.fallback='';}else{this.style.display='none';}">` : '';
        return `<div style="margin-bottom:12px"><strong style="color:#0ff">${t}</strong>${imgTag}<div style="font-size:12px;color:#dfe8ff">${descriptions[t]||'A local bird species.'}</div></div>`;
      }).join('');
    }
    birdGuideModal.style.display='block';
  }
  // expose to global so external handlers won't fail
  try{ window.openBirdGuide = openBirdGuide; }catch(e){}
  
  function openFishGuide(){
    const fishArray = Array.isArray(window.fish) ? window.fish : [];
    const types = Array.from(new Set(fishArray.map(f=>f.type||'Unknown')));
    if(!types.length) types.push('bluegill','bass','trout','catfish');
    const descriptions = {
      'bluegill':'A popular panfish with distinctive blue coloring on gill covers. Found in lakes and ponds.',
      'bass':'Largemouth or smallmouth bass. Prized gamefish known for aggressive strikes and fighting ability.',
      'trout':'Brook, brown, or rainbow trout. Cold-water fish found in West Virginia streams and rivers.',
      'catfish':'Bottom-feeding fish with distinctive whisker-like barbels. Common in rivers and lakes.'
    };
    const fishImages = {
      bluegill:{src:'images/fish/blue-gill.jpg', fallback:'./WestVirginia game data/blue-gill.jpg'},
      bass:{src:'images/fish/bass.jpg', fallback:'./WestVirginia game data/bass.jpg'},
      trout:{src:'images/fish/trout.jpg', fallback:'./WestVirginia game data/trout.jpg'},
      catfish:{src:'images/fish/catfish.jpg', fallback:'./WestVirginia game data/catfish.jpg'}
    };
    if(fishGuideContent) {
      fishGuideContent.innerHTML = types.map(t=>{
        const imgInfo = fishImages[t];
        const imgTag = imgInfo ? `<img src="${imgInfo.src}" data-fallback="${imgInfo.fallback}" alt="${t}" style="width:100%;max-width:200px;border-radius:6px;display:block;margin:6px 0" onerror="if(this.dataset.fallback){this.src=this.dataset.fallback;this.dataset.fallback='';}else{this.style.display='none';}">` : '';
        return `<div style="margin-bottom:12px"><strong style="color:#0ff">${t}</strong>${imgTag}<div style="font-size:12px;color:#dfe8ff">${descriptions[t]||'A local fish species.'}</div></div>`;
      }).join('');
    }
    fishGuideModal.style.display='block';
  }
  // expose to global so external handlers won't fail
  try{ window.openFishGuide = openFishGuide; }catch(e){}
  
  function openTreeGuide(){
    const types = ['oak', 'pine', 'willow', 'maple', 'birch', 'beech', 'basswood', 'laurel', 'walnut', 'hickory', 'chestnut', 'poplar', 'sycamore'];
    const descriptions = {
      'oak': 'Sturdy hardwood tree with lobed leaves. Produces acorns and has strong, durable wood. Common throughout West Virginia forests.',
      'pine': 'Evergreen conifer with needle-like leaves. Stays green year-round. Fast-growing and produces pinecones.',
      'willow': 'Graceful tree with drooping branches and narrow leaves. Often found near water. Known for its flexibility and medicinal properties.',
      'maple': 'Deciduous tree famous for brilliant fall colors and sweet sap. Produces distinctive winged seeds called samaras.',
      'birch': 'Distinguished by white, papery bark that peels in layers. Slender tree with delicate leaves that turn golden in fall.',
      'beech': 'Smooth gray bark and oval leaves. Produces small triangular nuts. Wood is strong and used for furniture.',
      'basswood': 'Also called American Linden. Heart-shaped leaves and fragrant flowers. Soft wood popular for carving.',
      'laurel': 'Evergreen shrub or small tree. Dense foliage stays green year-round. Native to Appalachian mountains.',
      'walnut': 'Valuable hardwood tree producing edible nuts. Dark brown wood prized for furniture. Compound leaves with many leaflets.',
      'hickory': 'Strong hardwood tree with compound leaves. Produces edible nuts. Wood is extremely tough and used for tool handles.',
      'chestnut': 'Once dominant tree in Appalachia. Produces sweet, edible nuts in spiny burrs. American chestnut nearly extinct due to blight.',
      'poplar': 'Also called tulip tree. Tall, fast-growing with distinctive tulip-shaped flowers. Soft wood used in construction.',
      'sycamore': 'Large tree with distinctive mottled bark that flakes off in patches. Big maple-like leaves and round seed balls.'
    };
    const treeImageCandidates = (name) => {
      const baseName = name.toLowerCase();
      return [
        `./WestVirginia game data/${baseName}.jpg`,
        `./WestVirginia game data/${baseName}.png`,
        `./WestVirginia game data/${baseName}.jpeg`,
        `./WestVirginia game data/${baseName}.webp`,
        `./WestVirginia game data/trees/${baseName}.jpg`,
        `./WestVirginia game data/trees/${baseName}.png`,
        `./WestVirginia game data/trees/${baseName}.jpeg`,
        `./WestVirginia game data/trees/${baseName}.webp`,
        `images/trees/${baseName}.jpg`,
        `images/trees/${baseName}.png`,
        `images/trees/${baseName}.jpeg`,
        `images/trees/${baseName}.webp`
      ];
    };
    if(treeGuideContent) {
      treeGuideContent.innerHTML = types.map(t=>{
        const [primary, ...fallbacks] = treeImageCandidates(t);
        const imgTag = `<img src="${primary}" data-fallbacks="${fallbacks.join('|')}" alt="${t}" style="width:100%;max-width:200px;border-radius:6px;display:block;margin:6px 0" onerror="(function(img){const list=(img.dataset.fallbacks||'').split('|').filter(Boolean); if(!list.length){img.style.display='none';return;} const next=list.shift(); img.dataset.fallbacks=list.join('|'); img.src=next;})(this)">`;
        return `<div style="margin-bottom:12px"><strong style="color:#0ff">${t.charAt(0).toUpperCase() + t.slice(1)}</strong>${imgTag}<div style="font-size:12px;color:#dfe8ff">${descriptions[t]||'A native tree species.'}</div></div>`;
      }).join('');
    }
    treeGuideModal.style.display='block';
  }
  // expose to global so external handlers won't fail
  try{ window.openTreeGuide = openTreeGuide; }catch(e){}
  // birdGuideBtn removed; Settings button calls openBirdGuide()

  // Moon phases calendar for current month
  function moonPhase(date){
    const synodic = 29.530588853;
    const knownNew = Date.UTC(2000,0,6,18,14);
    const d = Date.UTC(date.getFullYear(),date.getMonth(),date.getDate());
    const days = (d - knownNew)/86400000;
    let age = (days % synodic + synodic) % synodic;
    const phaseIndex = Math.floor((age/synodic)*8 + 0.5) % 8;
    const names = ['New','Waxing Crescent','First Quarter','Waxing Gibbous','Full','Waning Gibbous','Last Quarter','Waning Crescent'];
    const illum = Math.round((1 - Math.cos(2*Math.PI*age/synodic))/2*100);
    return {phase:names[phaseIndex],illum,age};
  }

  function getFishingActivity(phase, temp, month){
    // Best fishing: new/full moon, dawn/dusk, moderate temps
    const phaseScore = (phase==='New' || phase==='Full') ? 'Excellent' : 
                       (phase==='First Quarter' || phase==='Last Quarter') ? 'Good' : 'Fair';
    const tempScore = (temp>=55 && temp<=75) ? 'optimal temps' : 
                      (temp>=45 && temp<55) ? 'cool water' : 
                      (temp>75) ? 'warm water - fish deep' : 'cold water - slow';
    const seasonTip = (month>=4 && month<=6) ? 'Spawning season - catch & release' :
                      (month>=6 && month<=8) ? 'Peak summer fishing' :
                      (month>=9 && month<=10) ? 'Fall feeding frenzy' : 'Winter - ice fishing';
    return {rating:phaseScore, condition:tempScore, tip:seasonTip};
  }

  function buildMoonGrid(){
    moonGrid.innerHTML='';
    const today = new Date();
    const year = today.getFullYear(), month = today.getMonth();
    const first = new Date(year,month,1);
    const startDay = (first.getDay()+6)%7; // Monday-first adjust
    const daysInMonth = new Date(year,month+1,0).getDate();
    
    // Current month almanac advice
    const cal = PLANTING_CALENDAR[month];
    const seasonName = ['Winter','Winter','Spring','Spring','Spring','Summer','Summer','Summer','Fall','Fall','Fall','Winter'][month];
    almanacAdvice.innerHTML = `<strong>ğŸŒ± ${seasonName} Guidance (${new Date(year,month,1).toLocaleString('default',{month:'long'})})</strong><br>
      <strong>Plant:</strong> ${cal.plant.join(', ')}<br>
      <strong>Harvest:</strong> ${cal.harvest.join(', ')}<br>
      <strong>Activity:</strong> ${cal.activity}`;
    
    // blank cells
    for(let i=0;i<startDay;i++) moonGrid.appendChild(Object.assign(document.createElement('div'),{className:'moonCell',innerHTML:''}));
    
    // Month number for meteor shower checks
    const mm = month+1;
    
    // Build calendar with moon phases and almanac icons
    for(let d=1; d<=daysInMonth; d++){
      const cell = document.createElement('div'); cell.className='moonCell';
      const cellDate = new Date(year,month,d);
      const info = moonPhase(cellDate);
      const isToday = (d === today.getDate() && month === today.getMonth());
      
      // Add planting/harvesting icons based on moon phase
      let icon = '';
      if(info.phase === 'New Moon' || info.phase === 'First Quarter') icon = 'ğŸŒ±'; // Good for above-ground crops
      else if(info.phase === 'Full Moon' || info.phase === 'Last Quarter') icon = 'ğŸ¥•'; // Good for root crops
      
      // Check for meteor showers on this date
      const meteorDay = METEOR_SHOWERS.find(m => m.month === mm && m.day === d);
      if(meteorDay) icon += 'â­';
      
      // Check fishing quality (best on new/full moon)
      let fishIcon = '';
      if(info.phase === 'New' || info.phase === 'Full') fishIcon = 'ğŸ£';
      
      const highlight = isToday ? 'background:rgba(100,200,100,0.3);border:1px solid #4f8;' : '';
      cell.innerHTML = `<div style="font-weight:600;${highlight}">${d} ${icon}${fishIcon}</div><div style="font-size:9px">${info.phase}</div><div style="font-size:9px;color:#bfe">${info.illum}%</div>`;
      moonGrid.appendChild(cell);
    }
    
    // Meteor showers
    const upcoming = METEOR_SHOWERS.filter(m=>m.month===mm);
    meteorList.innerHTML = upcoming.length ? '<strong>â­ Meteor Showers:</strong><div>'+upcoming.map(u=>`${u.name} â€” ${u.month}/${u.day}`).join('<br>')+'</div>' : '<em>No major showers this month</em>';
    
    // Fishing forecast based on current conditions
    const currentInfo = moonPhase(today);
    const temp = (window.weatherData && (window.weatherData.temperature_current || window.weatherData.temp)) || 65;
    const fishing = getFishingActivity(currentInfo.phase, temp, month);
    
    // Find best fishing days this month (new/full moon dates)
    const bestFishingDays = [];
    for(let d=1; d<=daysInMonth; d++){
      const info = moonPhase(new Date(year,month,d));
      if(info.phase === 'New' || info.phase === 'Full'){
        bestFishingDays.push(`${d} (${info.phase} Moon)`);
      }
    }
    const fishDaysList = bestFishingDays.length > 0 ? bestFishingDays.join(', ') : 'No new/full moons this period';
    
    fishingForecast.innerHTML = `<strong>ğŸ£ Fishing Forecast</strong><br>
      <strong>Current Conditions:</strong> ${fishing.rating} (${currentInfo.phase})<br>
      <strong>Water Temp:</strong> ${fishing.condition}<br>
      <strong>Season Tip:</strong> ${fishing.tip}<br>
      <strong>Best Days This Month:</strong> ${fishDaysList}<br>
      <em>Best times: Dawn (6-9am) and Dusk (5-8pm)</em>`;
    
    // Update store with new seasonal plants
    if(typeof updateSeasonalStore !== 'undefined') updateSeasonalStore();
  }
  buildMoonGrid();

    // small helper: slightly darken or lighten a hex color (#rrggbb)
    function shadeColor(hex, percent) {
      try{
        const h = hex.replace('#','');
        const r = parseInt(h.substring(0,2),16);
        const g = parseInt(h.substring(2,4),16);
        const b = parseInt(h.substring(4,6),16);
        const t = percent<0?0:255;
        const p = Math.abs(percent)/100;
        const R = Math.round((t - r)*p) + r;
        const G = Math.round((t - g)*p) + g;
        const B = Math.round((t - b)*p) + b;
        return '#'+((1<<24) + (R<<16) + (G<<8) + B).toString(16).slice(1);
      }catch(e){return hex}
    }

  // Seasonal overlays: ice on river (winter) and spring blooms
  function updateSeasonals(){
    const now = new Date();
    const month = now.getMonth()+1;
    const temp = (window.weatherData && (window.weatherData.temperature_current || window.weatherData.temp)) || 2;
    // show ice overlay in deep winter when temp <= 0 and month in Dec/Jan/Feb
    if((month===12 || month===1 || month===2) && temp <= 0){
      iceOverlay.style.display='block';
    }else{ iceOverlay.style.display='none'; }
    // spring blooms: months 3-5 -> spawn a few petals
    if(month>=3 && month<=5){
      const count = 12;
      for(let i=0;i<count;i++){ 
        const p = document.createElement('div'); p.className='bloomPetal';
        p.style.left = Math.random()*100 + '%'; p.style.top = (70 + Math.random()*22)+'%';
        p.style.background = 'pink'; p.style.transform = 'rotate('+Math.random()*360+'deg)';
        document.body.appendChild(p);
        setTimeout(()=>{ p.style.transition='transform 6s linear, top 6s linear, opacity 6s linear'; p.style.top = (80+Math.random()*15)+'%'; p.style.opacity='0'; },50);
        setTimeout(()=>p.remove(),7000);
      }
    }
  }
  updateSeasonals();
  setInterval(updateSeasonals, 5*60*1000);

})();
</script>

<script>
// Bats: spawn at dusk/dawn and simple flight
(function(){
  function spawnBat(){
    if(bats.length > 30) return;
    const dir = Math.random() < 0.5 ? 1 : -1;
    bats.push({
      x: dir>0? -30: W+30,
      y: H*0.25 + Math.random()*H*0.25,
      vx: dir * (1 + Math.random()*2),
      vy: (Math.random()-0.5) * 0.15,
      wing: Math.random()*6,
      size: 8 + Math.random()*6,
      life: 400 + Math.random()*400,
      state: 'flying_to_center', // New states: flying_to_center, hunting, flying_away
      huntTimer: 0,
      huntDuration: 180, // 3 seconds at 60fps
      huntCenterX: W / 2,
      huntCenterY: H * 0.35,
      huntRadius: 80,
      huntAngle: Math.random() * Math.PI * 2
    });
  }

  function updateAndDrawBats(ctx){
    // Hide all bat images first
    document.querySelectorAll('[data-bat-element]').forEach(el => el.style.display = 'none');
    
    for(let i = bats.length -1; i >= 0; i--){
      const b = bats[i];
      b.wing += 0.9 + Math.abs(b.vx)*0.05;
      
      // State machine for bat behavior
      if(b.state === 'flying_to_center'){
        // Fly toward center of screen
        const dx = b.huntCenterX - b.x;
        const dy = b.huntCenterY - b.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if(dist < 20){
          // Reached center, start hunting
          b.state = 'hunting';
          b.huntTimer = 0;
        } else {
          // Continue toward center
          b.vx = (dx / dist) * 2;
          b.vy = (dy / dist) * 2;
          b.x += b.vx;
          b.y += b.vy + Math.sin(b.wing*2.2) * 0.4;
        }
      } else if(b.state === 'hunting'){
        // Fly in erratic patterns around center catching bugs
        b.huntTimer++;
        b.huntAngle += 0.15 + Math.random() * 0.1;
        
        // Erratic movement around center
        const radiusVariation = Math.sin(b.huntTimer * 0.1) * 30;
        const targetX = b.huntCenterX + Math.cos(b.huntAngle) * (b.huntRadius + radiusVariation);
        const targetY = b.huntCenterY + Math.sin(b.huntAngle * 1.3) * (b.huntRadius * 0.6 + radiusVariation);
        
        b.vx = (targetX - b.x) * 0.15;
        b.vy = (targetY - b.y) * 0.15;
        b.x += b.vx;
        b.y += b.vy + Math.sin(b.wing*2.2) * 0.6;
        
        if(b.huntTimer >= b.huntDuration){
          // Done hunting, fly away
          b.state = 'flying_away';
          b.vx = (Math.random() < 0.5 ? -2 : 2) * (1 + Math.random());
          b.vy = -0.5 - Math.random() * 0.5; // Fly upward
        }
      } else if(b.state === 'flying_away'){
        // Fly off screen
        b.x += b.vx;
        b.y += b.vy + Math.sin(b.wing*2.2) * 0.4;
      }
      
      b.life -= 1;
      
      // Create or reuse bat HTML element for animation
      if(!b.element){
        b.element = document.createElement('img');
        b.element.src = batImg.src;
        b.element.style.position = 'fixed';
        b.element.style.zIndex = '50';
        b.element.style.pointerEvents = 'none';
        b.element.setAttribute('data-bat-element', 'true');
        document.body.appendChild(b.element);
      }
      
      // Position bat element
      b.element.style.display = 'block';
      b.element.style.left = (b.x - b.size) + 'px';
      b.element.style.top = (b.y - b.size) + 'px';
      b.element.style.width = (b.size * 2) + 'px';
      b.element.style.height = (b.size * 2) + 'px';
      b.element.style.transform = b.vx < 0 ? 'scaleX(-1)' : 'scaleX(1)';
      b.element.style.opacity = '0.9';
      
      // remove offscreen or dead
      if(b.x < -200 || b.x > W+200 || b.y < -200 || b.life <= 0){
        if(b.element){
          b.element.remove();
        }
        bats.splice(i,1);
      }
    }
  }

  // integrate into main loop by patching draw() end: we'll call from draw() via a global hook
  window._updateAndDrawBats = updateAndDrawBats;
  window._spawnBat = spawnBat;
})();
</script>

<script>
// Deer animation system: walks from right to left, stops mid-screen, idles, then continues
(function(){
  const DEER_SIZE = 140; // fixed deer size per user preference
  const DEER_WALK_SPEED = 1.5;
  const DEER_IDLE_MS = 5500; // Time to play full idle animation
  const MAX_DEER_EVENTS_PER_DAY = 3;
  
  function scheduleDeerEvents(){
    const now = new Date();
    const currentDay = now.toDateString();
    
    // Reset daily counter if it's a new day
    if(!window.lastDeerDay || window.lastDeerDay !== currentDay){
      window.lastDeerDay = currentDay;
      deerEventsToday = 0;
      deerEvents = [];
      
      // Schedule deer during early morning (8-10am) and evening (6-8pm)
      for(let i = 0; i < MAX_DEER_EVENTS_PER_DAY; i++){
        let hour;
        if(i < MAX_DEER_EVENTS_PER_DAY / 2){
          // Morning deer: 8-10am
          hour = 8 + Math.random() * 2;
        }else{
          // Evening deer: 6-8pm
          hour = 18 + Math.random() * 2;
        }
        const minute = Math.random() * 60;
        const eventTime = new Date(now);
        eventTime.setHours(Math.floor(hour), Math.floor(minute), 0, 0);
        // If event is in the past today, schedule for next occurrence
        if(eventTime < now){
          eventTime.setTime(now.getTime() + (Math.random() * 3600000)); // Within next hour
        }
        deerEvents.push({time: eventTime, triggered: false});
      }
      deerEvents.sort((a, b) => a.time - b.time);
      console.log('Deer events scheduled:', deerEvents.map(e => e.time.toLocaleTimeString()));
    }
  }
  
  function checkDeerEvents(){
    if(!deerEvents.length) return;
    
    const now = new Date();
    
    for(let event of deerEvents){
      if(!event.triggered && now >= event.time){
        event.triggered = true;
        console.log('Spawning deer from scheduled event');
        spawnDeer();
        break;
      }
    }
  }
  
  function spawnDeer(){
    if(deer) {
      console.log('Deer already active, skipping spawn');
      return; // Already have a deer
    }
    
    const terrainY = getTerrainY(W * 0.8);
    deer = {
      x: W + 100, // Start off-screen right
      y: terrainY - (DEER_SIZE * 0.5), // Position deer lower on terrain
      state: 'walking', // walking, idle, walking_out
      idleTimer: 0,
      targetX: -DEER_SIZE, // Traverse entire screen and exit left
      idleStops: [], // Random idle positions
      idleCount: 0
    };
    // Generate 4 random stop positions across the full journey (with final stop near exit)
    const startX = deer.x;
    const endX = deer.targetX;
    deer.idleStops = [
      startX - (Math.random() * 0.05 + 0.30) * (startX - endX),  // ~30-35% of journey
      startX - (Math.random() * 0.05 + 0.55) * (startX - endX),  // ~55-60% of journey
      startX - (Math.random() * 0.04 + 0.75) * (startX - endX),  // ~75-79% of journey
      startX - (Math.random() * 0.03 + 0.92) * (startX - endX)   // ~92-95% of journey (just before exit)
    ].sort((a, b) => b - a); // Sort descending so we hit them in order
    console.log('Deer spawned! Position:', deer.x, deer.y, 'TerrainY:', terrainY, 'Size:', DEER_SIZE, 'Idle stops at:', deer.idleStops, 'Images loaded:', deerWalkImg.complete, deerIdleImg.complete);
  }
  
  function updateAndDrawDeer(ctx){
    if(!deer) return;
    
    const terrainY = getTerrainY(deer.x);
    deer.y = terrainY - (DEER_SIZE * 0.5); // Keep deer lower on terrain
    
    if(deer.state === 'walking'){
      deer.x -= DEER_WALK_SPEED;
      
      // Check if we've reached an idle stop
      if(deer.idleStops && deer.idleStops.length > 0 && deer.x <= deer.idleStops[0]){
        deer.state = 'idle';
        deer.idleStart = performance.now();
        deer.idleStops.shift(); // Remove this stop
        deer.idleCount++;
      }
      // Reached final target, done walking
      else if(deer.x <= deer.targetX){
        deer.state = 'walking_out';
      }
      
      // Show walking deer GIF
      deerWalkImg.style.display = 'block';
      deerWalkImg.style.left = deer.x + 'px';
      deerWalkImg.style.top = deer.y + 'px';
      deerWalkImg.style.width = (DEER_SIZE * 1.5) + 'px';
      deerWalkImg.style.height = DEER_SIZE + 'px';
      deerIdleImg.style.display = 'none';
    }else if(deer.state === 'idle'){
      // Stay idle until GIF assumed duration elapses, then resume walking
      const idleElapsed = performance.now() - (deer.idleStart || performance.now());
      if(idleElapsed >= DEER_IDLE_MS){
        deer.state = 'walking'; // Resume walking to next stop or exit
      }
      
      // Show idle deer GIF
      deerIdleImg.style.display = 'block';
      deerIdleImg.style.left = deer.x + 'px';
      deerIdleImg.style.top = deer.y + 'px';
      deerIdleImg.style.width = (DEER_SIZE * 1.5) + 'px';
      deerIdleImg.style.height = DEER_SIZE + 'px';
      deerWalkImg.style.display = 'none';
    }else if(deer.state === 'walking_out'){
      deer.x -= DEER_WALK_SPEED;
      
      // Remove deer when fully off-screen
      if(deer.x < -DEER_SIZE){
        deer = null;
        deerEventsToday++;
        return;
      }
      
      // Show walking deer GIF
      deerWalkImg.style.display = 'block';
      deerWalkImg.style.left = deer.x + 'px';
      deerWalkImg.style.top = deer.y + 'px';
      deerWalkImg.style.width = (DEER_SIZE * 1.5) + 'px';
      deerWalkImg.style.height = DEER_SIZE + 'px';
      deerIdleImg.style.display = 'none';
    }
  }
  
  // Hide deer GIFs when no deer (runs at init time with safety check)
  function hideDeerIfNeeded(){
    if(typeof deer !== 'undefined' && !deer){
      if(typeof deerWalkImg !== 'undefined' && deerWalkImg) deerWalkImg.style.display = 'none';
      if(typeof deerIdleImg !== 'undefined' && deerIdleImg) deerIdleImg.style.display = 'none';
    }
  }
  
  // Schedule events on load
  scheduleDeerEvents();
  
  // Export functions
  window._updateAndDrawDeer = updateAndDrawDeer;
  window._checkDeerEvents = checkDeerEvents;
  window._scheduleDeerEvents = scheduleDeerEvents;
  window._spawnDeer = spawnDeer;
  
  console.log('Deer system initialized. Functions exported:', {
    updateAndDrawDeer: typeof window._updateAndDrawDeer,
    checkDeerEvents: typeof window._checkDeerEvents,
    scheduleDeerEvents: typeof window._scheduleDeerEvents,
    spawnDeer: typeof window._spawnDeer
  });
})();
</script>

<script>
// Bunny animation system: hops from left to right, stops to scratch at random spots
(function(){
  const BUNNY_SIZE = 100; // bunny base size
  const BUNNY_HOP_SPEED = 1.0; // Slowed down movement
  const BUNNY_SCRATCH_MS = 4000; // Time to play scratch animation
  const BUNNY_SIZE_MULTIPLIER = 0.4; // Fixed at 40%
  const BABY_BUNNY_SIZE_MULTIPLIER = 0.25; // Fixed at 25% for babies
  const BABY_BUNNY1_FOLLOW_DISTANCE = 180; // Distance baby 1 follows behind parent
  const BABY_BUNNY2_FOLLOW_DISTANCE = 100; // Distance baby 2 follows behind baby 1
  const MAX_BUNNY_EVENTS_PER_DAY = 3;
  
  function scheduleBunnyEvents(){
    const now = new Date();
    const currentDay = now.toDateString();
    
    // Reset daily counter if it's a new day
    if(!window.lastBunnyDay || window.lastBunnyDay !== currentDay){
      window.lastBunnyDay = currentDay;
      bunnyEventsToday = 0;
      bunnyEvents = [];
      
      // Schedule bunnies during morning (7-11am) and afternoon (2-5pm)
      for(let i = 0; i < MAX_BUNNY_EVENTS_PER_DAY; i++){
        let hour;
        if(i < MAX_BUNNY_EVENTS_PER_DAY / 2){
          // Morning bunnies: 7-11am
          hour = 7 + Math.random() * 4;
        }else{
          // Afternoon bunnies: 2-5pm
          hour = 14 + Math.random() * 3;
        }
        const minute = Math.random() * 60;
        const eventTime = new Date(now);
        eventTime.setHours(Math.floor(hour), Math.floor(minute), 0, 0);
        // If event is in the past today, schedule for next occurrence
        if(eventTime < now){
          eventTime.setTime(now.getTime() + (Math.random() * 3600000)); // Within next hour
        }
        bunnyEvents.push({time: eventTime, triggered: false});
      }
      bunnyEvents.sort((a, b) => a.time - b.time);
      console.log('Bunny events scheduled:', bunnyEvents.map(e => e.time.toLocaleTimeString()));
    }
  }
  
  function checkBunnyEvents(){
    if(!bunnyEvents.length) return;
    
    const now = new Date();
    const currentHour = now.getHours();
    
    // Only allow bunnies between 10am (10) and 2pm (14)
    if(currentHour < 10 || currentHour >= 14) return;
    
    for(let event of bunnyEvents){
      if(!event.triggered && now >= event.time){
        event.triggered = true;
        console.log('Spawning bunny from scheduled event');
        spawnBunny();
        break;
      }
    }
  }
  
  function spawnBunny(){
    if(bunny) {
      console.log('Bunny already active, skipping spawn');
      return; // Already have a bunny
    }
    
    const terrainY = getTerrainY(W * 0.2);
    const scaledSize = BUNNY_SIZE * BUNNY_SIZE_MULTIPLIER;
    bunny = {
      x: -100, // Start off-screen left
      y: terrainY - (scaledSize * 0.5),
      state: 'hopping', // hopping, scratching, hopping_out
      scratchTimer: 0,
      targetX: W + scaledSize, // Traverse entire screen and exit right
      scratchStops: [], // Random scratch positions
      scratchCount: 0
    };
    // Generate 3-5 random scratch positions across the journey
    const startX = bunny.x;
    const endX = bunny.targetX;
    const numStops = 3 + Math.floor(Math.random() * 3); // 3-5 stops
    bunny.scratchStops = [];
    for(let i = 0; i < numStops; i++){
      const progress = (i + 1) / (numStops + 1); // Distribute stops across journey
      const randomOffset = (Math.random() - 0.5) * 0.1; // Â±5% variation
      const stopX = startX + (progress + randomOffset) * (endX - startX);
      bunny.scratchStops.push(stopX);
    }
    bunny.scratchStops.sort((a, b) => a - b); // Sort ascending (left to right)
    console.log('Bunny spawned! Position:', bunny.x, bunny.y, 'TerrainY:', terrainY, 'Size:', scaledSize, 'Scratch stops at:', bunny.scratchStops, 'Images loaded:', bunnyHopImg.complete, bunnyScratchImg.complete);
    
    // Spawn baby bunny 1 following behind parent
    const baby1ScaledSize = BUNNY_SIZE * BABY_BUNNY_SIZE_MULTIPLIER;
    babyBunny1 = {
      x: bunny.x - BABY_BUNNY1_FOLLOW_DISTANCE,
      y: terrainY - (baby1ScaledSize * 0.5),
      state: 'hopping',
      scratchTimer: 0,
      targetX: W + baby1ScaledSize,
      scratchStops: [],
      scratchCount: 0,
      hopImg: babyBunnyHopImg1,
      scratchImg: babyBunnyScratchImg1
    };
    // Generate 2-4 random scratch positions for baby 1
    const baby1StartX = babyBunny1.x;
    const baby1EndX = babyBunny1.targetX;
    const baby1NumStops = 2 + Math.floor(Math.random() * 3);
    babyBunny1.scratchStops = [];
    for(let i = 0; i < baby1NumStops; i++){
      const progress = (i + 1) / (baby1NumStops + 1);
      const randomOffset = (Math.random() - 0.5) * 0.1;
      const stopX = baby1StartX + (progress + randomOffset) * (baby1EndX - baby1StartX);
      babyBunny1.scratchStops.push(stopX);
    }
    babyBunny1.scratchStops.sort((a, b) => a - b);
    console.log('Baby bunny 1 spawned! Position:', babyBunny1.x, babyBunny1.y, 'Size:', baby1ScaledSize);
    
    // Spawn baby bunny 2 following behind baby 1
    const baby2ScaledSize = BUNNY_SIZE * BABY_BUNNY_SIZE_MULTIPLIER;
    babyBunny2 = {
      x: babyBunny1.x - BABY_BUNNY2_FOLLOW_DISTANCE,
      y: terrainY - (baby2ScaledSize * 0.5),
      state: 'hopping',
      scratchTimer: 0,
      targetX: W + baby2ScaledSize,
      scratchStops: [],
      scratchCount: 0,
      hopImg: babyBunnyHopImg2,
      scratchImg: babyBunnyScratchImg2
    };
    // Generate 2-3 random scratch positions for baby 2
    const baby2StartX = babyBunny2.x;
    const baby2EndX = babyBunny2.targetX;
    const baby2NumStops = 2 + Math.floor(Math.random() * 2);
    babyBunny2.scratchStops = [];
    for(let i = 0; i < baby2NumStops; i++){
      const progress = (i + 1) / (baby2NumStops + 1);
      const randomOffset = (Math.random() - 0.5) * 0.1;
      const stopX = baby2StartX + (progress + randomOffset) * (baby2EndX - baby2StartX);
      babyBunny2.scratchStops.push(stopX);
    }
    babyBunny2.scratchStops.sort((a, b) => a - b);
    console.log('Baby bunny 2 spawned! Position:', babyBunny2.x, babyBunny2.y, 'Size:', baby2ScaledSize);
  }
  
  function drawBunnyState(bunnyObj, bunnyType = 'parent'){
    const sizeMultiplier = bunnyType === 'parent' ? BUNNY_SIZE_MULTIPLIER : BABY_BUNNY_SIZE_MULTIPLIER;
    const scaledSize = BUNNY_SIZE * sizeMultiplier;
    const terrainY = getTerrainY(bunnyObj.x);
    bunnyObj.y = terrainY - (scaledSize * 0.5);
    
    // Use bunny-specific GIF elements or default to parent GIFs
    const hopImg = bunnyObj.hopImg || bunnyHopImg;
    const scratchImg = bunnyObj.scratchImg || bunnyScratchImg;
    
    if(bunnyObj.state === 'hopping'){
      bunnyObj.x += BUNNY_HOP_SPEED;
      
      // Check if we've reached a scratch stop
      if(bunnyObj.scratchStops && bunnyObj.scratchStops.length > 0 && bunnyObj.x >= bunnyObj.scratchStops[0]){
        bunnyObj.state = 'scratching';
        bunnyObj.scratchStart = performance.now();
        bunnyObj.scratchStops.shift();
        bunnyObj.scratchCount++;
      }
      // Reached final target, done hopping
      else if(bunnyObj.x >= bunnyObj.targetX){
        bunnyObj.state = 'hopping_out';
      }
      
      // Show hopping bunny GIF (flipped to face right)
      hopImg.style.display = 'block';
      hopImg.style.left = bunnyObj.x + 'px';
      hopImg.style.top = bunnyObj.y + 'px';
      hopImg.style.width = (scaledSize * 1.2) + 'px';
      hopImg.style.height = scaledSize + 'px';
      hopImg.style.transform = 'scaleX(-1)';
      scratchImg.style.display = 'none';
    }else if(bunnyObj.state === 'scratching'){
      const scratchElapsed = performance.now() - (bunnyObj.scratchStart || performance.now());
      if(scratchElapsed >= BUNNY_SCRATCH_MS){
        bunnyObj.state = 'hopping';
      }
      
      // Show scratching bunny GIF (flipped to face right)
      scratchImg.style.display = 'block';
      scratchImg.style.left = bunnyObj.x + 'px';
      scratchImg.style.top = bunnyObj.y + 'px';
      scratchImg.style.width = (scaledSize * 1.2) + 'px';
      scratchImg.style.height = scaledSize + 'px';
      scratchImg.style.transform = 'scaleX(-1)';
      hopImg.style.display = 'none';
    }else if(bunnyObj.state === 'hopping_out'){
      bunnyObj.x += BUNNY_HOP_SPEED;
      
      // Remove bunny when fully off-screen
      if(bunnyObj.x > W + scaledSize){
        return false; // Signal to remove this bunny
      }
      
      // Show hopping bunny GIF (flipped to face right)
      hopImg.style.display = 'block';
      hopImg.style.left = bunnyObj.x + 'px';
      hopImg.style.top = bunnyObj.y + 'px';
      hopImg.style.width = (scaledSize * 1.2) + 'px';
      hopImg.style.height = scaledSize + 'px';
      hopImg.style.transform = 'scaleX(-1)';
      scratchImg.style.display = 'none';
    }
    return true; // Keep bunny
  }
  
  function updateAndDrawBunny(ctx){
    // Update and draw parent bunny
    if(bunny){
      const parentActive = drawBunnyState(bunny, 'parent');
      if(!parentActive){
        // Parent is exiting, transition babies to hopping_out
        if(babyBunny1) babyBunny1.state = 'hopping_out';
        if(babyBunny2) babyBunny2.state = 'hopping_out';
        bunny = null;
        bunnyEventsToday++;
      }
    }
    
    // Update and draw baby bunny 1
    if(babyBunny1){
      // Only follow parent if parent exists and baby is still hopping normally
      if(bunny && babyBunny1.state === 'hopping'){
        const idealBaby1X = bunny.x - BABY_BUNNY1_FOLLOW_DISTANCE;
        if(babyBunny1.x < idealBaby1X){
          babyBunny1.x += BUNNY_HOP_SPEED;
        }
      }
      // If parent is hopping out or gone, baby should hop out too
      if(!bunny || (bunny && bunny.state === 'hopping_out')){
        babyBunny1.state = 'hopping_out';
      }
      
      const baby1Active = drawBunnyState(babyBunny1, 'baby');
      if(!baby1Active){
        babyBunny1 = null;
      }
    }
    
    // Update and draw baby bunny 2
    if(babyBunny2){
      // Only follow baby1 if baby1 exists and baby2 is still hopping normally
      if(babyBunny1 && babyBunny2.state === 'hopping'){
        const idealBaby2X = babyBunny1.x - BABY_BUNNY2_FOLLOW_DISTANCE;
        if(babyBunny2.x < idealBaby2X){
          babyBunny2.x += BUNNY_HOP_SPEED;
        }
      }
      // If baby1 is hopping out or gone, baby2 should hop out too
      if(!babyBunny1 || (babyBunny1 && babyBunny1.state === 'hopping_out')){
        babyBunny2.state = 'hopping_out';
      }
      
      const baby2Active = drawBunnyState(babyBunny2, 'baby');
      if(!baby2Active){
        babyBunny2 = null;
      }
    }
  }
  
  // Hide bunny GIFs when no bunny (runs at init time with safety check)
  function hideBunnyIfNeeded(){
    if(typeof bunny !== 'undefined' && !bunny){
      if(typeof bunnyHopImg !== 'undefined' && bunnyHopImg) bunnyHopImg.style.display = 'none';
      if(typeof bunnyScratchImg !== 'undefined' && bunnyScratchImg) bunnyScratchImg.style.display = 'none';
    }
    if(typeof babyBunny1 !== 'undefined' && !babyBunny1){
      if(typeof babyBunnyHopImg1 !== 'undefined' && babyBunnyHopImg1) babyBunnyHopImg1.style.display = 'none';
      if(typeof babyBunnyScratchImg1 !== 'undefined' && babyBunnyScratchImg1) babyBunnyScratchImg1.style.display = 'none';
    }
    if(typeof babyBunny2 !== 'undefined' && !babyBunny2){
      if(typeof babyBunnyHopImg2 !== 'undefined' && babyBunnyHopImg2) babyBunnyHopImg2.style.display = 'none';
      if(typeof babyBunnyScratchImg2 !== 'undefined' && babyBunnyScratchImg2) babyBunnyScratchImg2.style.display = 'none';
    }
  }
  
  // Schedule events on load
  scheduleBunnyEvents();
  
  // Export functions
  window._updateAndDrawBunny = updateAndDrawBunny;
  window._checkBunnyEvents = checkBunnyEvents;
  window._scheduleBunnyEvents = scheduleBunnyEvents;
  window._spawnBunny = spawnBunny;
  
  console.log('Bunny system initialized. Functions exported:', {
    updateAndDrawBunny: typeof window._updateAndDrawBunny,
    checkBunnyEvents: typeof window._checkBunnyEvents,
    scheduleBunnyEvents: typeof window._scheduleBunnyEvents,
    spawnBunny: typeof window._spawnBunny
  });
})();

// ============== NEW FEATURES ==============

// 1. FRAME RATE MONITORING
let frameCount = 0;
let lastTime = Date.now();
let fps = 0;
function updateFPS(){
  frameCount++;
  const now = Date.now();
  if(now - lastTime >= 1000){
    fps = frameCount;
    document.getElementById('fpsCounter').textContent = `FPS: ${fps}`;
    frameCount = 0;
    lastTime = now;
    // Show FPS counter on lower-end devices (FPS < 30)
    if(fps < 30){
      document.getElementById('fpsCounter').classList.add('visible');
    }else{
      document.getElementById('fpsCounter').classList.remove('visible');
    }
  }
}

// 2. TUTORIAL OVERLAY
function showTutorial(){
  document.getElementById('tutorialOverlay').classList.add('visible');
}
function closeTutorial(){
  document.getElementById('tutorialOverlay').classList.remove('visible');
  localStorage.setItem('tutorialShown', 'true');
  if(document.getElementById('quickActionsModal')){
    document.getElementById('quickActionsModal').classList.remove('visible');
  }
}
function skipTutorial(){
  closeTutorial();
}
// Show tutorial on first visit
window.addEventListener('load', function(){
  // Check if tutorial has ever been shown (allow re-showing for testing)
  const hasShown = localStorage.getItem('tutorialShown');
  if(!hasShown){
    // Wait 2.5 seconds for page to fully initialize
    setTimeout(function(){
      showTutorial();
    }, 2500);
  }
});

// 3. SCREENSHOT FEATURE
function captureScreenshot(){
  try {
    const link = document.createElement('a');
    link.href = canvas.toDataURL('image/png');
    link.download = `wv-nature-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.png`;
    link.click();
    showNotification('ğŸ“¸ Screenshot saved!');
  }catch(e){
    console.error('Screenshot failed:', e);
    showNotification('âŒ Screenshot failed');
  }
}

// 4. SAVE/LOAD SCENES
function showSaveSceneModal(){
  const now = new Date();
  const defaultName = `Scene-${now.toLocaleDateString()}-${now.toLocaleTimeString()}`;
  document.getElementById('sceneName').value = defaultName;
  document.getElementById('saveSceneModal').classList.add('visible');
  document.getElementById('quickActionsModal').classList.remove('visible');
}
function saveSceneFromModal(){
  const sceneName = document.getElementById('sceneName').value.trim();
  if(sceneName){
    saveScene(sceneName);
    document.getElementById('saveSceneModal').classList.remove('visible');
  }
}
function saveScene(name){
  const sceneData = {
    name: name,
    timestamp: new Date().toISOString(),
    items: items.map(item => ({
      type: item.type,
      subtype: item.subtype,
      x: item.baseX,
      y: item.baseY,
      age: item.age,
      maxAge: item.maxAge,
      customText: item.customText
    }))
  };
  let scenes = JSON.parse(localStorage.getItem('savedScenes')) || [];
  scenes.push(sceneData);
  localStorage.setItem('savedScenes', JSON.stringify(scenes));
  showNotification(`ğŸ’¾ Scene "${name}" saved!`);
}
function showLoadSceneModal(){
  let scenes = JSON.parse(localStorage.getItem('savedScenes')) || [];
  const sceneList = document.getElementById('sceneList');
  
  if(scenes.length === 0){
    sceneList.innerHTML = '<p style="text-align:center;color:#0cf;padding:20px;">No saved scenes yet. Save one first!</p>';
  } else {
    let html = '<div style="display:flex;flex-direction:column;gap:8px;">';
    scenes.forEach((s, i) => {
      const date = new Date(s.timestamp).toLocaleString();
      html += `<button class="modal-btn" onclick="loadSceneByIndex(${i});document.getElementById('loadSceneModal').classList.remove('visible')">
        <strong>${s.name}</strong><br>
        <small style="opacity:0.7;font-size:10px;">${date} - ${s.items.length} items</small>
      </button>`;
    });
    html += '</div>';
    sceneList.innerHTML = html;
  }
  
  document.getElementById('loadSceneModal').classList.add('visible');
  document.getElementById('quickActionsModal').classList.remove('visible');
}

function loadSceneByIndex(idx){
  let scenes = JSON.parse(localStorage.getItem('savedScenes')) || [];
  if(idx >= 0 && idx < scenes.length){
    loadScene(scenes[idx]);
  }
}
function loadScene(sceneData){
  items = [];
  console.log('Loading scene:', sceneData.name, 'with', sceneData.items.length, 'items');
  sceneData.items.forEach((itemData, idx) => {
    console.log(`Item ${idx}: ${itemData.type} ${itemData.subtype} at (${itemData.x}, ${itemData.y})`);
    const item = new Item(itemData.x, itemData.y, itemData.type, itemData.subtype);
    item.age = itemData.age;
    item.maxAge = itemData.maxAge;
    item.customText = itemData.customText;
    items.push(item);
    console.log(`Item ${idx} created: baseX=${item.baseX}, baseY=${item.baseY}`);
  });
  console.log('Items array after load:', items.length, 'items');
  saveSettings();
  showNotification(`ğŸ“‚ Scene "${sceneData.name}" loaded!`);
}

// 5. PLANT POPUPS ON HOVER
let hoveredPlant = null;
function checkPlantHover(mouseX, mouseY){
  hoveredPlant = null;
  for(let item of items){
    if(item.type === 'plant'){
      const dist = Math.hypot(mouseX - item.screenX, mouseY - item.screenY);
      if(dist < 40){
        hoveredPlant = item;
        showPlantTooltip(item, mouseX, mouseY);
        return;
      }
    }
  }
  hidePlantTooltip();
}
function showPlantTooltip(plant, x, y){
  const tooltip = document.getElementById('plantTooltip');
  const ageMonths = Math.floor(plant.age / 30);
  const age = ageMonths > 0 ? `${ageMonths}mo` : '<1mo';
  tooltip.innerHTML = `<strong>${plant.subtype}</strong><br>Age: ${age}<br>Health: ${Math.floor(plant.age / plant.maxAge * 100)}%`;
  tooltip.style.left = (x + 10) + 'px';
  tooltip.style.top = (y - 30) + 'px';
  tooltip.style.display = 'block';
}
function hidePlantTooltip(){
  document.getElementById('plantTooltip').style.display = 'none';
}
// ========== COMMUNITY HISTORY FEATURE ==========
let communityHistoryData = null;
let lastCommunityHistoryShow = 0;
const COMMUNITY_HISTORY_INTERVAL = 30 * 60 * 1000; // 30 minutes

async function reverseGeocode(lat, lon){
  try{
    const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`);
    const data = await response.json();
    const address = data.address || {};
    const town = address.city || address.town || address.village || address.county || 'Unknown';
    const county = address.county || '';
    const state = address.state || 'West Virginia';
    return { town, county, state };
  }catch(e){
    console.error('Reverse geocode error:', e);
    return null;
  }
}

async function fetchWikipediaData(town, county){
  try{
    const searchTerms = [`${town} West Virginia`, `${town}, West Virginia`, town];
    for(let term of searchTerms){
      const response = await fetch(`https://en.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(term)}&prop=extracts|pageimages&explaintext=true&format=json&origin=*`);
      const data = await response.json();
      const pages = data.query.pages;
      for(let pageId in pages){
        const page = pages[pageId];
        if(page.extract){
          const extract = page.extract.substring(0, 800);
          const foundingMatch = extract.match(/founded|established|settled|incorporated/i);
          return { title: page.title, extract: extract, hasInfo: !!foundingMatch };
        }
      }
    }
  }catch(e){
    console.error('Wikipedia fetch error:', e);
  }
  return null;
}

function getHistoricalAstronomy(lat, lon, historicalYear){
  if(!historicalYear || historicalYear < 1700) return null;
  const visibleConstellations = ['Orion', 'Ursa Major', 'Ursa Minor', 'Cassiopeia', 'Lyra', 'Cygnus', 'Aquila', 'Sagittarius'];
  const brightStars = ['Sirius', 'Vega', 'Altair', 'Deneb', 'Polaris', 'Arcturus'];
  const randomConstellation = visibleConstellations[Math.floor(Math.random() * visibleConstellations.length)];
  const randomStar = brightStars[Math.floor(Math.random() * brightStars.length)];
  return { year: historicalYear, constellation: randomConstellation, star: randomStar };
}

function extractYearFromWiki(text){
  const yearMatch = text.match(/(?:founded|established|incorporated|settled|chartered)\s+in\s+(\d{4})/i);
  if(yearMatch) return parseInt(yearMatch[1]);
  const justYear = text.match(/\b(1[7-9]\d{2}|20\d{2})\b/);
  return justYear ? parseInt(justYear[1]) : null;
}

function formatWikiExtract(text){
  if(!text) return '';
  const trimmed = text.replace(/\n+/g, '\n').trim();
  return trimmed.split('\n').map(p => `<p style="margin:0 0 8px 0;">${p}</p>`).join('');
}

function displayCommunityHistoryModal(data){
  const modal = document.getElementById('communityHistoryModal');
  const historyContent = document.getElementById('historyContent');
  const astronomyConnection = document.getElementById('astronomyConnection');
  const scrollBox = document.getElementById('communityHistoryScroll');
  let historyHTML = `<h3 style="color:#0ff;margin-top:0;">ğŸ“ ${data.town}, ${data.county || 'West Virginia'}</h3>`;
  historyHTML += formatWikiExtract(data.wikiData.extract);
  historyContent.innerHTML = historyHTML;
  let astronomyHTML = 'ğŸŒŸ <strong>Astronomical Connection:</strong><br>';
  if(data.astronomy){
    astronomyHTML += `You are seeing the same stars tonight as those who founded this community. Look for <strong>${data.astronomy.constellation}</strong> and the bright star <strong>${data.astronomy.star}</strong>.`;
  }else{
    astronomyHTML += 'Tonight, you share the same starry sky with those who came before.';
  }
  astronomyConnection.innerHTML = astronomyHTML;
  modal.style.display = 'block';
  modal.classList.add('visible');
  if(scrollBox) scrollBox.scrollTop = 0;
}

async function showCommunityHistory(){
  const now = Date.now();
  if(now - lastCommunityHistoryShow < COMMUNITY_HISTORY_INTERVAL) return;
  if(!communityHistoryData){
    const geoData = await reverseGeocode(LAT, LON);
    if(!geoData) return;
    const wikiData = await fetchWikipediaData(geoData.town, geoData.county);
    if(!wikiData || !wikiData.hasInfo) return;
    communityHistoryData = {
      town: geoData.town,
      county: geoData.county,
      state: geoData.state,
      wikiData: wikiData,
      astronomy: getHistoricalAstronomy(LAT, LON, extractYearFromWiki(wikiData.extract))
    };
  }
  if(!communityHistoryData.wikiData) return;
  lastCommunityHistoryShow = now;
  displayCommunityHistoryModal(communityHistoryData);
}

setInterval(() => { if(ready) showCommunityHistory(); }, 60000);

// 6. SEASONAL NOTIFICATIONS
function checkSeasonalNotifications(){
  const month = new Date().getMonth();
  const day = new Date().getDate();
  
  // Spring planting season (April)
  if(month === 3 && day === 1 && !localStorage.getItem('springNotif2026')){
    showSeasonalAlert('ğŸŒ± Spring is here! Time to plant your garden!');
    localStorage.setItem('springNotif2026', 'true');
  }
  // Summer maintenance (July)
  else if(month === 6 && day === 1 && !localStorage.getItem('summerNotif2026')){
    showSeasonalAlert('â˜€ï¸ Summer season! Keep plants watered!');
    localStorage.setItem('summerNotif2026', 'true');
  }
  // Fall harvest (September)
  else if(month === 8 && day === 1 && !localStorage.getItem('fallNotif2026')){
    showSeasonalAlert('ğŸ‚ Fall is here! Time to prepare for winter!');
    localStorage.setItem('fallNotif2026', 'true');
  }
  // Winter (December)
  else if(month === 11 && day === 1 && !localStorage.getItem('winterNotif2026')){
    showSeasonalAlert('â„ï¸ Winter season! Most plants are dormant.');
    localStorage.setItem('winterNotif2026', 'true');
  }
}
function showSeasonalAlert(message){
  const alert = document.getElementById('seasonalAlert');
  alert.textContent = message;
  alert.classList.add('visible');
  setTimeout(() => {
    alert.classList.remove('visible');
  }, 5000);
}

// Helper notification
function showNotification(message){
  const notif = document.getElementById('sceneNotification');
  notif.textContent = message;
  notif.classList.add('visible');
  setTimeout(() => {
    notif.classList.remove('visible');
  }, 3000);
}

// Initialize features on load
window.addEventListener('load', function(){
  checkSeasonalNotifications();
  // Check seasonals periodically
  setInterval(checkSeasonalNotifications, 60000);
  initAds();
});

// Support link function
function openSupportLink(){
  window.open('https://buymeacoffee.com/ctf57918', '_blank');
}

// Ads initialization (non-intrusive banners)
function initAds(){
  try {
    initWebAds();
    initMobileAds();
  } catch (e) {
    console.warn('Ads init failed:', e);
  }
}

function initWebAds(){
  // Web-only: AdSense banner (disabled on file:// and Electron)
  if (window.isElectron) return;
  if (window.location.protocol !== 'http:' && window.location.protocol !== 'https:') return;

  const adBanner = document.getElementById('adBanner');
  if (!adBanner) return;

  const clientId = 'ca-pub-XXXXXXXXXXXXXXXX'; // TODO: replace with your AdSense client ID
  const slotId = '0000000000'; // TODO: replace with your AdSense slot ID

  adBanner.innerHTML = `<ins class="adsbygoogle" style="display:block" data-ad-client="${clientId}" data-ad-slot="${slotId}" data-ad-format="auto" data-full-width-responsive="true"></ins>`;

  const script = document.createElement('script');
  script.async = true;
  script.src = `https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=${clientId}`;
  script.crossOrigin = 'anonymous';
  script.onload = () => {
    try {
      (window.adsbygoogle = window.adsbygoogle || []).push({});
      adBanner.classList.remove('ad-hidden');
    } catch (e) {
      console.warn('AdSense init failed:', e);
    }
  };
  document.head.appendChild(script);
}

async function initMobileAds(){
  // Mobile only: AdMob banner (Capacitor)
  if (!window.Capacitor || !window.Capacitor.isNativePlatform || !window.Capacitor.isNativePlatform()) return;
  if (window.isElectron) return;

  const AdMob = window.Capacitor?.Plugins?.AdMob;
  if (!AdMob) return;

  try {
    await AdMob.initialize({
      requestTrackingAuthorization: true,
      initializeForTesting: true
    });

    await AdMob.showBanner({
      adId: 'ca-app-pub-XXXXXXXXXXXXXXXX/BBBBBBBBBB', // TODO: replace with your AdMob banner ID
      position: 'BOTTOM_CENTER',
      adSize: 'BANNER',
      margin: 0,
      isTesting: true
    });
  } catch (e) {
    console.warn('AdMob init failed:', e);
  }
}

// Service Worker Registration for PWA - Only in web, not Electron
if ('serviceWorker' in navigator && !window.isElectron) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('sw.js')
      .then(registration => {
        console.log('Service Worker registered:', registration);
      })
      .catch(err => {
        console.warn('Service Worker registration failed:', err);
      });
  });
} else if (window.isElectron && 'serviceWorker' in navigator) {
  // Unregister any existing service workers in Electron
  navigator.serviceWorker.getRegistrations().then(registrations => {
    for (let reg of registrations) {
      reg.unregister();
    }
  });
}
</script>
</body>
</html>
